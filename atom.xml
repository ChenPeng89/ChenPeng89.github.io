<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenPeng&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenpeng89.github.io/"/>
  <updated>2017-01-03T07:15:13.187Z</updated>
  <id>http://chenpeng89.github.io/</id>
  
  <author>
    <name>ChenPeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elasticsearch学习笔记：四、Search-APIs.md</title>
    <link href="http://chenpeng89.github.io/2016/11/21/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%9B%E3%80%81Search-APIs/"/>
    <id>http://chenpeng89.github.io/2016/11/21/Elasticsearch学习笔记：四、Search-APIs/</id>
    <published>2016-11-21T02:30:17.000Z</published>
    <updated>2017-01-03T07:15:13.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><p>当执行搜索时，将会对所有索引分片进行广播（轮询所有备份）。这个可以通过设置 routing 参数来指定搜索的分片。<br>例如，在创建索引时可以指定routing：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl -XPOST &apos;http://localhost:9200/twitter/tweet?routing=kimchy&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;postDate&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>然后我们在后面查询时指定相应routing：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ curl -XGET &apos;http://localhost:9200/twitter/tweet/_search?routing=kimchy&apos; -d &apos;&#123;</div><div class="line">    &quot;query&quot;: &#123;</div><div class="line">        &quot;bool&quot; : &#123;</div><div class="line">            &quot;must&quot; : &#123;</div><div class="line">                &quot;query_string&quot; : &#123;</div><div class="line">                    &quot;query&quot; : &quot;some query string here&quot;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &quot;filter&quot; : &#123;</div><div class="line">                &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>routing参数可以设置为多个，用 , 隔开。</p>
<h3 id="Stats-Group"><a href="#Stats-Group" class="headerlink" title="Stats Group"></a>Stats Group</h3><p>还可以关联数据组，数据组可以通过后面index API中的indices stats API 来设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match_all&quot; : &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;stats&quot; : [&quot;group1&quot;, &quot;group2&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Global-Search-Timeout"><a href="#Global-Search-Timeout" class="headerlink" title="Global Search Timeout"></a>Global Search Timeout</h3><p>es可以设置一个集群级的超时时间，在<code>search.default_search_timeout</code> 中，设为-1 的话表示没有超时时间。</p>
<h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h3 id="Multi-Index，Multi-Type"><a href="#Multi-Index，Multi-Type" class="headerlink" title="Multi-Index，Multi-Type"></a>Multi-Index，Multi-Type</h3><p>所有search APIs 都可以跨 index和type来进行查询。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /twitter/_search?q=user:kimchy</div></pre></td></tr></table></figure></p>
<p>也可以指定多个type:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /twitter/tweet,user/_search?q=user:kimchy</div></pre></td></tr></table></figure></p>
<p>还可以通过一个tag来搜索相关的几个index:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /kimchy,elasticsearch/tweet/_search?q=tag:wow</div></pre></td></tr></table></figure></p>
<p>或者搜索所有index，使用_all：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_all/tweet/_search?q=tag:wow</div></pre></td></tr></table></figure></p>
<p>甚至所有index和type：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?q=tag:wow</div></pre></td></tr></table></figure></p>
<p>默认情况下，es会拒绝搜索超过1000个分片的查询。因为这会严重影响es的性能。通常的做法是，将分片设置的更大，数量更少，可以通过<code>action.search.shard_count.limit</code>来设置。</p>
<h2 id="URI-Search"><a href="#URI-Search" class="headerlink" title="URI Search"></a>URI Search</h2><p>一个搜索请求可以通过URI中带有参数来实现，当然，并不是所有搜索都能使用这个模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET twitter/tweet/_search?q=user:kimchy</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 38,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 1.4054651,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">        &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">        &quot;_id&quot;: &quot;AViEvWlRDD544hrngUp_&quot;,</div><div class="line">        &quot;_score&quot;: 1.4054651,</div><div class="line">        &quot;_routing&quot;: &quot;kimchy&quot;,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;user&quot;: &quot;kimchy&quot;,</div><div class="line">          &quot;postDate&quot;: &quot;2009-11-15T14:12:12&quot;,</div><div class="line">          &quot;message&quot;: &quot;trying out Elasticsearch&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>q: 查询字符串。</li>
<li>df: 在查询中没定义字段时默认使用的字段。</li>
<li>analyzer ： 指定使用的查询分析器。</li>
<li>lowercase_expanded_terms ： 瓷套是否自动变成小写。默认是true。</li>
<li>analyze_wildcard ： 通配符和前缀查询是否要被分析器分析。默认是false。</li>
<li>default_operator ： 默认的操作符，AND /OR ，默认是OR。</li>
<li>lenient : 如果设置为true，则会忽略类型错误，比如向数字字段传文本数据。</li>
<li>explain : 对于所有命中的数据，计算命中分数。</li>
<li>_source： 返回的结果中是否包含source。还可以设置source中的字段。</li>
<li>stored_fields ： 选择命中后返回的字段，使用 ， 分隔。</li>
<li>sort ： 排序。</li>
<li>track_scores : 当设置sort时，将它设为true，将会返回track score。</li>
<li>timeout： 超时时间。默认是没有超时时间。</li>
<li>terminate_after :  一个Shard可以在获取到多少条数据后，停止查询。</li>
<li>from/size : 分页参数。</li>
<li>search_type : search的类型：dfs_query_then_fetch和query_then_fetch。默认是后者。</li>
</ul>
<h2 id="Request-Body-Search"><a href="#Request-Body-Search" class="headerlink" title="Request Body Search"></a>Request Body Search</h2><p>search请求可以通过search DSL ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /twitter/tweet/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 856,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 1.4054651,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">        &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">        &quot;_id&quot;: &quot;AViEvWlRDD544hrngUp_&quot;,</div><div class="line">        &quot;_score&quot;: 1.4054651,</div><div class="line">        &quot;_routing&quot;: &quot;kimchy&quot;,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;user&quot;: &quot;kimchy&quot;,</div><div class="line">          &quot;postDate&quot;: &quot;2009-11-15T14:12:12&quot;,</div><div class="line">          &quot;message&quot;: &quot;trying out Elasticsearch&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="快速确定是否有匹配的文档"><a href="#快速确定是否有匹配的文档" class="headerlink" title="快速确定是否有匹配的文档"></a>快速确定是否有匹配的文档</h3><p>如果我们只是想查看是否有匹配的文档，而不在乎返回的数据，可以将size设为0。还可以将termnate_after设为1。在查找到第一条后不再进行搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?q=message:elasticsearch&amp;size=0&amp;terminate_after=1</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 846,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;terminated_early&quot;: true,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 36,</div><div class="line">    &quot;successful&quot;: 36,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 2,</div><div class="line">    &quot;max_score&quot;: 0,</div><div class="line">    &quot;hits&quot;: []</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p>在request body中可以使用query DSL定义查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="From-Size"><a href="#From-Size" class="headerlink" title="From/Size"></a>From/Size</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;from&quot; : 0, &quot;size&quot; : 10,</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><p>可以将一个或者多个字段进行排序。每个排序都可以正序倒序。排序定义在字段级别，可以通过指定字段名进行评分_score，并根据评分进行排序。或者_doc来根据索引顺序排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">PUT  localhost:9200/my_index</div><div class="line">&#123;</div><div class="line">    &quot;mappings&quot;: &#123;</div><div class="line">        &quot;my_type&quot;: &#123;</div><div class="line">            &quot;properties&quot;: &#123;</div><div class="line">                &quot;post_date&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;,</div><div class="line">                &quot;user&quot;: &#123;</div><div class="line">                    &quot;type&quot;: &quot;string&quot;</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot;: &#123;</div><div class="line">                    &quot;type&quot;: &quot;string&quot;</div><div class="line">                &#125;,</div><div class="line">                &quot;age&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查询时，可以设置每个字段的排序方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">POST localhost:9200/my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123; &quot;post_date&quot; : &#123;&quot;order&quot; : &quot;asc&quot;&#125;&#125;,</div><div class="line">        &quot;user&quot;,</div><div class="line">        &#123; &quot;name&quot; : &quot;desc&quot; &#125;,</div><div class="line">        &#123; &quot;age&quot; : &quot;desc&quot; &#125;,</div><div class="line">        &quot;_score&quot;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般来说，_doc没有实际的用处。但是，如果你不需要进行排序的话，按_doc排序是会增加处理效率的，因此，如果你不关心文档的返回顺序，你可以指定按_doc来排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST localhost:9200/my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        </div><div class="line">        &quot;_doc&quot;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="排序参数"><a href="#排序参数" class="headerlink" title="排序参数"></a>排序参数</h4><p>es支持按照数组排序或者多个值进行排序。mode 选项控制了选择类型为数组的字段中的哪个值来进行排序。有以下值：</p>
<ul>
<li>min 最小值</li>
<li>max 最大值</li>
<li>sum 总和</li>
<li>avg 平均值</li>
<li>median 中间值</li>
</ul>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PUT /my_index/my_type/1?refresh</div><div class="line">&#123;</div><div class="line">   &quot;product&quot;: &quot;chocolate&quot;,</div><div class="line">    &quot;price&quot;: [20, 4]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>排序操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST /_search</div><div class="line">&#123;</div><div class="line">   &quot;query&quot; : &#123;</div><div class="line">      &quot;term&quot; : &#123; &quot;product&quot; : &quot;chocolate&quot; &#125;</div><div class="line">   &#125;,</div><div class="line">   &quot;sort&quot; : [</div><div class="line">      &#123;&quot;price&quot; : &#123;&quot;order&quot; : &quot;asc&quot;, &quot;mode&quot; : &quot;avg&quot;&#125;&#125;</div><div class="line">   ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="对内嵌对象进行排序"><a href="#对内嵌对象进行排序" class="headerlink" title="对内嵌对象进行排序"></a>对内嵌对象进行排序</h4><p>es也支持对内嵌对象的字段进行排序。</p>
<ul>
<li>nested_path 定义进行排序的内嵌对象的路径。进行排序的字段必须在这个对象中。</li>
<li>nested_filter 针对内嵌对象的一个过滤器。</li>
</ul>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">POST /_search</div><div class="line">&#123;</div><div class="line">   &quot;query&quot; : &#123;</div><div class="line">      &quot;term&quot; : &#123; &quot;product&quot; : &quot;chocolate&quot; &#125;</div><div class="line">   &#125;,</div><div class="line">   &quot;sort&quot; : [</div><div class="line">       &#123;</div><div class="line">          &quot;offer.price&quot; : &#123;</div><div class="line">             &quot;mode&quot; :  &quot;avg&quot;,</div><div class="line">             &quot;order&quot; : &quot;asc&quot;,</div><div class="line">             &quot;nested_path&quot; : &quot;offer&quot;,</div><div class="line">             &quot;nested_filter&quot; : &#123;</div><div class="line">                &quot;term&quot; : &#123; &quot;offer.color&quot; : &quot;blue&quot; &#125;</div><div class="line">             &#125;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面针对offer里面的price的平均值进行升序排序，并限定了offer的color字段为blue。</p>
<h4 id="针对字段为空的文档的处理"><a href="#针对字段为空的文档的处理" class="headerlink" title="针对字段为空的文档的处理"></a>针对字段为空的文档的处理</h4><p>missing参数可以设置当某个字段为空时，在排序时怎么控制文档的位置。它有以下参数：_last和_first或者自定义的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123; &quot;price&quot; : &#123;&quot;missing&quot; : &quot;_last&quot;&#125; &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;product&quot; : &quot;chocolate&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面将没有price字段的文档放到最后。</p>
<font color="red"><strong>注意：如果内嵌对象不满足nested_filter时，也将使用missing 参数的值。</strong></font>

<h4 id="忽略UnMapped-字段"><a href="#忽略UnMapped-字段" class="headerlink" title="忽略UnMapped 字段"></a>忽略UnMapped 字段</h4><p>默认情况下，如果相关的字段没有进行mapping，那么search请求将会失败。unmapped-type参数用来决定使用什么值来进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123; &quot;price&quot; : &#123;&quot;unmapped_type&quot; : &quot;long&quot;&#125; &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;product&quot; : &quot;chocolate&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子的意思是，如果当price没有进行mapping操作，那么，将会把它视为 long 来进行处理。</p>
<h4 id="经纬度距离排序"><a href="#经纬度距离排序" class="headerlink" title="经纬度距离排序"></a>经纬度距离排序</h4><p>可以根据经纬度位置上的距离来排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_geo_distance&quot; : &#123;</div><div class="line">                &quot;pin.location&quot; : [-70, 40],</div><div class="line">                &quot;order&quot; : &quot;asc&quot;,</div><div class="line">                &quot;unit&quot; : &quot;km&quot;,</div><div class="line">                &quot;mode&quot; : &quot;min&quot;,</div><div class="line">                &quot;distance_type&quot; : &quot;sloppy_arc&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>distance_type：如何计算距离，包括sloppy（默认的），arc（更精准但是更慢）和plane（很快，但是对于长距离和接近两极的计算不准确）。</li>
<li>mode：当一个字段有多个经纬度的时候怎么办。默认的话，升序排序的时候考虑最近的，降序排序的时候考虑最远的。有min，max，median和avg等。</li>
<li>unit：用来计算的单位。默认是m（米）。</li>
</ul>
<h4 id="经纬度作为参数"><a href="#经纬度作为参数" class="headerlink" title="经纬度作为参数"></a>经纬度作为参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_geo_distance&quot; : &#123;</div><div class="line">                &quot;pin.location&quot; : &#123;</div><div class="line">                    &quot;lat&quot; : 40,</div><div class="line">                    &quot;lon&quot; : -70</div><div class="line">                &#125;,</div><div class="line">                &quot;order&quot; : &quot;asc&quot;,</div><div class="line">                &quot;unit&quot; : &quot;km&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="经纬度是string"><a href="#经纬度是string" class="headerlink" title="经纬度是string"></a>经纬度是string</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_geo_distance&quot; : &#123;</div><div class="line">                &quot;pin.location&quot; : &quot;40,-70&quot;,</div><div class="line">                &quot;order&quot; : &quot;asc&quot;,</div><div class="line">                &quot;unit&quot; : &quot;km&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="地理位置是hash值"><a href="#地理位置是hash值" class="headerlink" title="地理位置是hash值"></a>地理位置是hash值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_geo_distance&quot; : &#123;</div><div class="line">                &quot;pin.location&quot; : &quot;drm3btev3e86&quot;,</div><div class="line">                &quot;order&quot; : &quot;asc&quot;,</div><div class="line">                &quot;unit&quot; : &quot;km&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="经纬度是数组"><a href="#经纬度是数组" class="headerlink" title="经纬度是数组"></a>经纬度是数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_geo_distance&quot; : &#123;</div><div class="line">                &quot;pin.location&quot; : [-70, 40],</div><div class="line">                &quot;order&quot; : &quot;asc&quot;,</div><div class="line">                &quot;unit&quot; : &quot;km&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="多个参考点"><a href="#多个参考点" class="headerlink" title="多个参考点"></a>多个参考点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_geo_distance&quot; : &#123;</div><div class="line">                &quot;pin.location&quot; : [[-70, 40], [-71, 42]],</div><div class="line">                &quot;order&quot; : &quot;asc&quot;,</div><div class="line">                &quot;unit&quot; : &quot;km&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，这个经纬度的排序会按mode的那几个参数来进行。</p>
<h4 id="基于脚本的排序"><a href="#基于脚本的排序" class="headerlink" title="基于脚本的排序"></a>基于脚本的排序</h4><p>可以基于脚本进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;sort&quot; : &#123;</div><div class="line">        &quot;_script&quot; : &#123;</div><div class="line">            &quot;type&quot; : &quot;number&quot;,</div><div class="line">            &quot;script&quot; : &#123;</div><div class="line">                &quot;lang&quot;: &quot;painless&quot;,</div><div class="line">                &quot;inline&quot;: &quot;doc[&apos;field_name&apos;].value * params.factor&quot;,</div><div class="line">                &quot;params&quot; : &#123;</div><div class="line">                    &quot;factor&quot; : 1.1</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &quot;order&quot; : &quot;asc&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="计算得分"><a href="#计算得分" class="headerlink" title="计算得分"></a>计算得分</h4><p>当按照字段来排序时，分数是不会被计算的。可以设置 track_scores为true来计算分数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;track_scores&quot;: true,</div><div class="line">    &quot;sort&quot; : [</div><div class="line">        &#123; &quot;post_date&quot; : &#123;&quot;order&quot; : &quot;desc&quot;&#125; &#125;,</div><div class="line">        &#123; &quot;name&quot; : &quot;desc&quot; &#125;,</div><div class="line">        &#123; &quot;age&quot; : &quot;desc&quot; &#125;</div><div class="line">    ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="针对内存方面的考虑"><a href="#针对内存方面的考虑" class="headerlink" title="针对内存方面的考虑"></a>针对内存方面的考虑</h4><p>当执行排序时，排序相关的字段都会被加载到内存中。这就意味着，每个分片都应该有足够的内存来容纳它们。对于string类型，字段排序不应该进行 analyzed/tokenized 操作。对于数字类型，如果可能，尽量将它们设置为具体的类型（short、integer和float等）。</p>
<h3 id="Source-filtering"><a href="#Source-filtering" class="headerlink" title="Source filtering"></a>Source filtering</h3><p>允许控制_source的命中返回。<br>一般操作都将返回_source，除非你使用stored_fields 或者将_source设为false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;_source&quot;: false,</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以设置哪些字段返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;_source&quot;: &quot;obj.*&quot;,</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;_source&quot;: [ &quot;obj1.*&quot;, &quot;obj2.*&quot; ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终，为了完全控制，还可以通过 includes 和excludes来设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;_source&quot;: &#123;</div><div class="line">        &quot;includes&quot;: [ &quot;obj1.*&quot;, &quot;obj2.*&quot; ],</div><div class="line">        &quot;excludes&quot;: [ &quot;*.description&quot; ]</div><div class="line">    &#125;,</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><p>stored_fields参数是针对已经明确mapping过的，一般不体检使用。可以使用 source filtering来代替。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;stored_fields&quot; : [&quot;user&quot;, &quot;postDate&quot;],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想加载所有的字段，可以用 * 。<br>如果设置为空数组，那么如果命中，将只返回_id 和 _type。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;stored_fields&quot; : [],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有需要的字段，它将会被忽略。</p>
<h4 id="不使用存储的字段"><a href="#不使用存储的字段" class="headerlink" title="不使用存储的字段"></a>不使用存储的字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;stored_fields&quot;: &quot;_none_&quot;,</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不使用存储的字段，可以使用<em>none</em></p>
<h3 id="Script-Fields"><a href="#Script-Fields" class="headerlink" title="Script Fields"></a>Script Fields</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match_all&quot;: &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;script_fields&quot; : &#123;</div><div class="line">        &quot;test1&quot; : &#123;</div><div class="line">            &quot;script&quot; : &#123;</div><div class="line">             </div><div class="line">                &quot;inline&quot;: &quot;doc[&apos;my_field_name&apos;].value * 2&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        &quot;test2&quot; : &#123;</div><div class="line">            &quot;script&quot; : &#123;</div><div class="line">               </div><div class="line">                &quot;inline&quot;: &quot;doc[&apos;my_field_name&apos;].value * factor&quot;,</div><div class="line">                &quot;params&quot; : &#123;</div><div class="line">                    &quot;factor&quot;  : 2.0</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>script_fields 能够操作没存储的字段，并且允许人为定义其返回值。<br>script_fields 还可以访问年实际存在的 _source 文档，并且指定返回的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">    &#123;</div><div class="line">        &quot;query&quot; : &#123;</div><div class="line">            &quot;match_all&quot;: &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        &quot;script_fields&quot; : &#123;</div><div class="line">            &quot;test1&quot; : &#123;</div><div class="line">                &quot;script&quot; : &quot;_source.obj1.obj2&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>理解doc[‘my_field’].value 和 _source.my_field 的区别是很重要的。首先，使用doc，将会导致字段加载进内存，需要更多的内存消耗，但是会获得更快的响应速度。另外，doc[…]符号只允许简单的值的字段，不允许json object类型。<br>_source只返回json相关的部分。</p>
<h3 id="Doc-value-Fields"><a href="#Doc-value-Fields" class="headerlink" title="Doc value Fields"></a>Doc value Fields</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match_all&quot;: &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;docvalue_fields&quot; : [&quot;test1&quot;, &quot;test2&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>docvalue_fields 能够用于没有存储的字段上。<br>值得注意的是，如果字段的参数制定了没有docvalues的字段，将会从字段数据的缓存中加载值并导致字段中的所有词条加载到内存中，造成更多的内存消耗。</p>
<h3 id="Post-filter"><a href="#Post-filter" class="headerlink" title="Post filter"></a>Post filter</h3><p>post_filter 用来搜索每个hits，在聚合运算之后。下面是一个解释的例子：</p>
<p>加入你卖衬衫：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">PUT /shirts</div><div class="line">&#123;</div><div class="line">    &quot;mappings&quot;: &#123;</div><div class="line">        &quot;item&quot;: &#123;</div><div class="line">            &quot;properties&quot;: &#123;</div><div class="line">                &quot;brand&quot;: &#123; &quot;type&quot;: &quot;string&quot;&#125;,</div><div class="line">                &quot;color&quot;: &#123; &quot;type&quot;: &quot;string&quot;&#125;,</div><div class="line">                &quot;model&quot;: &#123; &quot;type&quot;: &quot;string&quot;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PUT /shirts/item/1?refresh</div><div class="line">&#123;</div><div class="line">    &quot;brand&quot;: &quot;gucci&quot;,</div><div class="line">    &quot;color&quot;: &quot;red&quot;,</div><div class="line">    &quot;model&quot;: &quot;slim&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想象一下，一个用户制定了两个搜索条件：<br>color:red 和 brand:gucci 。通常，你可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /shirts/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;filter&quot;: [</div><div class="line">        &#123; &quot;term&quot;: &#123; &quot;color&quot;: &quot;red&quot;   &#125;&#125;,</div><div class="line">        &#123; &quot;term&quot;: &#123; &quot;brand&quot;: &quot;gucci&quot; &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回结果时这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 120,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 0,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;shirts&quot;,</div><div class="line">        &quot;_type&quot;: &quot;item&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;brand&quot;: &quot;gucci&quot;,</div><div class="line">          &quot;color&quot;: &quot;red&quot;,</div><div class="line">          &quot;model&quot;: &quot;slim&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然而，你还想要展示一系列的选项来让用户点击查询。例如，你有一个model 字段来希望用户进一步查询是 red gucci 的t-shirts 还是dress-shirts，这可以使用terms aggregation来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">GET /shirts/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;filter&quot;: [</div><div class="line">        &#123; &quot;term&quot;: &#123; &quot;color&quot;: &quot;red&quot;   &#125;&#125;,</div><div class="line">        &#123; &quot;term&quot;: &#123; &quot;brand&quot;: &quot;gucci&quot; &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;models&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123; &quot;field&quot;: &quot;model&quot; &#125; </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 73,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 0,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;shirts&quot;,</div><div class="line">        &quot;_type&quot;: &quot;item&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;brand&quot;: &quot;gucci&quot;,</div><div class="line">          &quot;color&quot;: &quot;red&quot;,</div><div class="line">          &quot;model&quot;: &quot;slim&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  &quot;aggregations&quot;: &#123;</div><div class="line">    &quot;models&quot;: &#123;</div><div class="line">      &quot;doc_count_error_upper_bound&quot;: 0,</div><div class="line">      &quot;sum_other_doc_count&quot;: 0,</div><div class="line">      &quot;buckets&quot;: [</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;slim&quot;,</div><div class="line">          &quot;doc_count&quot;: 1</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是，有可能你邮箱告诉user还有多少其他颜色的gucci shirts。如果你仅仅添加一个terms 的aggregation在color字段，你只能得到color为red的，因为你的查询只返回了red gucci shirts。</p>
<p>解决方法是，你想要查询所有color的shirts，先通过聚合，然后使用color的filter来对查询结果进一步过滤，这就是post_filter的用处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">GET /shirts/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;filter&quot;: &#123;</div><div class="line">        &quot;term&quot;: &#123; &quot;brand&quot;: &quot;gucci&quot; &#125; </div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;colors&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123; &quot;field&quot;: &quot;color&quot; &#125; </div><div class="line">    &#125;,</div><div class="line">    &quot;color_red&quot;: &#123;</div><div class="line">      &quot;filter&quot;: &#123;</div><div class="line">        &quot;term&quot;: &#123; &quot;color&quot;: &quot;red&quot; &#125; </div><div class="line">      &#125;,</div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;models&quot;: &#123;</div><div class="line">          &quot;terms&quot;: &#123; &quot;field&quot;: &quot;model&quot; &#125; </div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;post_filter&quot;: &#123; </div><div class="line">    &quot;term&quot;: &#123; &quot;color&quot;: &quot;red&quot; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 20,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 0,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;shirts&quot;,</div><div class="line">        &quot;_type&quot;: &quot;item&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;brand&quot;: &quot;gucci&quot;,</div><div class="line">          &quot;color&quot;: &quot;red&quot;,</div><div class="line">          &quot;model&quot;: &quot;slim&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  &quot;aggregations&quot;: &#123;</div><div class="line">    &quot;color_red&quot;: &#123;</div><div class="line">      &quot;doc_count&quot;: 1,</div><div class="line">      &quot;models&quot;: &#123;</div><div class="line">        &quot;doc_count_error_upper_bound&quot;: 0,</div><div class="line">        &quot;sum_other_doc_count&quot;: 0,</div><div class="line">        &quot;buckets&quot;: [</div><div class="line">          &#123;</div><div class="line">            &quot;key&quot;: &quot;slim&quot;,</div><div class="line">            &quot;doc_count&quot;: 1</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;colors&quot;: &#123;</div><div class="line">      &quot;doc_count_error_upper_bound&quot;: 0,</div><div class="line">      &quot;sum_other_doc_count&quot;: 0,</div><div class="line">      &quot;buckets&quot;: [</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;red&quot;,</div><div class="line">          &quot;doc_count&quot;: 1</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Highlighting"><a href="#Highlighting" class="headerlink" title="Highlighting"></a>Highlighting</h3><p>可以对搜索结果的一个或多个字段进行高亮处理。具体是使用Lucene的plain highlighter ， fast vector highting 和 posting highlighter实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;user&quot;: &quot;kimchy&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;content&quot; : &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，content字段就是对于每个命中的结果进行高亮的字段。</p>
<h4 id="Plain-highlighter"><a href="#Plain-highlighter" class="headerlink" title="Plain highlighter"></a>Plain highlighter</h4><p>默认的高亮方式是通过plain，也就是使用的Lucene的highlighter。它力图反映查询匹配的逻辑中单词理解的重要性和短语查询中单词的定位标准。</p>
<p>如果你想要通过复杂的查询来高亮很多文档中的很多字段，那么它不会很快。因为在执行时，它会创建一个小的内存空间并使用Lucene的查询重新搜索一遍将要被高亮的字段。</p>
<h4 id="Postings-highlighter"><a href="#Postings-highlighter" class="headerlink" title="Postings highlighter"></a>Postings highlighter</h4><p>如果在mapping中将 index_options 设置为 offsets，那么将会使用postings highlighter 来代替 plain highlighter。postings highlighter有以下特点：</p>
<ul>
<li>响应比较快，因为他不需要重新分析将被高亮的文本，越大的文件响应速度越快。</li>
<li>比term_vectors 需要更少的硬盘空间，需要fast vector highlighter。</li>
<li>可以将文本分成句子并高亮他们。对于自然语言发挥得很好,但是不包含例如html标记的字段。</li>
<li>将文档视为整个文章，使用BM25算法score每个单独的句子。</li>
</ul>
<p>Elasticsearch中需要在建立索引的时候映射字段类型，才可以实现postings-highlighter高亮显示，例如对content字段采用postings高亮类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;type_name&quot; : &#123;</div><div class="line">        &quot;content&quot; : &#123;&quot;type&quot;:&quot;string&quot;,&quot;index_options&quot; : &quot;offsets&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，postings highlighter 意味着针对简单查询的词条高亮，而不管它们的位置。这意味着，当与短语查询结合使用时，它将高亮构成查询的所有词条，而不管它们是否实际上是查询匹配的一部分，从而有效地忽略了它们的位置。</p>
<p>postings highlighter 不支持高亮一些复杂的查询，比如将type设置match_phrase_prefix的match查询。这种情况下没有被高亮的段落返回。</p>
<h4 id="Fast-vector-highlighter"><a href="#Fast-vector-highlighter" class="headerlink" title="Fast vector highlighter"></a>Fast vector highlighter</h4><p>当mapping中设置term_vector为with_positions_offsets，将会用fast vector highlighter 代替 plain highlighter。<br>特点：</p>
<ul>
<li>快，尤其对于大于1M的字段。</li>
<li>可定制的boundary_chars，boundary_max_scan，和fragment_offset。</li>
<li>需要设置term_vector的值为with_positions_offsets，这会增加索引的大小。</li>
<li>可以将多个字段的匹配组合成一个结果。</li>
<li>可以为不同位置的短语分配不同的权重。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;type_name&quot; : &#123;</div><div class="line">        &quot;content&quot; : &#123;&quot;term_vector&quot; : &quot;with_positions_offsets&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Force-highlighter-type"><a href="#Force-highlighter-type" class="headerlink" title="Force highlighter type"></a>Force highlighter type</h4><p>可以对指定的字段类型进行高亮。这对于要使用term_vectors对字段进行高亮非常有用。可以允许的类型为：plain，postings和fvh。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;brand&quot;: &quot;gucci&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;brand&quot; : &#123;&quot;type&quot; : &quot;plain&quot;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 18,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 0.30685282,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;shirts&quot;,</div><div class="line">        &quot;_type&quot;: &quot;item&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0.30685282,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;brand&quot;: &quot;gucci&quot;,</div><div class="line">          &quot;color&quot;: &quot;red&quot;,</div><div class="line">          &quot;model&quot;: &quot;slim&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;highlight&quot;: &#123;</div><div class="line">          &quot;brand&quot;: [</div><div class="line">            &quot;&lt;em&gt;gucci&lt;/em&gt;&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Force-highlighter-on-source"><a href="#Force-highlighter-on-source" class="headerlink" title="Force highlighter on source"></a>Force highlighter on source</h4><p>强制高亮source中的字段，即使字段被分开存储。默认是false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;brand&quot;: &quot;gucci&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;brand&quot; : &#123;&quot;force_source&quot; : true&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样返回的内容是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 130,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 0.30685282,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;shirts&quot;,</div><div class="line">        &quot;_type&quot;: &quot;item&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0.30685282,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;brand&quot;: &quot;gucci&quot;,</div><div class="line">          &quot;color&quot;: &quot;red&quot;,</div><div class="line">          &quot;model&quot;: &quot;slim&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;highlight&quot;: &#123;</div><div class="line">          &quot;brand&quot;: [</div><div class="line">            &quot;&lt;em&gt;gucci&lt;/em&gt;&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Highlighting-tags"><a href="#Highlighting-tags" class="headerlink" title="Highlighting tags"></a>Highlighting tags</h4><p>默认情况下，被高亮的文本的包围标签是<em></em>，这个可以自定义设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;brand&quot;: &quot;gucci&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;pre_tags&quot; : [&quot;&lt;tag1&gt;&quot;],</div><div class="line">        &quot;post_tags&quot; : [&quot;&lt;/tag1&gt;&quot;],</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;brand&quot; : &#123;&quot;force_source&quot; : true&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 3,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;max_score&quot;: 0.30685282,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;shirts&quot;,</div><div class="line">        &quot;_type&quot;: &quot;item&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0.30685282,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;brand&quot;: &quot;gucci&quot;,</div><div class="line">          &quot;color&quot;: &quot;red&quot;,</div><div class="line">          &quot;model&quot;: &quot;slim&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;highlight&quot;: &#123;</div><div class="line">          &quot;brand&quot;: [</div><div class="line">            &quot;&lt;tag1&gt;gucci&lt;/tag1&gt;&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用fast vector highlighter 能够使用更多的tag。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;user&quot;: &quot;kimchy&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;pre_tags&quot; : [&quot;&lt;tag1&gt;&quot;, &quot;&lt;tag2&gt;&quot;],</div><div class="line">        &quot;post_tags&quot; : [&quot;&lt;/tag1&gt;&quot;, &quot;&lt;/tag2&gt;&quot;],</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;_all&quot; : &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用样式，例如想实现这样的样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;em class=&quot;hlt1&quot;&gt;, &lt;em class=&quot;hlt2&quot;&gt;, &lt;em class=&quot;hlt3&quot;&gt;,</div><div class="line">&lt;em class=&quot;hlt4&quot;&gt;, &lt;em class=&quot;hlt5&quot;&gt;, &lt;em class=&quot;hlt6&quot;&gt;,</div><div class="line">&lt;em class=&quot;hlt7&quot;&gt;, &lt;em class=&quot;hlt8&quot;&gt;, &lt;em class=&quot;hlt9&quot;&gt;,</div><div class="line">&lt;em class=&quot;hlt10&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;user&quot;: &quot;kimchy&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;tags_schema&quot; : &quot;styled&quot;,</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;content&quot; : &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>encoder参数用于定义highlighter的文本是怎样的编码。可以是default或者html。</p>
<h4 id="Highlighted-Fragments"><a href="#Highlighted-Fragments" class="headerlink" title="Highlighted Fragments"></a>Highlighted Fragments</h4><p>可以控制高亮字段的字符数大小，默认是100，还有最大片段数，默认是5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;color&quot;: &quot;red&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;color&quot; : &#123;&quot;fragment_size&quot; : 1, &quot;number_of_fragments&quot; : 1&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当使用postings highlighter时，fragment_size会被忽略。<br>可以针对评分进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;color&quot;: &quot;red&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">        	&quot;order&quot; : &quot;score&quot;,</div><div class="line">            &quot;color&quot; : &#123;&quot;force_source&quot; : true ,&quot;fragment_size&quot; : 1, &quot;number_of_fragments&quot; : 1&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Highlight-query"><a href="#Highlight-query" class="headerlink" title="Highlight query"></a>Highlight query</h4><p>使用 highlight_query 可以针对搜索结果进行高亮内的二次搜索。这对于如果你想对没有考虑高亮的查询进行重新评分查询是非常有用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;stored_fields&quot;: [ &quot;_id&quot; ],</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123;</div><div class="line">            &quot;content&quot;: &#123;</div><div class="line">                &quot;query&quot;: &quot;foo bar&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;rescore&quot;: &#123;</div><div class="line">        &quot;window_size&quot;: 50,</div><div class="line">        &quot;query&quot;: &#123;</div><div class="line">            &quot;rescore_query&quot; : &#123;</div><div class="line">                &quot;match_phrase&quot;: &#123;</div><div class="line">                    &quot;content&quot;: &#123;</div><div class="line">                        &quot;query&quot;: &quot;foo bar&quot;,</div><div class="line">                        &quot;slop&quot;: 1</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &quot;rescore_query_weight&quot; : 10</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;order&quot; : &quot;score&quot;,</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;content&quot; : &#123;</div><div class="line">                &quot;fragment_size&quot; : 150,</div><div class="line">                &quot;number_of_fragments&quot; : 3,</div><div class="line">                &quot;highlight_query&quot;: &#123;</div><div class="line">                    &quot;bool&quot;: &#123;</div><div class="line">                        &quot;must&quot;: &#123;</div><div class="line">                            &quot;match&quot;: &#123;</div><div class="line">                                &quot;content&quot;: &#123;</div><div class="line">                                    &quot;query&quot;: &quot;foo bar&quot;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;,</div><div class="line">                        &quot;should&quot;: &#123;</div><div class="line">                            &quot;match_phrase&quot;: &#123;</div><div class="line">                                &quot;content&quot;: &#123;</div><div class="line">                                    &quot;query&quot;: &quot;foo bar&quot;,</div><div class="line">                                    &quot;slop&quot;: 1,</div><div class="line">                                    &quot;boost&quot;: 10.0</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;,</div><div class="line">                        &quot;minimum_should_match&quot;: 0</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Global-Settings"><a href="#Global-Settings" class="headerlink" title="Global Settings"></a>Global Settings</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;user&quot;: &quot;kimchy&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;number_of_fragments&quot; : 3,</div><div class="line">        &quot;fragment_size&quot; : 150,</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;_all&quot; : &#123; &quot;pre_tags&quot; : [&quot;&lt;em&gt;&quot;], &quot;post_tags&quot; : [&quot;&lt;/em&gt;&quot;] &#125;,</div><div class="line">            &quot;bio.title&quot; : &#123; &quot;number_of_fragments&quot; : 0 &#125;,</div><div class="line">            &quot;bio.author&quot; : &#123; &quot;number_of_fragments&quot; : 0 &#125;,</div><div class="line">            &quot;bio.content&quot; : &#123; &quot;number_of_fragments&quot; : 5, &quot;order&quot; : &quot;score&quot; &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Require-Field-Match"><a href="#Require-Field-Match" class="headerlink" title="Require Field Match"></a>Require Field Match</h4><p>将require_field_match设为false可以导致不管查询是否匹配，都会高亮显示。默认是true，意味着只有匹配的才高亮显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot;: &#123; &quot;user&quot;: &quot;kimchy&quot; &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot; : &#123;</div><div class="line">        &quot;require_field_match&quot;: false,</div><div class="line">        &quot;fields&quot;: &#123;</div><div class="line">                &quot;_all&quot; : &#123; &quot;pre_tags&quot; : [&quot;&lt;em&gt;&quot;], &quot;post_tags&quot; : [&quot;&lt;/em&gt;&quot;] &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Boundary-Characters"><a href="#Boundary-Characters" class="headerlink" title="Boundary Characters"></a>Boundary Characters</h4><p>当使用fast vector highlighter 高亮一个字段时，boundary_chars 能够设置边界字符。默认是 .,!? \t\n 。<br>boundary_max_scan允许控制查找边界字符的距离，默认值为20。</p>
<h4 id="Matched-Fields"><a href="#Matched-Fields" class="headerlink" title="Matched Fields"></a>Matched Fields</h4><p>Fast Vector Highlighter 能够组合多个字段上的匹配并使用 matched_fields 突出单个字段。这对于使用不同分析器来处理同一字符串来说是最直观的。所有matched_fields 必须将 term_vector 设置为 with_positions_offsets ，但只会加载匹配的组合字段，因此只有该字段可以在store设置为yes时受益。</p>
<p>下面的例子中，content 使用 english 分析器 ， content.plain使用 standard分析器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;: &#123;</div><div class="line">        &quot;query_string&quot;: &#123;</div><div class="line">            &quot;query&quot;: &quot;content.plain:running scissors&quot;,</div><div class="line">            &quot;fields&quot;: [&quot;content&quot;]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot;: &#123;</div><div class="line">        &quot;order&quot;: &quot;score&quot;,</div><div class="line">        &quot;fields&quot;: &#123;</div><div class="line">            &quot;content&quot;: &#123;</div><div class="line">                &quot;matched_fields&quot;: [&quot;content&quot;, &quot;content.plain&quot;],</div><div class="line">                &quot;type&quot; : &quot;fvh&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的查询中会匹配所有 “run with scissors” 和 “running with scissors”，而不是”run”。如果所有的词组都在一个大的文档中出现，那么”running with scissors” 会排在 “run with scissors”上面，因为在段落中它会更匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;: &#123;</div><div class="line">        &quot;query_string&quot;: &#123;</div><div class="line">            &quot;query&quot;: &quot;running scissors&quot;,</div><div class="line">            &quot;fields&quot;: [&quot;content&quot;, &quot;content.plain^10&quot;]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot;: &#123;</div><div class="line">        &quot;order&quot;: &quot;score&quot;,</div><div class="line">        &quot;fields&quot;: &#123;</div><div class="line">            &quot;content&quot;: &#123;</div><div class="line">                &quot;matched_fields&quot;: [&quot;content&quot;, &quot;content.plain&quot;],</div><div class="line">                &quot;type&quot; : &quot;fvh&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Phrase-Limit"><a href="#Phrase-Limit" class="headerlink" title="Phrase Limit"></a>Phrase Limit</h4><p>fast vector highlighter 可以通过phrase_limit 参数来防止分析过多的词组或消耗太多内存。默认是256，也就意味着只有文档前面的256个匹配的词组可以使用。你可以根据自己的需求适量提高这个限制，并且要考虑各方面平衡。<br>如果使用matched_fields，每个匹配字段的phrase_limit短语被考虑。</p>
<h4 id="Field-Highlight-Order"><a href="#Field-Highlight-Order" class="headerlink" title="Field Highlight Order"></a>Field Highlight Order</h4><p>Elasticsearch按照它们发送的顺序来高亮字段。每个json对象是无序的，但如果你需要明确的字段高亮的顺序，你可以使用数组，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;highlight&quot;: &#123;</div><div class="line">        &quot;fields&quot;: [</div><div class="line">            &#123;&quot;title&quot;:&#123; /*params*/ &#125;&#125;,</div><div class="line">            &#123;&quot;text&quot;:&#123; /*params*/ &#125;&#125;</div><div class="line">        ]</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Rescoring"><a href="#Rescoring" class="headerlink" title="Rescoring"></a>Rescoring</h3><p>Rescoring能够通过重新排序来精确query和post_filter的查询结果，使用了二次算法，而不是对整个索引进行操作。<br>rescore请求会被在每一个分片上执行，在返回被节点排序的整个查询请求结果之前。<br>当前，rescore API 只有一个实现：query rescorer–通过使用查询来调整得分。</p>
<p>注意，当使用了sort时，rescore是不会执行的。<br>当使用了分页功能时，遍历每一个页面是不应该改变window_size的（通过传不同的from的值），因为这会改变最上面的命中结果，使得用户在遍历页面时感到困惑。</p>
<h4 id="Query-rescorer"><a href="#Query-rescorer" class="headerlink" title="Query rescorer"></a>Query rescorer</h4><p>query rescorer 只会在query 和 post_filter查询返回的头N条进行二次查询。每个分片检查的文档数量可以通过window_size来控制，默认情况是 from / size。<br>默认情况下，最初查询的得分和rescore查询的得分会先行的组成最终的每个文档的_score。这两个组合的权重比例可以通过query_weight和rescore_query_weight来控制，默认都是1.</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   &quot;query&quot; : &#123;</div><div class="line">      &quot;match&quot; : &#123;</div><div class="line">         &quot;brand&quot; : &#123;</div><div class="line">            &quot;operator&quot; : &quot;or&quot;,</div><div class="line">            &quot;query&quot; : &quot;gucci&quot;,</div><div class="line">            &quot;type&quot; : &quot;boolean&quot;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;,</div><div class="line">   &quot;rescore&quot; : &#123;</div><div class="line">      &quot;window_size&quot; : 50,</div><div class="line">      &quot;query&quot; : &#123;</div><div class="line">         &quot;rescore_query&quot; : &#123;</div><div class="line">            &quot;match&quot; : &#123;</div><div class="line">               &quot;brand&quot; : &#123;</div><div class="line">                  &quot;query&quot; : &quot;asd&quot;,</div><div class="line">                  &quot;type&quot; : &quot;phrase&quot;,</div><div class="line">                  &quot;slop&quot; : 2</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">         &#125;,</div><div class="line">         &quot;query_weight&quot; : 0,</div><div class="line">         &quot;rescore_query_weight&quot; : 1</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以通过score_mode来控制得分：</p>
<ul>
<li>total: 默认的设置，会将最初的得分和resscore加起来。</li>
<li>multiply：最初得分 * rescore。</li>
<li>avg： 平均分。</li>
<li>max： 最大值。</li>
<li>min： 最小值。</li>
</ul>
<h4 id="Multiple-Rescores"><a href="#Multiple-Rescores" class="headerlink" title="Multiple Rescores"></a>Multiple Rescores</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">curl -s -XPOST &apos;localhost:9200/_search&apos; -d &apos;&#123;</div><div class="line">   &quot;query&quot; : &#123;</div><div class="line">      &quot;match&quot; : &#123;</div><div class="line">         &quot;field1&quot; : &#123;</div><div class="line">            &quot;operator&quot; : &quot;or&quot;,</div><div class="line">            &quot;query&quot; : &quot;the quick brown&quot;,</div><div class="line">            &quot;type&quot; : &quot;boolean&quot;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;,</div><div class="line">   &quot;rescore&quot; : [ &#123;</div><div class="line">      &quot;window_size&quot; : 100,</div><div class="line">      &quot;query&quot; : &#123;</div><div class="line">         &quot;rescore_query&quot; : &#123;</div><div class="line">            &quot;match&quot; : &#123;</div><div class="line">               &quot;field1&quot; : &#123;</div><div class="line">                  &quot;query&quot; : &quot;the quick brown&quot;,</div><div class="line">                  &quot;type&quot; : &quot;phrase&quot;,</div><div class="line">                  &quot;slop&quot; : 2</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">         &#125;,</div><div class="line">         &quot;query_weight&quot; : 0.7,</div><div class="line">         &quot;rescore_query_weight&quot; : 1.2</div><div class="line">      &#125;</div><div class="line">   &#125;, &#123;</div><div class="line">      &quot;window_size&quot; : 10,</div><div class="line">      &quot;query&quot; : &#123;</div><div class="line">         &quot;score_mode&quot;: &quot;multiply&quot;,</div><div class="line">         &quot;rescore_query&quot; : &#123;</div><div class="line">            &quot;function_score&quot; : &#123;</div><div class="line">               &quot;script_score&quot;: &#123;</div><div class="line">                  &quot;script&quot;: &#123;</div><div class="line">                    &quot;lang&quot;: &quot;painless&quot;,</div><div class="line">                    &quot;inline&quot;: &quot;Math.log10(doc[&apos;numeric&apos;].value + 2)&quot;</div><div class="line">                  &#125;</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125; ]</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure>
<p>第一个查询查询到结果，然后第二个查询通过第一个查询结果来进行查询，依次类推。第二次查询会查看第一次查询结果的排序，因此它可能会在看第一次rescore时使用一个大的window，在第二次rescore时使用小一些的window。</p>
<h3 id="Scroll"><a href="#Scroll" class="headerlink" title="Scroll"></a>Scroll</h3><p>与使用search请求一个单独的页面相比，scroll API能够用来获得更多数量的结果（甚至全部结果）通过一个请求，和数据库中的游标差不多。<br>scroll请求返回的结果反映了当时search请求返回的索引的状态，像一个当时的快照。对文档（索引，更新或删除）的后续更改只会影响以后的搜索请求。<br>为了使用scrolling，在查询字符串中应该初始化scroll参数，来告诉es要search context对象存活多久。例如：scroll=1m。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST /_search?scroll=1m</div><div class="line">&#123;</div><div class="line">    &quot;size&quot;: 100,</div><div class="line">    &quot;query&quot;: &#123;</div><div class="line">        &quot;match&quot; : &#123;</div><div class="line">            &quot;brand&quot; : &quot;gucci&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">返回：</div></pre></td></tr></table></figure></p>
<p>{<br>  “_scroll_id”: “cXVlcnlUaGVuRmV0Y2g7NTs0ODp6bnRHQVprSVMwaWJ4bGxmcG9OVFNBOzUwOnpudEdBWmtJUzBpYnhsbGZwb05UU0E7NDY6em50R0Faa0lTMGlieGxsZnBvTlRTQTs0OTp6bnRHQVprSVMwaWJ4bGxmcG9OVFNBOzQ3OnpudEdBWmtJUzBpYnhsbGZwb05UU0E7MDs=”,<br>  “took”: 4,<br>  “timed_out”: false,<br>  “_shards”: {<br>    “total”: 5,<br>    “successful”: 5,<br>    “failed”: 0<br>  },<br>  “hits”: {<br>    “total”: 1,<br>    “max_score”: 0.30685282,<br>    “hits”: [<br>      {<br>        “_index”: “shirts”,<br>        “_type”: “item”,<br>        “_id”: “1”,<br>        “_score”: 0.30685282,<br>        “_source”: {<br>          “brand”: “gucci”,<br>          “color”: “red”,<br>          “model”: “slim”<br>        }<br>      }<br>    ]<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">搜索结果会返回一个_scroll_id，可以用来传入scrollAPI来获得下一批数据。</div></pre></td></tr></table></figure></p>
<p>POST  /_search/scroll<br>{<br>    “scroll” : “1m”,<br>    “scroll_id” : “DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==”<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">size参数可以用来配置每次命中数据的返回条数，每次请求scroll API都会返回下一批数据，直到为空。</div><div class="line"></div><div class="line">### Preference</div><div class="line">使用preference可以控制在哪个分片上执行搜索请求。默认情况下，会随机在分片的备份上执行。</div><div class="line"></div><div class="line">参数：</div><div class="line">- _primary: 只会在主分片上执行。</div><div class="line">- _primary_first: 会优先在祝分片上执行，如果主分片不可用，则在其他分片上执行。</div><div class="line">- _replica： 只会在副本分片上执行。</div><div class="line">- _replica_first： 会优先在副本分片上执行，如果分片不可用，则在其他分片上执行。</div><div class="line">- _local： 操作会尽可能在本地分片上执行。</div><div class="line">- _prefer_nodes:abc,xyz： 会在指定的节点上执行。</div><div class="line">- _shards:2,3： 限制操作在指定的分片上执行，这个参数可以和其他的preference参数一起执行，但是必须将它放在第一个：_shards:2,3|_primary。</div><div class="line">- _only_nodes： 限制操作的节点的规格。</div><div class="line">- Custom (string) value： 自定义的值将用来保证同一个分片会用来处理相同的自定义值。</div></pre></td></tr></table></figure></p>
<p>GET /_search?preference=xyzabc123<br>{<br>    “query”: {<br>        “match”: {<br>            “title”: “elasticsearch”<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Explain</div><div class="line">开启explain可以知道所有的命中结果的score是怎么计算的。</div></pre></td></tr></table></figure></p>
<p>GET /_search<br>{<br>    “explain”: true,<br>    “query” : {<br>        “term” : { “user” : “kimchy” }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Version</div><div class="line">每次命中的结果返回一个版本号。</div></pre></td></tr></table></figure></p>
<p>GET /_search<br>{<br>    “version”: true,<br>    “query” : {<br>        “term” : { “user” : “kimchy” }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### min_score</div><div class="line">排除_score低于设置的最小值的结果。</div></pre></td></tr></table></figure></p>
<p>GET /_search<br>{<br>    “min_score”: 0.5,<br>    “query” : {<br>        “term” : { “user” : “kimchy” }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### Named Queries</div><div class="line">每个filter和query都可以在最上面设置一个 _name 参数。</div></pre></td></tr></table></figure></p>
<p>GET /_search<br>{<br>    “query”: {<br>        “bool” : {<br>            “should” : [<br>                {“match” : { “name.first” : {“query” : “shay”, “_name” : “first”} }},<br>                {“match” : { “name.last” : {“query” : “banon”, “_name” : “last”} }}<br>            ],<br>            “filter” : {<br>                “terms” : {<br>                    “name.last” : [“banon”, “kimchy”],<br>                    “_name” : “test”<br>                }<br>            }<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">### Inner hits</div><div class="line">parent/child 和 nested 功能可以允许返回匹配不同范围的文档。 在parent/child 中，parent文档可以基于child文档的匹配结果进行返回，或者child文档可以基于parent的匹配结果进行返回。在nested中，文档可以基于内嵌对象的匹配结果进行返回。</div><div class="line"></div><div class="line">在所有情况下，实际的返回结果是由哪个文档引起的一般来说是隐藏的，但是，大部分情况下，知道哪个文档引起的匹配结果是很必要的。inner hits 这个功能就是做这个的。</div><div class="line"></div><div class="line">结构是这样的：</div></pre></td></tr></table></figure></p>
<p>“<query>“ : {<br>    “inner_hits” : {<br>        <inner_hits_options><br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果在查询中定义了inner_hits，那么在每次返回的信息中都包含inner_hits这个json块：</div></pre></td></tr></table></figure></inner_hits_options></query></p>
<p>“hits”: [<br>     {<br>        “_index”: …,<br>        “_type”: …,<br>        “_id”: …,<br>        “inner_hits”: {<br>           “<inner_hits_name>“: {<br>              “hits”: {<br>                 “total”: …,<br>                 “hits”: [<br>                    {<br>                       “_type”: …,<br>                       “_id”: …,<br>                       …<br>                    },<br>                    …<br>                 ]<br>              }<br>           }<br>        },<br>        …<br>     },<br>     …<br>]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- from、size、sort：用于分页和排序。</div><div class="line">- name： 用于标识inner_hits的返回结果。当查询中有多个inner_hits时非常有用。</div><div class="line"></div><div class="line">nested的查询：</div></pre></td></tr></table></figure></inner_hits_name></p>
<p>{<br>    “query” : {<br>        “nested” : {<br>            “path” : “comments”,<br>            “query” : {<br>                “match” : {“comments.message” : “[actual query]”}<br>            },<br>            “inner_hits” : {}<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">响应结果：</div></pre></td></tr></table></figure></p>
<p>…<br>“hits”: {<br>  …<br>  “hits”: [<br>     {<br>        “_index”: “my-index”,<br>        “_type”: “question”,<br>        “_id”: “1”,<br>        “_source”: …,<br>        “inner_hits”: {<br>           “comments”: {<br>              “hits”: {<br>                 “total”: …,<br>                 “hits”: [<br>                    {<br>                       “_nested”: {<br>                          “field”: “comments”,<br>                          “offset”: 2<br>                       },<br>                       “_source”: …<br>                    },<br>                    …<br>                 ]<br>              }<br>           }<br>        }<br>     },<br>     …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">parent/child 查询：</div></pre></td></tr></table></figure></p>
<p>{<br>    “query” : {<br>        “has_child” : {<br>            “type” : “comment”,<br>            “query” : {<br>                “match” : {“message” : “[actual query]”}<br>            },<br>            “inner_hits” : {}<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">响应结果：</div></pre></td></tr></table></figure></p>
<p>…<br>“hits”: {<br>  …<br>  “hits”: [<br>     {<br>        “_index”: “my-index”,<br>        “_type”: “question”,<br>        “_id”: “1”,<br>        “_source”: …,<br>        “inner_hits”: {<br>           “comment”: {<br>              “hits”: {<br>                 “total”: …,<br>                 “hits”: [<br>                    {<br>                       “_type”: “comment”,<br>                       “_id”: “5”,<br>                       “_source”: …<br>                    },<br>                    …<br>                 ]<br>              }<br>           }<br>        }<br>     },<br>     …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">### Search After</div><div class="line">分页功能一般可以使用from/size来实现，但是当深度分页时的成本也是很大的。index-max_result_window默认安全值是10000，搜索请求的堆内存占用率和时间成本和from+size成正比。Scroll API推荐用于深度分页，但是滚动的成本高，不推荐用于实时的请求。search_after参数通过提供一个实时的游标绕过了这个问题。这个想法是通过前一页的结果来帮助下一页的检索。</div><div class="line"></div><div class="line">假设查询第一页是这样的：</div></pre></td></tr></table></figure></p>
<p>GET twitter/tweet/_search<br>{<br>    “size”: 10,<br>    “query”: {<br>        “match” : {<br>            “title” : “elasticsearch”<br>        }<br>    },<br>    “sort”: [<br>        {“date”: “asc”},<br>        {“_uid”: “desc”}<br>    ]<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面查询的结果包括了一组 sort values。这些sort values 能用于联合search_after参数来返回任何文档后面的结果。例如，我们可以使用最后一个文档的sort values 并把它传入search_after，就可以获取下一页的文档：</div></pre></td></tr></table></figure></p>
<p>GET twitter/tweet/_search<br>{<br>    “size”: 10,<br>    “query”: {<br>        “match” : {<br>            “title” : “elasticsearch”<br>        }<br>    },<br>    “search_after”: [1463538857, “tweet#654323”],<br>    “sort”: [<br>        {“date”: “asc”},<br>        {“_uid”: “desc”}<br>    ]<br>}<br>```<br>值得注意的是，使用search_after需要将from设置为0或1。</p>
<p>search_after对于想要随机跳转到某页是不可用的。它和scroll API非常相似，不同的是search_after是无状态的，它总是取得的是最新版本的数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;Routing&quot;&gt;&lt;a href=&quot;#Routing&quot; class=&quot;headerlink&quot; title=&quot;Routing&quot;&gt;&lt;/
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://chenpeng89.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>【转】解决hexo在github page上css/js 404问题</title>
    <link href="http://chenpeng89.github.io/2016/11/16/%E3%80%90%E8%BD%AC%E3%80%91%E8%A7%A3%E5%86%B3hexo%E5%9C%A8github-page%E4%B8%8Acss-js-404%E9%97%AE%E9%A2%98/"/>
    <id>http://chenpeng89.github.io/2016/11/16/【转】解决hexo在github-page上css-js-404问题/</id>
    <published>2016-11-16T08:51:31.000Z</published>
    <updated>2016-11-16T08:54:40.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近github page更新了，GitHub Pages 过滤掉了 source/vendors 目录的访问，所以next主题下的source下的vendors目录不能够被访问到，所以就出现了本地hexo s能够正常访问，但是deploy到github就是一片空白，按f12，可以看到大量来自source/vendors的css和js提示404。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法一（来自github next主题issue）:</p>
<p>找到解决方案了。。 @BBBOND @monsterLin @SpadeRoy 根据作者的提示 @iissnan ，首先修改source/vendors为source/lib，然后修改_config.yml， 将 _internal: vendors修改为_internal:lib 然后修改next底下所有引用source/vendors路径为source/lib。这些地方可以通过文件查找找出来。主要集中在这几个文件中。1. Hexo\themes\next.bowerrc 2. Hexo\themes\next.gitignore 3. Hexo\themes\next.javascript_ignore 4. Hexo\themes\next\bower.json 。修改完毕后，刷新重新g一遍就ok啦。</p>
<p>方法二:更新next主题，不过听过最新的next主题对第三方例如多说删除了，具体不清楚，不敢亲易尝试，毕竟更新一次主题引来的问题太多，很多配置可能都要改，代价太高，所以推荐第一种方法<br>参考</p>
<pre><code>https://github.com/hexojs/hexo/issues/2238
https://github.com/iissnan/hexo-theme-next/issues/1214
</code></pre><p>转自： <a href="http://blog.csdn.net/zhouzixin053/article/details/53038679" target="_blank" rel="external">Hexo+Github博客css js404导致博客页面空白</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;最近github page更新了，GitHub Pages 过滤掉了 source/vendors 目录的访问，所以next主题下的sour
    
    </summary>
    
    
      <category term="hexo" scheme="http://chenpeng89.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记：三、Document APIs</title>
    <link href="http://chenpeng89.github.io/2016/09/22/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%89%E3%80%81Document-APIs/"/>
    <id>http://chenpeng89.github.io/2016/09/22/Elasticsearch学习笔记：三、Document-APIs/</id>
    <published>2016-09-22T06:02:30.000Z</published>
    <updated>2016-11-21T02:23:27.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h2><p>index API 用来向指定的index添加或更新JSON文档，并使它可被搜索。下面的例子是在名为 twitter 的index中添加一个文档，type为tweet，id=1 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 3,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，_shards段中提供了以下信息：</p>
<ul>
<li>total - 多少个分片及其备份要被操作。</li>
<li>successful - 说明分片及其备份成功了几个。</li>
<li>failures - 一个包含了失败分片及失败原因的数组。</li>
</ul>
<h3 id="自动创建Index"><a href="#自动创建Index" class="headerlink" title="自动创建Index"></a>自动创建Index</h3><p>如果实现没创建index，那么在上面的操作中会自动创建相应的index，如果没创建type，也会为指定的type自动创建一个动态type映射。</p>
<p>这个映射非常灵活，并且模式自由。新的字段和对象会自动的被添加到指定类型的映射定义中去。</p>
<p>自动创建index可以被关闭，在节点配置文件中将 action.auto_create_index 设为 false 就可以了。自动创建type映射也可以关闭，将 index.mapper.dynamic 设为 false就可以了。</p>
<p>自动创建index也可以设置黑白名单，例如，设置 action.auto_create_index 为 +aaa*,-bbb*,+ccc*,-* ， 名字为 aaa*的是可以创建的，为 bbb*的是被禁止的，以此类推。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>每个被index的文档都会有一个版本号。version 字段会在查询时返回给客户端。如果指定了版本号，可使用它做一个乐观锁。可以使用版本号进行一个read-then-update的事务处理。在读的时候指定文档的版本号可以确保期间文档不会发生变化。如果是读而不是更新操作，可以设置为preference 来替代 _primary。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/twitter/tweet/1?version=2&apos; -d &apos;&#123;</div><div class="line">    &quot;message&quot; : &quot;elasticsearch now has versioning support, double cool!&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>注意：版本操作是实时的，而且不被搜索操作的接近实时所影响。如果没设置版本号，接下来的操作将不会检查版本号。</p>
<p>默认情况下，内部的版本号会从1开始，然后随着每次更新增加。版本号也可以由外部提供。如果要开启外部版本号，需要将version_type设置为external。当设置为版本号为外部版本号时，系统不会检查版本号是否相等，而是当传入的版本号是否大于当前版本号，如果大于，则更新，如果等于或小于，则更新失败。</p>
<h4 id="版本号类型"><a href="#版本号类型" class="headerlink" title="版本号类型"></a>版本号类型</h4><p>除了上面所说的内部和外部版本号类型，es还提供了一些特殊的版本号类型：</p>
<ul>
<li>internal<br>只有在传入的版本号和系统中当前版本号相等时才更新索引。</li>
<li>external 或 external_gt<br>只有在传入的版本号大于系统当前版本号 或者 要更新的文档不存在的时候，才会更新索引。传入的版本号将作为新的版本号，并且会存储新的文档。版本号必须为一个非负的long型。</li>
<li>external_gte<br>和上面唯一不同的是，如果传入的版本号等于当前版本号也可以更新索引。</li>
<li>force<br>无视版本号或者文档是否存在，都直接更新。且传入的版本号作为新的版本号，并会存储新的文档。一般用于改正错误数据。</li>
</ul>
<h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><p>index操作也允许传入 on_type 参数来强制进行 create 操作。当设置为create，如果文档已经存在，index操作将会失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1?op_type=create&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>如果失败，会返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;error&quot;: &#123;</div><div class="line">    &quot;root_cause&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;type&quot;: &quot;document_already_exists_exception&quot;,</div><div class="line">        &quot;reason&quot;: &quot;[tweet][1]: document already exists&quot;,</div><div class="line">        &quot;index&quot;: &quot;twitter&quot;,</div><div class="line">        &quot;shard&quot;: &quot;0&quot;</div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    &quot;type&quot;: &quot;document_already_exists_exception&quot;,</div><div class="line">    &quot;reason&quot;: &quot;[tweet][1]: document already exists&quot;,</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;,</div><div class="line">    &quot;shard&quot;: &quot;0&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;status&quot;: 409</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种指定 create 的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1/_create&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="自动生成ID"><a href="#自动生成ID" class="headerlink" title="自动生成ID"></a>自动生成ID</h3><p>index的操作可以不指定id。id可以自动生成。op_type会自动设置为create。注意，此处用的是POST而不是PUT：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPOST &apos;http://localhost:9200/twitter/tweet/&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;AVdQyYB5e-yIFmSuoS-f&quot;,</div><div class="line">  &quot;_version&quot;: 1,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><p>一般情况下，shard的位置是由id的hash来控制的。为了更精确地控制，可以直接在每次操作上指定用于计算hash的值。使用 routing参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPOST &apos;http://localhost:9200/twitter/tweet?routing=kimchy&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>例如上面，就是使用kimchy来计算分片hash，来决定这个文档存放在哪个shard中。</p>
<p>当显示设置了_routing字段，并设置为required，如果index操作中没传递这个参数，将会操作失败。</p>
<h3 id="Parent-amp-Children"><a href="#Parent-amp-Children" class="headerlink" title="Parent &amp; Children"></a>Parent &amp; Children</h3><p>可以在index操作时指定parent：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT localhost:9200/blogs/blog_tag/1122?parent=1111 -d &apos;&#123;</div><div class="line">    &quot;tag&quot; : &quot;something&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>当index一个child文档，routing的值会自动设置为何它parent的一致，除非显式指定child的routing。</p>
<h3 id="写一致性"><a href="#写一致性" class="headerlink" title="写一致性"></a>写一致性</h3><p>默认情况下，对index的操作只有在超过半数的分片可用的情况下（quorum）才能成功返回。这个默认值可以通过 action.write_consistency参数来设置。如果想在每次操作时指定，可以使用请求参数 consistency 。参数有效值为one ， quorum和all。 index操作只有在复制组里面所有可用的分片都执行后才返回。</p>
<h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>想要在index操作后立即就能够查询到结果，需要设置refresh参数为true。将此选项设置为true应该在经过仔细思考和验证后,从索引和搜索的角度来看，它不会影响性能。注意，使用getAPI是实时的，不需要刷新。</p>
<h3 id="Noop-Updates"><a href="#Noop-Updates" class="headerlink" title="Noop Updates"></a>Noop Updates</h3><p>等待更新？。。。这个词不知道怎么翻译比较易懂。。。<br>当使用新的版本号进行index更新时，不管文档内容有没有变，都会创建一个新的文档。如果不能接受这样的操作，可以在使用_update api时将detect_noop设为true。这个选项不能用于index api因为index api不会获取旧的文档，因此，也就不会拿旧的和新的作比较。</p>
<h3 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h3><p>当进行index操作时，被安排用于index操作的shard可能暂时不可用。一些因素导致这个情形，比如正在搬迁或者网络异常。默认的，index操作将会等待shard一分钟，如果还不可用就会返回失败。timeout 参数可以用来显式设置等待多久：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1?timeout=5m&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>上例中，设置等待5分钟。</p>
<h2 id="Get-API"><a href="#Get-API" class="headerlink" title="Get API"></a>Get API</h2><p>get API 允许通过id来从index中查找相应的JSON文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 5,</div><div class="line">  &quot;found&quot;: true,</div><div class="line">  &quot;_source&quot;: &#123;</div><div class="line">    &quot;user&quot;: &quot;kimchy&quot;,</div><div class="line">    &quot;postDate&quot;: &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot;: &quot;trying out Elasticsearch&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过HEAD来查询文档是否存在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XHEAD -i &apos;http://localhost:9200/twitter/tweet/1&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果可以通过 http status来判断，200 – 存在，404则不存在。</p>
<h3 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h3><p>一般来说，get API是实时的，它不会被index的刷新频率所影响（当数据变得可搜索后）。</p>
<p>为了关闭实时性，可以传入 realtime参数为false，或者全局设置 action.get.realtime为false。</p>
<h3 id="可选择的Type"><a href="#可选择的Type" class="headerlink" title="可选择的Type"></a>可选择的Type</h3><p>get API可以将_type作为可选项。设置为_all会获取所有符合id的type。</p>
<h3 id="Source过滤器"><a href="#Source过滤器" class="headerlink" title="Source过滤器"></a>Source过滤器</h3><p>一般情况下，get操作都会返回_source内容，除非你设置了fields参数或者关闭_source字段。<br>不返回_source字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1?_source=false&apos;</div></pre></td></tr></table></figure></p>
<p>如果你只需要一两个字段的话，你可以使用_source_include 或 _source_exclude参数来设置。这对于大文档的检索是非常有益的，它可以减少网络中的传输字节数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1?_source_include=*ser&amp;_source_exclude=message&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 5,</div><div class="line">  &quot;found&quot;: true,</div><div class="line">  &quot;_source&quot;: &#123;</div><div class="line">    &quot;user&quot;: &quot;kimchy&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果仅仅设置include，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1?_source_include=*ser,message&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><p>get操作可以通过fields参数来指定返回的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1?fields=user,message&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 5,</div><div class="line">  &quot;found&quot;: true,</div><div class="line">  &quot;fields&quot;: &#123;</div><div class="line">    &quot;message&quot;: [</div><div class="line">      &quot;trying out Elasticsearch&quot;</div><div class="line">    ],</div><div class="line">    &quot;user&quot;: [</div><div class="line">      &quot;kimchy&quot;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了向后兼容，如果请求的字段没有存储，它们将从_source中被解析和提取。这个方法会被source过滤器的参数所覆盖。<br>被请求的字段的值将会以数组形式返回。元数据字段，像_routing或者_parent字段则永远不会以数组形式返回。</p>
<h3 id="生成的字段"><a href="#生成的字段" class="headerlink" title="生成的字段"></a>生成的字段</h3><p>如果在indexing后没有刷新，GET将会通过translog日志来查询文档。然而，一些字段只有在indexing时才生成。如果你想要获取索引中的字段，就会产生异常。可以设置来ignore_erros_on_generated_fields=true忽视异常。</p>
<p>translog是一个操作日志。每次进行索引操作后，数据变动都会先存在translog中，之后再刷新到es中。实时查询，其实是读取了translog中还未持久化的数据。</p>
<h3 id="只返回-source"><a href="#只返回-source" class="headerlink" title="只返回_source"></a>只返回_source</h3><p>使用 /{index}/{type}/{id}/_source 可以只返回_source字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1/_source&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;user&quot;: &quot;kimchy&quot;,</div><div class="line">  &quot;postDate&quot;: &quot;2009-11-15T14:12:12&quot;,</div><div class="line">  &quot;message&quot;: &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，还可以指定返回的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1/_source?_source_include=*ser&amp;_source_exclude=message&apos;</div></pre></td></tr></table></figure></p>
<p>使用HEAD方式请求也可以判断文档是否存在:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XHEAD -i &apos;http://localhost:9200/twitter/tweet/1/_source&apos;</div></pre></td></tr></table></figure></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>也可以使用路由查询，路由不对的话是查询不到的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1?routing=kimchy&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h3><p>使用preference控制哪个分片来执行get请求。一般情况下，get是在分片中随机执行的。</p>
<ul>
<li>primary: 这个操作仅仅会在主分片上执行。</li>
<li>local : 这个操作会尽可能的在本地分片上执行。</li>
<li>Custom (string) value： 用户可以自定义值，对于相同的分片可以设置相同的值。这样可以保证不同的刷新状态下，查询不同的分片。就像sessionid或者用户名一样。</li>
</ul>
<h3 id="刷新-1"><a href="#刷新-1" class="headerlink" title="刷新"></a>刷新</h3><p>refresh参数可以控制在get操作时，执行刷新，使数据可用。将它设为true时会导致每次查询都先进行刷新，这样会影响系统效率。</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>get操作被散列到一个特定的分片id。然后根据分片id直接请求其中一个备份，并返回结果。这个备份是由在这个分片id组里面的主分片和它的备份所组成的。这就意味着，备份数量越多，get的扩展性越好。</p>
<h3 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h3><p>当指定的version参数和当前版本一致时，可以获取文档。当版本类型为FORCE的时候，所有的版本类型都可以检索文档。<br>在删除一个文档后，es在内部并不立即删除这个文档，而是将它标记起来，当然， 你也不能进行访问。es会在后台逐渐清理掉这些文档。</p>
<h2 id="Delete-API"><a href="#Delete-API" class="headerlink" title="Delete API"></a>Delete API</h2><p>delete API允许通过指定的id来删除对应的文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -XDELETE &apos;http://localhost:9200/twitter/tweet/1&apos;</div></pre></td></tr></table></figure></p>
<p>返回:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;_shards&quot; : &#123;</div><div class="line">        &quot;total&quot; : 10,</div><div class="line">        &quot;failed&quot; : 0,</div><div class="line">        &quot;successful&quot; : 10</div><div class="line">    &#125;,</div><div class="line">    &quot;found&quot; : true,</div><div class="line">    &quot;_index&quot; : &quot;twitter&quot;,</div><div class="line">    &quot;_type&quot; : &quot;tweet&quot;,</div><div class="line">    &quot;_id&quot; : &quot;1&quot;,</div><div class="line">    &quot;_version&quot; : 2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="版本号-1"><a href="#版本号-1" class="headerlink" title="版本号"></a>版本号</h3><p>每个文档的索引都是有版本号的。当删除文档时，需要指定文档的version，并且在我们要进行删除操作时，版本号不能被其它的程序改变，因为更新等操作都会引起版本号的改变。</p>
<h3 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h3><p>也可以指定路由来进行删除，路有错误的话会导致删除失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -XDELETE &apos;http://localhost:9200/twitter/tweet/1?routing=kimchy&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Parent"><a href="#Parent" class="headerlink" title="Parent"></a>Parent</h3><p>删除操作也可以指定父文档。再删除父文档的时候，不会删除子文档。有一种删除子文档的方法，就是使用delete-by-query。</p>
<h3 id="自动创建索引"><a href="#自动创建索引" class="headerlink" title="自动创建索引"></a>自动创建索引</h3><p>在执行删除操作时，如果当前索引不存在，则会自动创建一个索引，同时自动创建一个指定的type。</p>
<h3 id="分布式-1"><a href="#分布式-1" class="headerlink" title="分布式"></a>分布式</h3><p>和get API中的意思差不多。</p>
<h3 id="写一致性-1"><a href="#写一致性-1" class="headerlink" title="写一致性"></a>写一致性</h3><p>操作是否能成功执行，是由对应的组里面的可用的分片备份数量决定的。这个值可以是one, quorum 和 all。可以用consistency 请求参数来设置。节点级的设置是在 action.write_consistency ， 默认是quorum。</p>
<h3 id="刷新-2"><a href="#刷新-2" class="headerlink" title="刷新"></a>刷新</h3><p>refresh参数设置为true，可以在删除操作执行后，立即刷新分片，保证其数据可以立即被查询。不过要慎用！</p>
<h3 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h3><p>当分片不可用的时候，删除操作会等待一段时间执行。可以设置其timeout。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -XDELETE &apos;http://localhost:9200/twitter/tweet/1?timeout=5m&apos;</div></pre></td></tr></table></figure></p>
<h2 id="Update-API"><a href="#Update-API" class="headerlink" title="Update API"></a>Update API</h2><p>updateAPI 允许通过脚本来更新文档。它使用版本管理来控制在get和reindex时不会有更新操作。<br>注意，update这个操作是重新索引文档，它只是减少了网络影响和版本冲突。</p>
<p>首先，创建一个索引文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPUT localhost:9200/test/type1/1 -d &apos;&#123;</div><div class="line">    &quot;counter&quot; : 1,</div><div class="line">    &quot;tags&quot; : [&quot;red&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="使用脚本更新"><a href="#使用脚本更新" class="headerlink" title="使用脚本更新"></a>使用脚本更新</h3><p>可以通过执行一个脚本来增加counter：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;script&quot; : &#123;</div><div class="line">        &quot;inline&quot;: &quot;ctx._source.counter += count&quot;,</div><div class="line">        &quot;params&quot; : &#123;</div><div class="line">            &quot;count&quot; : 4</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者也可以添加一个tag到tags[]中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;script&quot; : &#123;</div><div class="line">        &quot;inline&quot;: &quot;ctx._source.tags.add(params.tag)&quot;,</div><div class="line">        &quot;params&quot; : &#123;</div><div class="line">            &quot;tag&quot; : &quot;blue&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了_source，还可以通过ctx来获得这些变量： _index , _type , _id, _version , _routing , _parent , 和 _now (当前时间戳)。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;script&quot; : &#123;</div><div class="line">        &quot;inline&quot;: &quot;ctx._source.tages.add(ctx._id)&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除此之外，我们还可以为文档添加一个新的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;script&quot; : &quot;ctx._source.new_field = \&quot;value_of_new_field\&quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>字段为 new_field ， 且值为value_of_new_field。</p>
<p>也可以删除字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;script&quot; : &quot;ctx._source.remove(\&quot;new_field\&quot;)&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>甚至，我们还可以通过一系列逻辑判断来改变它的操作类型，例子中，如果tags包含 green，则删除文档，否则什么都不做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;script&quot; : &#123;</div><div class="line">        &quot;inline&quot;: &quot;if (ctx._source.tags.contains(tag)) &#123; ctx.op = \&quot;delete\&quot; &#125; else &#123; ctx.op = \&quot;none\&quot; &#125;&quot;,</div><div class="line">        &quot;params&quot; : &#123;</div><div class="line">            &quot;tag&quot; : &quot;green&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="通过文档来更新"><a href="#通过文档来更新" class="headerlink" title="通过文档来更新"></a>通过文档来更新</h3><p>updateAPI还支持传递一部分文档，这部分文档将会被合并到当前文档中，使用doc可以实现简单的递归合并、内部合并、替换KV以及数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;doc&quot; : &#123;</div><div class="line">        &quot;name&quot; : &quot;new_name&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 doc 和 script 都被指定了，那么doc会被忽略。最好的方式是将doc的操作也放到 script 中去执行。</p>
<h3 id="更新检测"><a href="#更新检测" class="headerlink" title="更新检测"></a>更新检测</h3><p>如果doc中定义的部分与现在的文档相同，则默认不会执行任何动作。设置detect_noop=false，就会无视是否修改，强制合并到现有的文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;doc&quot; : &#123;</div><div class="line">        &quot;name&quot; : &quot;new_name&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面例子中，执行后的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;test&quot;,</div><div class="line">  &quot;_type&quot;: &quot;type1&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 9,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 0,</div><div class="line">    &quot;successful&quot;: 0,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果请求设置了<code>&quot;detect_noop&quot;: false</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;doc&quot; : &#123;</div><div class="line">        &quot;name&quot; : &quot;new_name&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;detect_noop&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;test&quot;,</div><div class="line">  &quot;_type&quot;: &quot;type1&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 10,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 2,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Upserts"><a href="#Upserts" class="headerlink" title="Upserts"></a>Upserts</h3><p>如果文档不存在，那么upsert 元素的内容将被插入到文档中，如果文档存在，则执行脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">    &quot;script&quot; : &#123;</div><div class="line">        &quot;inline&quot;: &quot;ctx._source.counter += count&quot;,</div><div class="line">        &quot;params&quot; : &#123;</div><div class="line">            &quot;count&quot; : 4</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;upsert&quot; : &#123;</div><div class="line">        &quot;counter&quot; : 1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="scripted-upsert"><a href="#scripted-upsert" class="headerlink" title="scripted_upsert"></a>scripted_upsert</h4><p>如果你想不管文档存不存在都执行脚本，可以设置 scripted_upsert 为 true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">POST test/type1/1/_update</div><div class="line">&#123;</div><div class="line">	&quot;scripted_upsert&quot;:true,</div><div class="line">    &quot;script&quot; : &#123;</div><div class="line">        &quot;inline&quot;: &quot;ctx._source.counter += count&quot;,</div><div class="line">        &quot;params&quot; : &#123;</div><div class="line">            &quot;count&quot; : 4</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;upsert&quot; : &#123;</div><div class="line">        &quot;counters&quot; : 1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，counters不会被插入到文档中，而是只会执行脚本内容。</p>
<h4 id="doc-as-upsert"><a href="#doc-as-upsert" class="headerlink" title="doc_as_upsert"></a>doc_as_upsert</h4><p>当使用doc时，如果id为2的文档不存在，那么会报错，而如果使用doc_as_upsert，则可以在文档不存在的时候，把doc中的内容插入到文档中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST test/type1/2/_update</div><div class="line">&#123;</div><div class="line">    &quot;doc&quot; : &#123;</div><div class="line">        &quot;name&quot; : &quot;new_name&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;doc_as_upsert&quot; : true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p>retry_on_conflict : 当执行索引和更新的时候，有可能另一个进程正在执行更新。这个时候就会造成冲突，这个参数就是用于定义当遇到冲突时，重试的次数。</p>
</li>
<li><p>routing ： routing是用来为update请求路由到正确的分片的，并且当文档不存在时进行upsert操作。不能用来更新现有文档的路由。</p>
</li>
<li><p>parent： parent用来路由到正确的分片，并且当文档不存在时进行upsert操作。不能用来更新现有文档的 parent。如果一个index的路由被指定了，那么它会覆盖parent的路由，并且用新的路由来路由请求。</p>
</li>
<li><p>timeout ： 用来等待一个分片可用。</p>
</li>
<li><p>wait_for_active_shards ： 指定在更新操作前，分片副本可用的数量。</p>
</li>
<li><p>refresh : 当执行操作的时候，会自动刷新索引。</p>
</li>
<li><p>_source ： 控制被更新的source是否、如何返回。默认情况下，update操作是不返回source的。</p>
</li>
<li><p>version &amp; version_type ： updateAPI使用es的版本号来保证文档在update时没有被改变。可以使用 version参数来指定，只有当version号匹配当前版本号时，才能更新成功。你也可以使用 force 参数来强制指定版本号来更新，不过这一般用于版本修正。</p>
</li>
</ul>
<p>更新操作是不支持外部版本号的，因为本来外部版本号就脱离系统的版本控制，如果再执行更新操作，那就彻底乱了。如果使用了外部版本号，可以使用Index代替更新操作，重新索引文档。</p>
<h2 id="Update-By-Query-API"><a href="#Update-By-Query-API" class="headerlink" title="Update By Query API"></a>Update By Query API</h2><p>update By Query API 是一个新的功能，尚需实践检验，因此，以后可能会有所修改，并且不向后兼容。</p>
<p>这个api会更新索引中的每一个文档并且不改变它们的source。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POST twitter/_update_by_query?conflicts=proceed</div></pre></td></tr></table></figure></p>
<p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 2549,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;total&quot;: 3,</div><div class="line">  &quot;updated&quot;: 3,</div><div class="line">  &quot;batches&quot;: 1,</div><div class="line">  &quot;version_conflicts&quot;: 0,</div><div class="line">  &quot;noops&quot;: 0,</div><div class="line">  &quot;retries&quot;: 0,</div><div class="line">  &quot;throttled_millis&quot;: 0,</div><div class="line">  &quot;requests_per_second&quot;: &quot;unlimited&quot;,</div><div class="line">  &quot;throttled_until_millis&quot;: 0,</div><div class="line">  &quot;failures&quot;: []</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>_update_by_query 会在执行时获取一个index的快照，并且用内部版本号对它找到的文档进行索引。这意味着如果在快照生成和处理索引请求时文档有所改变，你会遇到版本冲突问题。当版本号匹配时，文档会进行更新，并且版本号会增加。</p>
<p>所有的查询和更新失败都会导致_update_by_query的终止并且返回失败信息。但是已更新的数据不会被回滚。当第一条失败时，会导致程序中止，这意味着所有的更新失败，这时候会返回大量的失败元素。</p>
<p>如果你想当版本冲突时只进行简单的计数，而不中止，可以在url中设置 conflicts=proceed或者在请求内容中设置”conflicts”: “proceed”，在api中，可以只针对索引中的一个类型进行操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POST twitter/tweet/_update_by_query?conflicts=proceed</div></pre></td></tr></table></figure></p>
<p>还可以使用Query DSL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST twitter/_update_by_query?conflicts=proceed</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; </div><div class="line">    &quot;term&quot;: &#123;</div><div class="line">      &quot;user&quot;: &quot;kimchy&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之前介绍的都是没有改变文档内容的，其实_update_by_query是可以在支持脚本对文档内容的更新。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST twitter/_update_by_query</div><div class="line">&#123;</div><div class="line">  &quot;script&quot;: &#123;</div><div class="line">    &quot;inline&quot;: &quot;ctx._source.likes++&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;term&quot;: &#123;</div><div class="line">      &quot;user&quot;: &quot;kimchy&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Multi-Get-API"><a href="#Multi-Get-API" class="headerlink" title="Multi Get API"></a>Multi Get API</h2><p>Mget api 可以获得多个文档结果，它们会以数组方式返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_mget&apos; -d &apos;&#123;</div><div class="line">    &quot;docs&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_index&quot; : &quot;test&quot;,</div><div class="line">            &quot;_type&quot; : &quot;type&quot;,</div><div class="line">            &quot;_id&quot; : &quot;1&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;_index&quot; : &quot;test&quot;,</div><div class="line">            &quot;_type&quot; : &quot;type&quot;,</div><div class="line">            &quot;_id&quot; : &quot;2&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>它也可以指定index或type：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/test/type/_mget&apos; -d &apos;&#123;</div><div class="line">    &quot;docs&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_id&quot; : &quot;1&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;_id&quot; : &quot;2&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>或者指定id:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/test/type/_mget&apos; -d &apos;&#123;</div><div class="line">    &quot;ids&quot; : [&quot;1&quot;, &quot;2&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="source-过滤"><a href="#source-过滤" class="headerlink" title="_source 过滤"></a>_source 过滤</h3><p>还可以指定_source中包含的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_mget&apos; -d &apos;&#123;</div><div class="line">    &quot;docs&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_index&quot; : &quot;test&quot;,</div><div class="line">            &quot;_type&quot; : &quot;type&quot;,</div><div class="line">            &quot;_id&quot; : &quot;1&quot;,</div><div class="line">            &quot;_source&quot; : false</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;_index&quot; : &quot;test&quot;,</div><div class="line">            &quot;_type&quot; : &quot;type&quot;,</div><div class="line">            &quot;_id&quot; : &quot;2&quot;,</div><div class="line">            &quot;_source&quot; : [&quot;field3&quot;, &quot;field4&quot;]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;_index&quot; : &quot;test&quot;,</div><div class="line">            &quot;_type&quot; : &quot;type&quot;,</div><div class="line">            &quot;_id&quot; : &quot;3&quot;,</div><div class="line">            &quot;_source&quot; : &#123;</div><div class="line">                &quot;include&quot;: [&quot;user&quot;],</div><div class="line">                &quot;exclude&quot;: [&quot;user.location&quot;]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="field-过滤"><a href="#field-过滤" class="headerlink" title="field 过滤"></a>field 过滤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/test/type/_mget?stored_fields=field1,field2&apos; -d &apos;&#123;</div><div class="line">    &quot;docs&quot; : [</div><div class="line">        &#123;</div><div class="line">            &quot;_id&quot; : &quot;1&quot; </div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;_id&quot; : &quot;2&quot;,</div><div class="line">            &quot;stored_fields&quot; : [&quot;field3&quot;, &quot;field4&quot;] </div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<h2 id="Bulk-API"><a href="#Bulk-API" class="headerlink" title="Bulk API"></a>Bulk API</h2><p>bulk API 可以通过一条请求来实现多个增加、删除操作，这能很有效的提高索引速度。</p>
<p>bulk默认的json格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">action_and_meta_data\n</div><div class="line">optional_source\n</div><div class="line">action_and_meta_data\n</div><div class="line">optional_source\n</div><div class="line">....</div><div class="line">action_and_meta_data\n</div><div class="line">optional_source\n</div></pre></td></tr></table></figure></p>
<p>注意，它是以 \n 为每行的结束符。<br>一般，它用做index，create，delete和update操作。index和create的source放在下一行，而delete只需一行，update则是由于有script、upsert等操作，不局限于两行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -s -XPOST localhost:9200/_bulk</div><div class="line">&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;type1&quot;, &quot;_id&quot; : &quot;1&quot; &#125; &#125;</div><div class="line">&#123; &quot;field1&quot; : &quot;value1&quot; &#125;</div></pre></td></tr></table></figure>
<p>多种操作的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;type1&quot;, &quot;_id&quot; : &quot;1&quot; &#125; &#125;</div><div class="line">&#123; &quot;field1&quot; : &quot;value1&quot; &#125;</div><div class="line">&#123; &quot;delete&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;type1&quot;, &quot;_id&quot; : &quot;2&quot; &#125; &#125;</div><div class="line">&#123; &quot;create&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;type1&quot;, &quot;_id&quot; : &quot;3&quot; &#125; &#125;</div><div class="line">&#123; &quot;field1&quot; : &quot;value3&quot; &#125;</div><div class="line">&#123; &quot;update&quot; : &#123;&quot;_id&quot; : &quot;1&quot;, &quot;_type&quot; : &quot;type1&quot;, &quot;_index&quot; : &quot;index1&quot;&#125; &#125;</div><div class="line">&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125;</div></pre></td></tr></table></figure></p>
<p>在url中可以设置 index 和type ，如果在doc中也设置了，那么会覆盖掉url中的设置。</p>
<h2 id="Reindex-API"><a href="#Reindex-API" class="headerlink" title="Reindex API"></a>Reindex API</h2><p>reindex API 也是一个实验性质的，不保证向后兼容。</p>
<p>Reindex API 不会建立一个目标index，他也不会复制源索引的配置。你需要在运行_reindex之前配置好映射，分片和复制。</p>
<p>_reindex最基本的用法是将文档从一个索引拷贝到另一个索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和update_by_query 一样，_reindex从源索引得到一个快照，并且目标索引必须是不同的索引，而且也不会引起版本冲突。 dest 元素可以像 indexAPI那样配置，来执行乐观并发控制。可以不管version_type 或者设置它为internal ，这会使es直接将数据拷贝到目标索引，不管数据的并发情况:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;,</div><div class="line">    &quot;version_type&quot;: &quot;internal&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将version_type设置为external会导致es将version保存在source中，在更新文档的时候进行一个乐观的版本控制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;,</div><div class="line">    &quot;version_type&quot;: &quot;external&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置op_type为create将会导致_reindex仅仅只会创建没有的文档，而已经存在的文档则会导致版本冲突：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;,</div><div class="line">    &quot;op_type&quot;: &quot;create&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认情况下，版本冲突会导致_reindex进程停止，可是设置<code>&quot;conflicts&quot;: &quot;proceed&quot;</code>来计算失败的数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;conflicts&quot;: &quot;proceed&quot;,</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;,</div><div class="line">    &quot;op_type&quot;: &quot;create&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以根据查询结果来进行拷贝：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;,</div><div class="line">    &quot;type&quot;: &quot;tweet&quot;,</div><div class="line">    &quot;query&quot;: &#123;</div><div class="line">      &quot;term&quot;: &#123;</div><div class="line">        &quot;user&quot;: &quot;kimchy&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>指定多个index或type:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: [&quot;twitter&quot;, &quot;blog&quot;],</div><div class="line">    &quot;type&quot;: [&quot;tweet&quot;, &quot;post&quot;]</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;all_together&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还可以加上排序条件和条数限制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 10000,</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;,</div><div class="line">    &quot;sort&quot;: &#123; &quot;date&quot;: &quot;desc&quot; &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加入script：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;new_twitter&quot;,</div><div class="line">    &quot;version_type&quot;: &quot;external&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;script&quot;: &#123;</div><div class="line">    &quot;inline&quot;: &quot;if (ctx._source.foo == &apos;bar&apos;) &#123;ctx._version++; ctx._source.remove(&apos;foo&apos;)&#125;&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="从远程服务器reindex"><a href="#从远程服务器reindex" class="headerlink" title="从远程服务器reindex"></a>从远程服务器reindex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">POST _reindex</div><div class="line">&#123;</div><div class="line">  &quot;source&quot;: &#123;</div><div class="line">    &quot;remote&quot;: &#123;</div><div class="line">      &quot;host&quot;: &quot;http://otherhost:9200&quot;,</div><div class="line">      &quot;username&quot;: &quot;user&quot;,</div><div class="line">      &quot;password&quot;: &quot;pass&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;index&quot;: &quot;source&quot;,</div><div class="line">    &quot;query&quot;: &#123;</div><div class="line">      &quot;match&quot;: &#123;</div><div class="line">        &quot;test&quot;: &quot;data&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;dest&quot;: &#123;</div><div class="line">    &quot;index&quot;: &quot;dest&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Term-Vectors"><a href="#Term-Vectors" class="headerlink" title="Term Vectors"></a>Term Vectors</h2><p>返回一个带有词条信息和统计的特殊的文档。这个文档可以存在索引中，或者由用户人为提供。词条信息默认是实时的，可以通过realtime 参数设为 true 来改成非实时的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1/_termvectors?pretty=true&apos;</div></pre></td></tr></table></figure></p>
<p>也可以指定字段，返回这个字段的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1/_termvectors?fields=text,...&apos;</div></pre></td></tr></table></figure></p>
<h3 id="返回的信息"><a href="#返回的信息" class="headerlink" title="返回的信息"></a>返回的信息</h3><p>可以请求三种信息：词条信息、词条统计以及字段统计。默认情况下，会返回所有词条信息和字段统计，但不会返回词条统计。</p>
<h4 id="词条信息"><a href="#词条信息" class="headerlink" title="词条信息"></a>词条信息</h4><ul>
<li>词条在字段中的出现频率（始终返回）</li>
<li>词条位置（position:true）</li>
<li>开始和结束偏移量（offsets:true）</li>
<li>词条容量（payloads : true） ，比如base64编码的字节数。</li>
</ul>
<p>如果请求的信息不在索引中，它将尽量不计算。另外，term vectors甚至可以计算不在索引中而是由用户提供的文档。</p>
<h4 id="词条统计"><a href="#词条统计" class="headerlink" title="词条统计"></a>词条统计</h4><p>将term_statistics 设为 true 可以返回：</p>
<ul>
<li>词条整体出现频率（词条在所有文档中出现的频率）</li>
<li>文档频率（包含当前词条的文档数）</li>
</ul>
<p>默认情况下，这两个都不会返回，因为会影响系统效率。</p>
<h4 id="字段统计"><a href="#字段统计" class="headerlink" title="字段统计"></a>字段统计</h4><p>默认情况下，field_statistics ： true ， 这会返回：</p>
<ul>
<li>包含这个字段的文档数</li>
<li>所有包含这个字段的文档中这个字段包含的所有词条出现频率的总和。</li>
<li>这个字段中包含的每一个词条的出现频率总和。</li>
</ul>
<h4 id="词条过滤"><a href="#词条过滤" class="headerlink" title="词条过滤"></a>词条过滤</h4><p>通过filter参数，返回的词条可以基于它们的 tf-idf分数进行过滤。这对于为了找出一个特定的文档是很有帮助的。有以下几个参数可用：</p>
<ul>
<li>max_num_terms : 每个字段必须返回的最大词条数量，默认是25。</li>
<li>min_term_freg : 忽略在source中词语频率低于这个值的词条。默认是1.</li>
<li>max_term_freq ： 与上面相反。默认是无穷大。</li>
<li>min_doc_freq ： 忽略词条出现频率低于这个值的文档。默认是1.</li>
<li>max_doc_freq ： 与上面相反，默认是无穷大。</li>
<li>min_word_length ： 忽略长度短语这个值的短语。 默认是0。</li>
<li>max_word_length ： 与上面相反，默认是无穷大。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先创建存有 term vectors ， payloads 的索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">curl -s -XPUT &apos;http://localhost:9200/twitter/&apos; -d &apos;&#123;</div><div class="line">  &quot;mappings&quot;: &#123;</div><div class="line">    &quot;tweet&quot;: &#123;</div><div class="line">      &quot;properties&quot;: &#123;</div><div class="line">        &quot;text&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;string&quot;,</div><div class="line">          &quot;term_vector&quot;: &quot;with_positions_offsets_payloads&quot;,</div><div class="line">          &quot;store&quot; : true,</div><div class="line">          &quot;analyzer&quot; : &quot;fulltext_analyzer&quot;</div><div class="line">         &#125;,</div><div class="line">         &quot;fullname&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;string&quot;,</div><div class="line">          &quot;term_vector&quot;: &quot;with_positions_offsets_payloads&quot;,</div><div class="line">          &quot;analyzer&quot; : &quot;fulltext_analyzer&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;settings&quot; : &#123;</div><div class="line">    &quot;index&quot; : &#123;</div><div class="line">      &quot;number_of_shards&quot; : 1,</div><div class="line">      &quot;number_of_replicas&quot; : 0</div><div class="line">    &#125;,</div><div class="line">    &quot;analysis&quot;: &#123;</div><div class="line">      &quot;analyzer&quot;: &#123;</div><div class="line">        &quot;fulltext_analyzer&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;custom&quot;,</div><div class="line">          &quot;tokenizer&quot;: &quot;whitespace&quot;,</div><div class="line">          &quot;filter&quot;: [</div><div class="line">            &quot;lowercase&quot;,</div><div class="line">            &quot;type_as_payload&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>添加数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;http://localhost:9200/twitter/tweet/1?pretty=true&apos; -d &apos;&#123;</div><div class="line">  &quot;fullname&quot; : &quot;John Doe&quot;,</div><div class="line">  &quot;text&quot; : &quot;twitter test test test &quot;</div><div class="line">&#125;&apos;</div><div class="line"></div><div class="line">curl -XPUT &apos;http://localhost:9200/twitter/tweet/2?pretty=true&apos; -d &apos;&#123;</div><div class="line">  &quot;fullname&quot; : &quot;Jane Doe&quot;,</div><div class="line">  &quot;text&quot; : &quot;Another twitter test ...&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h4 id="查询id-1-的text字段的所有信息和统计："><a href="#查询id-1-的text字段的所有信息和统计：" class="headerlink" title="查询id=1 的text字段的所有信息和统计："></a>查询id=1 的text字段的所有信息和统计：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1/_termvectors?pretty=true&apos; -d &apos;&#123;</div><div class="line">  &quot;fields&quot; : [&quot;text&quot;],</div><div class="line">  &quot;offsets&quot; : true,</div><div class="line">  &quot;payloads&quot; : true,</div><div class="line">  &quot;positions&quot; : true,</div><div class="line">  &quot;term_statistics&quot; : true,</div><div class="line">  &quot;field_statistics&quot; : true</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>返回结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 1,</div><div class="line">  &quot;found&quot;: true,</div><div class="line">  &quot;took&quot;: 91,</div><div class="line">  &quot;term_vectors&quot;: &#123;</div><div class="line">    &quot;text&quot;: &#123;</div><div class="line">      &quot;field_statistics&quot;: &#123;</div><div class="line">        &quot;sum_doc_freq&quot;: 6   //该字段中词的出现频率(在所有文档中),</div><div class="line">        &quot;doc_count&quot;: 2    // 包含该字段的文档数</div><div class="line">        &quot;sum_ttf&quot;: 8      // 该字段中词的数量（包含重复的词）</div><div class="line">      &#125;,</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;test&quot;: &#123;</div><div class="line">          &quot;doc_freq&quot;: 2,   //该词出现在几个文档中</div><div class="line">          &quot;ttf&quot;: 4,		   //该词出现的次数</div><div class="line">          &quot;term_freq&quot;: 3,  //该词在这个文档中出现的频率</div><div class="line">          &quot;tokens&quot;: [</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 1,</div><div class="line">              &quot;start_offset&quot;: 8,</div><div class="line">              &quot;end_offset&quot;: 12,</div><div class="line">              &quot;payload&quot;: &quot;d29yZA==&quot;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 2,</div><div class="line">              &quot;start_offset&quot;: 13,</div><div class="line">              &quot;end_offset&quot;: 17,</div><div class="line">              &quot;payload&quot;: &quot;d29yZA==&quot;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 3,</div><div class="line">              &quot;start_offset&quot;: 18,</div><div class="line">              &quot;end_offset&quot;: 22,</div><div class="line">              &quot;payload&quot;: &quot;d29yZA==&quot;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        &quot;twitter&quot;: &#123;</div><div class="line">          &quot;doc_freq&quot;: 2,</div><div class="line">          &quot;ttf&quot;: 2,</div><div class="line">          &quot;term_freq&quot;: 1,</div><div class="line">          &quot;tokens&quot;: [</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 0,</div><div class="line">              &quot;start_offset&quot;: 0,</div><div class="line">              &quot;end_offset&quot;: 7,</div><div class="line">              &quot;payload&quot;: &quot;d29yZA==&quot;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="对不在索引中存储的文档进行统计"><a href="#对不在索引中存储的文档进行统计" class="headerlink" title="对不在索引中存储的文档进行统计"></a>对不在索引中存储的文档进行统计</h4><p>下面这个文档并没有在索引中，但是也可以对它进行统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1/_termvectors?pretty=true&apos; -d &apos;&#123;</div><div class="line">  &quot;fields&quot; : [&quot;text&quot;, &quot;some_field_without_term_vectors&quot;],</div><div class="line">  &quot;offsets&quot; : true,</div><div class="line">  &quot;positions&quot; : true,</div><div class="line">  &quot;term_statistics&quot; : true,</div><div class="line">  &quot;field_statistics&quot; : true</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h4 id="在请求中人为定义的文档"><a href="#在请求中人为定义的文档" class="headerlink" title="在请求中人为定义的文档"></a>在请求中人为定义的文档</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/_termvectors&apos; -d &apos;&#123;</div><div class="line">  &quot;doc&quot; : &#123;</div><div class="line">    &quot;fullname&quot; : &quot;John Doe&quot;,</div><div class="line">    &quot;text&quot; : &quot;twitter test test test&quot;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>如果设置了动态mapping，那么如果文档不存在会自动添加。</p>
<h4 id="针对每一个字段分析"><a href="#针对每一个字段分析" class="headerlink" title="针对每一个字段分析"></a>针对每一个字段分析</h4><p>可以使用per_field_analyzer参数定义该字段的分析器，这样每个字段都可以使用不同的分析器，分析其词条向量的信息。如果这个字段已经经过存储，那么会重新生成它的词条向量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/_termvectors&apos; -d &apos;&#123;</div><div class="line">  &quot;doc&quot; : &#123;</div><div class="line">    &quot;fullname&quot; : &quot;John Doe&quot;,</div><div class="line">    &quot;text&quot; : &quot;twitter test test test&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;fields&quot;: [&quot;fullname&quot;],</div><div class="line">  &quot;per_field_analyzer&quot; : &#123;</div><div class="line">    &quot;fullname&quot;: &quot;keyword&quot;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_version&quot;: 0,</div><div class="line">  &quot;found&quot;: true,</div><div class="line">  &quot;took&quot;: 178,</div><div class="line">  &quot;term_vectors&quot;: &#123;</div><div class="line">    &quot;fullname&quot;: &#123;</div><div class="line">      &quot;field_statistics&quot;: &#123;</div><div class="line">        &quot;sum_doc_freq&quot;: 4,</div><div class="line">        &quot;doc_count&quot;: 2,</div><div class="line">        &quot;sum_ttf&quot;: 4</div><div class="line">      &#125;,</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;John Doe&quot;: &#123;</div><div class="line">          &quot;term_freq&quot;: 1,</div><div class="line">          &quot;tokens&quot;: [</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 0,</div><div class="line">              &quot;start_offset&quot;: 0,</div><div class="line">              &quot;end_offset&quot;: 8</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;text&quot;: &#123;</div><div class="line">      &quot;field_statistics&quot;: &#123;</div><div class="line">        &quot;sum_doc_freq&quot;: 6,</div><div class="line">        &quot;doc_count&quot;: 2,</div><div class="line">        &quot;sum_ttf&quot;: 8</div><div class="line">      &#125;,</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;test&quot;: &#123;</div><div class="line">          &quot;term_freq&quot;: 3,</div><div class="line">          &quot;tokens&quot;: [</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 1,</div><div class="line">              &quot;start_offset&quot;: 8,</div><div class="line">              &quot;end_offset&quot;: 12</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 2,</div><div class="line">              &quot;start_offset&quot;: 13,</div><div class="line">              &quot;end_offset&quot;: 17</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 3,</div><div class="line">              &quot;start_offset&quot;: 18,</div><div class="line">              &quot;end_offset&quot;: 22</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        &quot;twitter&quot;: &#123;</div><div class="line">          &quot;term_freq&quot;: 1,</div><div class="line">          &quot;tokens&quot;: [</div><div class="line">            &#123;</div><div class="line">              &quot;position&quot;: 0,</div><div class="line">              &quot;start_offset&quot;: 0,</div><div class="line">              &quot;end_offset&quot;: 7</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="过滤词条"><a href="#过滤词条" class="headerlink" title="过滤词条"></a>过滤词条</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GET /twitter/tweet/_termvectors</div><div class="line">&#123;</div><div class="line">    &quot;doc&quot;: &#123;</div><div class="line">      &quot;plot&quot;: &quot;When wealthy industrialist Tony Stark is forced to build an armored suit after a life-threatening incident, he ultimately decides to use its technology to fight against evil.&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;term_statistics&quot; : true,</div><div class="line">    &quot;field_statistics&quot; : true,</div><div class="line">    &quot;positions&quot;: false,</div><div class="line">    &quot;offsets&quot;: false,</div><div class="line">    &quot;filter&quot; : &#123;</div><div class="line">      &quot;max_num_terms&quot; : 3,</div><div class="line">      &quot;min_term_freq&quot; : 1,</div><div class="line">      &quot;min_doc_freq&quot; : 1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_version&quot;: 0,</div><div class="line">  &quot;found&quot;: true,</div><div class="line">  &quot;took&quot;: 1324,</div><div class="line">  &quot;term_vectors&quot;: &#123;</div><div class="line">    &quot;plot&quot;: &#123;</div><div class="line">      &quot;field_statistics&quot;: &#123;</div><div class="line">        &quot;sum_doc_freq&quot;: 26,</div><div class="line">        &quot;doc_count&quot;: 1,</div><div class="line">        &quot;sum_ttf&quot;: 28</div><div class="line">      &#125;,</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;after&quot;: &#123;</div><div class="line">          &quot;doc_freq&quot;: 1,</div><div class="line">          &quot;ttf&quot;: 1,</div><div class="line">          &quot;term_freq&quot;: 1,</div><div class="line">          &quot;score&quot;: 0.30685282</div><div class="line">        &#125;,</div><div class="line">        &quot;against&quot;: &#123;</div><div class="line">          &quot;doc_freq&quot;: 1,</div><div class="line">          &quot;ttf&quot;: 1,</div><div class="line">          &quot;term_freq&quot;: 1,</div><div class="line">          &quot;score&quot;: 0.30685282</div><div class="line">        &#125;,</div><div class="line">        &quot;to&quot;: &#123;</div><div class="line">          &quot;doc_freq&quot;: 1,</div><div class="line">          &quot;ttf&quot;: 3,</div><div class="line">          &quot;term_freq&quot;: 3,</div><div class="line">          &quot;score&quot;: 0.92055845</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Multi-termvectors-API"><a href="#Multi-termvectors-API" class="headerlink" title="Multi termvectors API"></a>Multi termvectors API</h2><p>这个API可以进行一次获得多个termvectors。可以通过指定索引、类型或者id来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_mtermvectors&apos; -d &apos;&#123;</div><div class="line">   &quot;docs&quot;: [</div><div class="line">      &#123;</div><div class="line">         &quot;_index&quot;: &quot;testidx&quot;,</div><div class="line">         &quot;_type&quot;: &quot;test&quot;,</div><div class="line">         &quot;_id&quot;: &quot;2&quot;,</div><div class="line">         &quot;term_statistics&quot;: true</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">         &quot;_index&quot;: &quot;testidx&quot;,</div><div class="line">         &quot;_type&quot;: &quot;test&quot;,</div><div class="line">         &quot;_id&quot;: &quot;1&quot;,</div><div class="line">         &quot;fields&quot;: [</div><div class="line">            &quot;text&quot;</div><div class="line">         ]</div><div class="line">      &#125;</div><div class="line">   ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>参数方面，和termvectors一致，具体参照termvectors。</p>
<p>指定index的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/testidx/_mtermvectors&apos; -d &apos;&#123;</div><div class="line">   &quot;docs&quot;: [</div><div class="line">      &#123;</div><div class="line">         &quot;_type&quot;: &quot;test&quot;,</div><div class="line">         &quot;_id&quot;: &quot;2&quot;,</div><div class="line">         &quot;fields&quot;: [</div><div class="line">            &quot;text&quot;</div><div class="line">         ],</div><div class="line">         &quot;term_statistics&quot;: true</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">         &quot;_type&quot;: &quot;test&quot;,</div><div class="line">         &quot;_id&quot;: &quot;1&quot;</div><div class="line">      &#125;</div><div class="line">   ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>指定type的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/testidx/test/_mtermvectors&apos; -d &apos;&#123;</div><div class="line">   &quot;docs&quot;: [</div><div class="line">      &#123;</div><div class="line">         &quot;_id&quot;: &quot;2&quot;,</div><div class="line">         &quot;fields&quot;: [</div><div class="line">            &quot;text&quot;</div><div class="line">         ],</div><div class="line">         &quot;term_statistics&quot;: true</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">         &quot;_id&quot;: &quot;1&quot;</div><div class="line">      &#125;</div><div class="line">   ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>如果所有的文档都是同一个index和type，那么就简单很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/testidx/test/_mtermvectors&apos; -d &apos;&#123;</div><div class="line">    &quot;ids&quot; : [&quot;1&quot;, &quot;2&quot;],</div><div class="line">    &quot;parameters&quot;: &#123;</div><div class="line">        &quot;fields&quot;: [</div><div class="line">                &quot;text&quot;</div><div class="line">        ],</div><div class="line">        &quot;term_statistics&quot;: true,</div><div class="line">        …</div><div class="line">    &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>和termvectors一样，也能够使用用户自己定义的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_mtermvectors&apos; -d &apos;&#123;</div><div class="line">   &quot;docs&quot;: [</div><div class="line">      &#123;</div><div class="line">         &quot;_index&quot;: &quot;testidx&quot;,</div><div class="line">         &quot;_type&quot;: &quot;test&quot;,</div><div class="line">         &quot;doc&quot; : &#123;</div><div class="line">            &quot;fullname&quot; : &quot;John Doe&quot;,</div><div class="line">            &quot;text&quot; : &quot;twitter test test test&quot;</div><div class="line">         &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">         &quot;_index&quot;: &quot;testidx&quot;,</div><div class="line">         &quot;_type&quot;: &quot;test&quot;,</div><div class="line">         &quot;doc&quot; : &#123;</div><div class="line">           &quot;fullname&quot; : &quot;Jane Doe&quot;,</div><div class="line">           &quot;text&quot; : &quot;Another twitter test ...&quot;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   ]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Index-API&quot;&gt;&lt;a href=&quot;#Index-API&quot; class=&quot;headerlink&quot; title=&quot;Index API&quot;&gt;&lt;/a&gt;Index API&lt;/h2&gt;&lt;p&gt;index API 用来向指定的index添加或更新JSON文档，并使它可被搜索。下
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://chenpeng89.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记：二、基本设置</title>
    <link href="http://chenpeng89.github.io/2016/09/22/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/"/>
    <id>http://chenpeng89.github.io/2016/09/22/Elasticsearch学习笔记：二、基本设置/</id>
    <published>2016-09-22T01:49:19.000Z</published>
    <updated>2016-09-22T04:12:19.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="JAVA版本"><a href="#JAVA版本" class="headerlink" title="JAVA版本"></a>JAVA版本</h3><p>es是由java开发的，运行也需要java环境。需要保证jdk至少是1.7及以上的。且仅支持Oracle’sJava和OpenJDK。在es的所有节点和客户端中，jdk的版本号应该是一致的。<br>官方推荐安装jdk8 update20及以后或者jdk8 update 55及以后。之前的版本有bug因此会容易丢失数据。es也会自动判断，如果是不好的版本，它会拒绝启动。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="external">下载</a>最新的版本后，解压压缩包，然后就可以启动了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch</div></pre></td></tr></table></figure></p>
<h3 id="作为守护进程启动"><a href="#作为守护进程启动" class="headerlink" title="作为守护进程启动"></a>作为守护进程启动</h3><p>在*nix系统中，还可以作为守护进程启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch -d</div></pre></td></tr></table></figure></p>
<h3 id="指定PID"><a href="#指定PID" class="headerlink" title="指定PID"></a>指定PID</h3><p>为了维护方便，还可以指定es的pid:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch -d -p pid </div><div class="line">$ kill `cat pid`</div></pre></td></tr></table></figure></p>
<ul>
<li>PID应该被写在名为pid的文件中。</li>
<li>kill命令会发送一个term信号给pid文件中的PID。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>通过脚本，es可以向JVM传递JAVA_OPT参数。其中，最重要的参数是-Xms和-Xmx，它们用来控制进程的内存大小。<br>大多数情况下，最好用ES_JAVA_OPTS环境变量来替代JAVA_OPTS，这样可以不影响其它jvm项目的运行。<br>ES_HEAP_SIZE环境变量用来设置分配给esjava进程的堆内存大小。它会吧最大值和最小值设为同一个值。当然，也可以自己指定最大值和最小值，使用ES_MIN_MEM(默认是256m) 和 ES_MAX_MEM(默认是1G)。<br>值得推荐的做法是将最大值和最小值设为相同的值，并且开启mlockall（之后会有介绍）。</p>
<h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>确保要增加服务器中打开文件描述符的数量。设置为32K或者64是比较推荐的做法。<br>可以使用Nodes API查看文件描述符的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl localhost:9200/_nodes/stats/process?pretty</div></pre></td></tr></table></figure></p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>es默认使用 hybrid mmapfs / niofs 目录来存储index。默认情况下，os的限制的mmap数量可能过小，有可能会引起内存溢出。在Linux中，可以通过指令增加这个限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -w vm.max_map_count=262144</div></pre></td></tr></table></figure></p>
<p>或者为了让这个设置永久生效，可以在/etc/sysctl.conf设置vm.max_map_count 这个参数。</p>
<h4 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h4><p>大多数os会使用尽可能大的内存来做文件缓存，并将不用的应用程序内存换出，这就有可能将es的进程换出去了。换出这个动作对于es是非常影响效率的，并引起节点的不稳定，因此，应该尽量避免换出。<br>有以下三个解决方案：</p>
<ul>
<li><p>禁止换出<br>最简单的方案就是完全禁止换出操作。<br>在Linux系统中，如果暂时禁止换出，可以使用 sudo swapoff -a 命令。如果想永久生效，可以在 /etc/fstab 文件中将带有 swap的行通通注释掉。<br>在Windows中，可以通过 System Properties → Advanced → Performance → Advanced → Virtual memory 禁止分页文件来实现。</p>
</li>
<li><p>设置 swappiness<br>第二个方案是将sysctl 中 vm.swappiness设为0。这个操作会降低内核换出操作的频率。除非系统处于不得不换出的状态，一般情况下都不会执行换出操作。<br>注意，在内核版本 3.5-rc1及以上，swappiness为0会导致OOM杀掉进程而不是换出。你需要将swappiness设为1来允许在紧急情况下的换出。</p>
</li>
<li><p>mlockall<br>第三个方案是，在Linux中使用mlockall或者在Windows中使用VirtualLock，来锁住RAM中的进程地址空间，防止es内存被换出去，这个可以在 config/elasticsearch.yml 文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bootstrap.memory_lock: true</div></pre></td></tr></table></figure>
<p>在启动后，可以查看mlockall状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl http://localhost:9200/_nodes/process?pretty</div></pre></td></tr></table></figure>
<p>如果你看到mlockall是false，它意味着mlockall失败了。在Linuxl/Unix中，一般是因为es没有权限锁内存。这个在启动es前可以通过<code>ulimit -l unlimited as root</code> 来授权。<br>另一个可能的原因是临时目录（一般是/tmp）被安装了noexec 选项，这可以通过指定一个新的临时文件目录来解决:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/elasticsearch -Djna.tmpdir=/path/to/new/dir</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Elasticsearch设置"><a href="#Elasticsearch设置" class="headerlink" title="Elasticsearch设置"></a>Elasticsearch设置</h3><p>es配置文件可以在 ES_HOME/config 文件夹中找到。它包括两个文件，elasticsearch.yml 用于es的不同模块的设置，logging.yml 用于配置es的日志。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>在生产环境中，一般会设置两个路径来存储数据和日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">path:</div><div class="line">  logs: /var/log/elasticsearch</div><div class="line">  data: /var/data/elasticsearch</div></pre></td></tr></table></figure></p>
<h4 id="集群名称"><a href="#集群名称" class="headerlink" title="集群名称"></a>集群名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cluster:</div><div class="line">  name: &lt;NAME OF YOUR CLUSTER&gt;</div></pre></td></tr></table></figure>
<p>要保证你不会在不同的环境使用相同的集群名称，否则节点有可能加入到错误的集群中。你可以在生产环境用 logging-prod ，开发环境 logging-dev，分支环境使用 loggin-stage。</p>
<h4 id="节点名称"><a href="#节点名称" class="headerlink" title="节点名称"></a>节点名称</h4><p>你可以为每个节点修改他们的节点名称以便于管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node:</div><div class="line">  name: &lt;NAME OF YOUR NODE&gt;</div></pre></td></tr></table></figure></p>
<p>hostname一般存在于服务器的HOSTNAME环境变量中，如果你的机器对于集群运行一个单独的es节点，你可以设置节点名称为hostname<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node:</div><div class="line">  name: $&#123;HOSTNAME&#125;</div></pre></td></tr></table></figure></p>
<h4 id="设置配置文件格式"><a href="#设置配置文件格式" class="headerlink" title="设置配置文件格式"></a>设置配置文件格式</h4><p>在es中，所有的设置都被包围在 anmespaced中。例如，上面这些设置都在node.name中。这意味着可以支持其他格式的配置文件，比如JSON。如果使用JSON，可以将elasticsearch.yml修改为elasticsearch.json。相应的，里面的设置格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;network&quot; : &#123;</div><div class="line">        &quot;host&quot; : &quot;10.0.0.4&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Index设置"><a href="#Index设置" class="headerlink" title="Index设置"></a>Index设置</h3><p>集群中的index可以维护自己的设置。例如，可以将创建index的刷新间隔时间设置为5s。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT http://localhost:9200/kimchy/ -d \</div><div class="line">&apos;</div><div class="line">index:</div><div class="line">    refresh_interval: 5s</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>Index级别的设置也可以在node级别中设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">index :</div><div class="line">    refresh_interval: 5s</div></pre></td></tr></table></figure></p>
<p>如果index和node都设置了，那么指定的index会覆盖node的设置。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>es内部使用了log4j。配置文件是config/logging.yml。也支持JSON和properties文件。</p>
<h4 id="过期行为的日志"><a href="#过期行为的日志" class="headerlink" title="过期行为的日志"></a>过期行为的日志</h4><p>除了常规的日志，es还能记录过期行为的日志。这对于迁移是一个很大的优势。默认它是关闭的，在 config/logging.yml 开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deprecation: DEBUG, deprecation_log_file</div></pre></td></tr></table></figure></p>
<p>它会在日志目录下创建一个每天滚动的日志文件。定期检查这个文件，针对于当你想要升级到一个新的大版本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h3 id=&quot;JAVA版本&quot;&gt;&lt;a href=&quot;#JAVA版本&quot; class=&quot;headerlink&quot; title=&quot;JAVA版本&quot;&gt;&lt;/a&gt;J
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://chenpeng89.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记：一、入门</title>
    <link href="http://chenpeng89.github.io/2016/09/21/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E3%80%81%E5%85%A5%E9%97%A8/"/>
    <id>http://chenpeng89.github.io/2016/09/21/Elasticsearch学习笔记：一、入门/</id>
    <published>2016-09-21T03:59:46.000Z</published>
    <updated>2016-09-21T10:11:38.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Elasticsearch是一个分布式的开源的全文分析搜索引擎，它基于Lucene，提供一个接近实时的搜索。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Near-Realtine-NRT"><a href="#Near-Realtine-NRT" class="headerlink" title="Near Realtine(NRT)"></a>Near Realtine(NRT)</h3><p>Es是一个接近实时的搜索平台。这意味着，当你index一个文档到能搜索到它，需要花费一些很少的时间（通常是一秒）。</p>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>cluster是一个由一个或多个服务节点组成的集合，它包含了你所有的数据并提供了对所有节点的索引和搜索。一个cluster会被一个名称唯一标识，默认名称是“elasticsearch”。这个名字非常重要，因为节点会通过集群的名字来确定加入的集群。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>一个节点是你cluster中一个独立的服务，存储数据，组成cluster的index，提供搜索的能力。在一个cluster中，它的节点会被节点名称唯一标识，默认是一个随机的Marvel人物的名称。节点名称对于管理节点是非常重要的。<br>一个节点可以cluster名称来决定参加哪个cluster。默认情况下，在你网络中又多个节点，并且它们可以互相连通，那么它们会自动组成并加入一个名字为”elasticsearch”的cluster。<br>在一个cluster中，如果只有一个节点，那么它会自动形成一个名叫“elasticsearch”的单节点cluster。</p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>index是有相同特征的文档的集合。例如，你可以有一个用户数据的index，或者产品目录的index。一个index被一个名称表示，名称必须是小写字母，这个名称可以用来对文档执行索引、创建，搜索，更新和删除等操作。</p>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>在index中，你可以定义一个或多个type。type是一个逻辑类别还是index的一部分，这些都取决于你的定义。一般来说，一个type是具有相同field的文档。例如，我们假设你运行一个blog平台，并且存储所有的数据在一个单独的index中。在这个index中，你可能会定义一个type为user数据，另一个type为blog数据，还有其它type为评论数据等等。</p>
<h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><p>document是被索引的基本数据单位。例如，你可能有一个文档是针对单个用户，另一个文档是某个商品等。document用JSON来存储。<br>在index/type类型中，你可以存储很多document。</p>
<h3 id="Shards-amp-Replicas"><a href="#Shards-amp-Replicas" class="headerlink" title="Shards &amp; Replicas"></a>Shards &amp; Replicas</h3><p>一个index能够存储非常大量的数据，有时可能会超过单个节点硬件的限制。例如。一个index存储一超过1TB的数据，这对于单个节点有可能是负担不起的。为了解决这个问题，es可以讲index分片到不同的shards中。当你创建一个index，你可以定义你想要的shards数量。每一个shard对于自己来说都是一个拥有所有功能并且有独立的index，可以被放到任何node上。<br>分片有两个重要的优势：</p>
<ul>
<li>它允许你水平 分割/扩展 你的内容。</li>
<li>它允许你并行处理不同分片上的数据来提高效率。 为了保证高可用性，可以为每个分片节点设置备份节点。</li>
</ul>
<p>对于如何进行分片以及进行聚合操作时文档是怎样merge的，es都自动管理了，并且对用户是透明的。</p>
<p>在网络环境中，当某个服务失效了，failover机制是非常有效的高可用保障。es也提供了对于index分片的复制。<br>复制机制有两个重要特点：</p>
<ul>
<li>它提供了高可用性以防一个shard/node失效。值得注意的是，一个shard复制不要和它本身放在同一个节点。</li>
<li>它通过对所有复制shard的并行搜索来提高你系统的吞吐量。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>es运行环境需要jdk1.7及以上，下载jdk直接去oracle官网下。然后<a href="http://www.elastic.co/downloads" target="_blank" rel="external">下载es </a>。<br>解压后，启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elasticsearch-2.4.0/bin/elasticsearch</div></pre></td></tr></table></figure></p>
<p>之前提到过，我们可以覆盖cluster和node名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./elasticsearch --cluster.name my_cluster_name --node.name my_node_name</div></pre></td></tr></table></figure></p>
<h2 id="探索集群和Index"><a href="#探索集群和Index" class="headerlink" title="探索集群和Index"></a>探索集群和Index</h2><p>现在我们已经让节点和集群运行起来了，下一步怎么和es进行沟通交流呢？幸运的是，es提供了一个非常好用的restAPI。通过api我们可以做这些事情：</p>
<ul>
<li>检查集群，节点和index的健康状况，状态和统计数据。</li>
<li>管理集群、节点和index的数据和元数据。</li>
<li>执行CRUD和一些针对index的搜索操作。</li>
<li>执行高级的搜索操作，例如分页，排序，过滤，脚本，聚合以及其他。</li>
</ul>
<h3 id="集群的健康监测"><a href="#集群的健康监测" class="headerlink" title="集群的健康监测"></a>集群的健康监测</h3><p>接下来，我们对集群进行一个基本的简单的健康监测。前文提到了，因为es通过restAPI来进行操作，所以可以使用curl或者postman等。<br>检测cluster的健康状况，我们可以使用_cat API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/health?v&apos;</div></pre></td></tr></table></figure></p>
<p>返回的结果是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign</div><div class="line">1394735289 14:28:09  elasticsearch green           1         1      0   0    0    0        0</div></pre></td></tr></table></figure></p>
<p>其中status显示了当前的健康状况。<br>status的定义如下： </p>
<ul>
<li>green ： everything is ok。 </li>
<li>yellow： 所有数据可用，但是一些备份节点的数据尚未被分配。 </li>
<li>red ： 一些数据不可用。</li>
</ul>
<p>还可以查看节点的状况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/nodes?v&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">host         ip        heap.percent ram.percent load node.role master name</div><div class="line">mwubuntu1    127.0.1.1            8           4 0.00 d         *      New Goblin</div></pre></td></tr></table></figure></p>
<h3 id="查询所有的index"><a href="#查询所有的index" class="headerlink" title="查询所有的index"></a>查询所有的index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/indices?v&apos;</div></pre></td></tr></table></figure>
<p>返回为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">health status index   pri rep docs.count docs.deleted store.size pri.store.size </div><div class="line">yellow open   secilog   5   1          1            0      4.2kb          4.2kb </div><div class="line">green  open   twitter   1   0          2            0      7.2kb          7.2kb</div></pre></td></tr></table></figure></p>
<p>上面显示了，我有两个index，一个secilog，还有一个twitter，当然，这些都是我后来自己建的，新安装的es是没有的，它会返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">health index pri rep docs.count docs.deleted store.size pri.store.size</div></pre></td></tr></table></figure></p>
<h3 id="创建一个Index"><a href="#创建一个Index" class="headerlink" title="创建一个Index"></a>创建一个Index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer?pretty&apos;</div></pre></td></tr></table></figure>
<p>返回：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"acknowledged"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/indices?v&apos;</div><div class="line">health index    pri rep docs.count docs.deleted store.size pri.store.size</div><div class="line">yellow customer   5   1          0            0       495b           495b</div></pre></td></tr></table></figure></p>
<p>这里status是yellow，是因为默认情况下，es默认会为每一个shards创建一个replica，但是由于目前我们只是一个单节点的，所以replica没有地方进行分配，所以就是yellow了。</p>
<h3 id="索引并查询一个文档"><a href="#索引并查询一个文档" class="headerlink" title="索引并查询一个文档"></a>索引并查询一个文档</h3><p>下面我们放一些数据到刚才定义的index中。还记得之前提到过的type么，我们必须为文档指定type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;John Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">  &quot;_type&quot;: &quot;external&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 1,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 2,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面显示创建成功了。不过，值得注意的是，如果上面的customer之前不存在，那么es会自动创建一个名为customer的index。</p>
<p>然后我们就可以搜索到了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;localhost:9200/customer/external/1?pretty&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot; : &quot;customer&quot;,</div><div class="line">  &quot;_type&quot; : &quot;external&quot;,</div><div class="line">  &quot;_id&quot; : &quot;1&quot;,</div><div class="line">  &quot;_version&quot; : 1,</div><div class="line">  &quot;found&quot; : true,</div><div class="line">  &quot;_source&quot; : &#123;</div><div class="line">    &quot;name&quot; : &quot;John Doe&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除一个Index"><a href="#删除一个Index" class="headerlink" title="删除一个Index"></a>删除一个Index</h3><p>现在我们可以删除刚刚创建的index：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE &apos;localhost:9200/customer?pretty&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;acknowledged&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据上面的操作，不难看出，es针对index的操作一般遵循这个格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X&lt;REST Verb&gt; &lt;Node&gt;:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</div></pre></td></tr></table></figure></p>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>es提供对于数据的修改以及接近实时的搜索功能。在你index/update/delete数据后，到你可以搜索到这些改变，一般需要1秒钟的延迟。这对于其他平台比如SQL来说，是一个非常大的区别。</p>
<h3 id="创建-替换索引文档"><a href="#创建-替换索引文档" class="headerlink" title="创建/替换索引文档"></a>创建/替换索引文档</h3><p>之前我们已经看到了如何对一个文档进行索引，让我们回顾一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;John Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>接着，上面的操作会为customer创建一个文档，type是external，id是1.如果我们执行同样的操作但是使用不同的数据，es会覆盖之前已经存在的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>如果我们不指定ID，es会为自动生成一个id并用它来索引文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">  &quot;_type&quot;: &quot;external&quot;,</div><div class="line">  &quot;_id&quot;: &quot;AVdLq7nyMju-ZsxkZnGp&quot;,</div><div class="line">  &quot;_version&quot;: 1,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 2,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<font color="red"><strong>值得注意的是，在不指定ID时，我们应该使用的是POST请求。</strong></font>

<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>为了创建/替换索引文档，我们还可以更新文档的内容。但是，es并不进行就地的更新。当我们执行一个update，es会删除旧的文档然后在桶中索引一个新的文档。</p>
<p>接下来更新之前的id=1的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/1/_update?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>也可以使用script来进行更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/1/_update?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;script&quot; : &quot;ctx._source.age += 5&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>有时可能会返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;error&quot;: &#123;</div><div class="line">    &quot;root_cause&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;type&quot;: &quot;remote_transport_exception&quot;,</div><div class="line">        &quot;reason&quot;: &quot;[Witchfire][127.0.0.1:9300][indices:data/write/update[s]]&quot;</div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    &quot;type&quot;: &quot;illegal_argument_exception&quot;,</div><div class="line">    &quot;reason&quot;: &quot;failed to execute script&quot;,</div><div class="line">    &quot;caused_by&quot;: &#123;</div><div class="line">      &quot;type&quot;: &quot;script_exception&quot;,</div><div class="line">      &quot;reason&quot;: &quot;scripts of type [inline], operation [update] and lang [groovy] are disabled&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;status&quot;: 400</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是由于es基于安全考虑，将脚本功能禁用了，可以在config/elasticsearch.yml文件添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">script.inline: on</div><div class="line">script.indexed: on</div><div class="line">script.file: on</div></pre></td></tr></table></figure></p>
<p>配置后，重启Elasticsearch。</p>
<p>再执行上面的操作，就可以了。</p>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE &apos;localhost:9200/customer/external/2?pretty&apos;</div></pre></td></tr></table></figure>
<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><p>es对于index/uodate/delete等操作也可以进行批量处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/_bulk?pretty&apos; -d &apos;</div><div class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</div><div class="line">&#123;&quot;name&quot;: &quot;John Doe&quot; &#125;</div><div class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</div><div class="line">&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>也可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/_bulk?pretty&apos; -d &apos;</div><div class="line">&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</div><div class="line">&#123;&quot;doc&quot;: &#123; &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot; &#125; &#125;</div><div class="line">&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>bulkAPI 会按顺序执行请求。如果某个请求失败了，不管是什么原因，它都会继续执行接下来的请求。当返回结果时，它会告诉你哪些成功哪些失败。</p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h3><p>下面我们来进行一些简单的查询操作。es提供了两种基本的查询方式：</p>
<ul>
<li>REST request URI</li>
<li>REST request body</li>
</ul>
<p>顾名思义，request body就是在请求体中添加参数，而URI则是在 URI中写明参数。<br>下面，用URI方式进行查询请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/customer/_search?q=*&amp;pretty&apos;</div></pre></td></tr></table></figure></p>
<p>来分析一下查询请求，我们使用了_search 在customer index中，q=*说明了es要查询index中所有的文档。preety参数说明返回结果打印的时候打印一个规范的json格式。</p>
<p>返回结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 109,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 3,</div><div class="line">    &quot;max_score&quot;: 1,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">        &quot;_type&quot;: &quot;external&quot;,</div><div class="line">        &quot;_id&quot;: &quot;2&quot;,</div><div class="line">        &quot;_score&quot;: 1,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">        &quot;_type&quot;: &quot;external&quot;,</div><div class="line">        &quot;_id&quot;: &quot;AVdLq7nyMju-ZsxkZnGp&quot;,</div><div class="line">        &quot;_score&quot;: 1,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">        &quot;_type&quot;: &quot;external&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 1,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>针对返回结果，我们可以看到这些部分：</p>
<ul>
<li>took - es用于执行查询所用的时间，单位为毫秒。</li>
<li>time_out - 告诉我们查询是否超时了。</li>
<li>_shards - 告诉我们以供查询了多少shards，以及它们成功与否。</li>
<li>hits - 查询的命中结果。</li>
<li>hits.total - 符合我们查询规则的文档总数。</li>
<li>hits.hits - 查询结果数组，默认为前10个文档。</li>
<li>_score和max_score - 先忽略它们。</li>
</ul>
<p>使用request body查询方式来达到相同的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/bank/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>非常重要的一点，一旦你的搜索结果返回了，那么，es不会保留任何的服务端资源或者在你结果集上的游标。这和其他的平台形成了鲜明的对比，比如SQL，你可能在一开始只是获取到你查询结果的子集，之后还需要向服务器使用某些服务端有状态的游标来抓取剩下的结果集。</p>
<h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><p>首先，我们来看一下返回的文档字段。默认情况下，会返回文档的所有字段，我们可以指定返回的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</div><div class="line">  &quot;_source&quot;: [&quot;name&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>接下来，我们看一下query部分，之前，我们都是使用的match_all，会返回所有的文档。下面我们加一些限制条件，查询name包含Jane 或者 Doe的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123;&quot;name&quot; : &quot;Jane Doe&quot;&#125; &#125;,</div><div class="line">  &quot;_source&quot;: [&quot;name&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>查询name同时包含“Jane Doe”短语的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123;&quot;name&quot; : &quot;Jane Doe&quot;&#125; &#125;,</div><div class="line">  &quot;_source&quot;: [&quot;name&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>下面是布尔类型的query，表示and：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;,</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>表示OR：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;should&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;,</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>表示都为false:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must_not&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;,</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>也可以自由组合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;</div><div class="line">      ],</div><div class="line">	  &quot;must_not&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h3><p>之前提到的score是一个数字，它用来评价当前返回的文档和我们需要的文档的匹配程度。分数越高的匹配程度越好。<br>但是查询并不是总需要产生score，尤其是它们只是用来过滤文档的时候。es能够自动的优化查询并不计算这些无用的score。<br>上文中的bool query也支持filter语句。filter语句可以在不改变score的情况下使用查询语句来限定文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</div><div class="line">      &quot;filter&quot;: &#123;</div><div class="line">        &quot;range&quot;: &#123;</div><div class="line">          &quot;age&quot;: &#123;</div><div class="line">            &quot;gte&quot;: 20000,</div><div class="line">            &quot;lte&quot;: 30000</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>由此可知，有的时候我们不需要关注score，那么久可以用filter来进行查询过滤，因为filter不会去计算score，那么它的效率相应会更高一些。</p>
<h3 id="执行聚合"><a href="#执行聚合" class="headerlink" title="执行聚合"></a>执行聚合</h3><p>聚合可以对数据进行分组并对分组进行数据统计。类似于SQL中的group by。在es中，可以一次性返回查询结果和局和结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_name&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;name&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>返回结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 159,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 3,</div><div class="line">    &quot;max_score&quot;: 0,</div><div class="line">    &quot;hits&quot;: []</div><div class="line">  &#125;,</div><div class="line">  &quot;aggregations&quot;: &#123;</div><div class="line">    &quot;group_by_state&quot;: &#123;</div><div class="line">      &quot;doc_count_error_upper_bound&quot;: 0,</div><div class="line">      &quot;sum_other_doc_count&quot;: 0,</div><div class="line">      &quot;buckets&quot;: [</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;doe&quot;,</div><div class="line">          &quot;doc_count&quot;: 3</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;jane&quot;,</div><div class="line">          &quot;doc_count&quot;: 3</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;becomes&quot;,</div><div class="line">          &quot;doc_count&quot;: 1</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;john&quot;,</div><div class="line">          &quot;doc_count&quot;: 1</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如按官网上的例子，统计不同银行账户下的平均余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/bank/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_state&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;state&quot;,</div><div class="line">        &quot;order&quot;: &#123;</div><div class="line">          &quot;average_balance&quot;: &quot;desc&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;average_balance&quot;: &#123;</div><div class="line">          &quot;avg&quot;: &#123;</div><div class="line">            &quot;field&quot;: &quot;balance&quot;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>或者对聚合进行嵌套，先按年龄范围分组，再统计不同性别的账户平均余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/bank/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_age&quot;: &#123;</div><div class="line">      &quot;range&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;age&quot;,</div><div class="line">        &quot;ranges&quot;: [</div><div class="line">          &#123;</div><div class="line">            &quot;from&quot;: 20,</div><div class="line">            &quot;to&quot;: 30</div><div class="line">          &#125;,</div><div class="line">          &#123;</div><div class="line">            &quot;from&quot;: 30,</div><div class="line">            &quot;to&quot;: 40</div><div class="line">          &#125;,</div><div class="line">          &#123;</div><div class="line">            &quot;from&quot;: 40,</div><div class="line">            &quot;to&quot;: 50</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;,</div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;group_by_gender&quot;: &#123;</div><div class="line">          &quot;terms&quot;: &#123;</div><div class="line">            &quot;field&quot;: &quot;gender&quot;</div><div class="line">          &#125;,</div><div class="line">          &quot;aggs&quot;: &#123;</div><div class="line">            &quot;average_balance&quot;: &#123;</div><div class="line">              &quot;avg&quot;: &#123;</div><div class="line">                &quot;field&quot;: &quot;balance&quot;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Elasticsearch是一个分布式的开源的全文分析搜索引擎，它基于Lucene，提供一个接近实时的搜索。&lt;/p&gt;
&lt;h2 id=&quot;基本概
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://chenpeng89.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记：六、访问限制</title>
    <link href="http://chenpeng89.github.io/2016/07/21/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%85%AD%E3%80%81%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/"/>
    <id>http://chenpeng89.github.io/2016/07/21/Nginx学习笔记：六、访问限制/</id>
    <published>2016-07-21T05:57:22.000Z</published>
    <updated>2016-09-20T07:33:28.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="限制访问HTTP代理资源"><a href="#限制访问HTTP代理资源" class="headerlink" title="限制访问HTTP代理资源"></a>限制访问HTTP代理资源</h2><h3 id="控制访问"><a href="#控制访问" class="headerlink" title="控制访问"></a>控制访问</h3><p>可以通过客户端IP地址或使用基于HTTP的身份认证。<br>使用IP地址控制访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    deny  192.168.1.2;</div><div class="line">    allow 192.168.1.1/24;</div><div class="line">    allow 127.0.0.1;</div><div class="line">    deny  all;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开启身份验证，可以使用 auth_basic指令。然后用户必须加入他们的有效用户名和密码来获取网站访问权。用户名和密码必须在auth_basic_user_file指定的文件中列举出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    auth_basic &quot;closed website&quot;;</div><div class="line">    auth_basic_user_file conf/htpasswd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以设置某些URL不需要身份认证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    auth_basic &quot;closed website&quot;;</div><div class="line">    auth_basic_user_file conf/htpasswd;</div><div class="line"></div><div class="line">    location /public/ &#123;</div><div class="line">        auth_basic off;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以使用satisfy指令来控制访问，如果需要某一个条件，则使用any ， 如果都需要满足，则使用all。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    satisfy any;</div><div class="line"></div><div class="line">    allow 192.168.1.0/24;</div><div class="line">    deny  all;</div><div class="line"></div><div class="line">    auth_basic           &quot;closed site&quot;;</div><div class="line">    auth_basic_user_file conf/htpasswd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="限制访问"><a href="#限制访问" class="headerlink" title="限制访问"></a>限制访问</h3><ul>
<li>限制访问的连接数<br>首先，使用 limit_conn_zone 指令定义key和共享的内存<br><code>limit_conn_zone $binary_remote_address zone=addr:10m;</code><br>第二步，使用limit_conn 指令指定使用的http 、 server 或者location。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /download/ &#123;</div><div class="line">    limit_conn addr 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里可以基于IP限制连接数，因为使用了$binary_remote_address 变量当做key。连接数也可以通过 server 名称来限制，通过使用$server_name变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    limit_conn_zone $server_name zone=servers:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        limit_conn servers 1000;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>限制访问率<br>限制访问率，首先使用 limit_req_zone 指令设置key和共享内存区域来供计数器使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>rate参数可以设置为每秒请求(r/s)或者每分钟请求 (r/m)。比如30r/m。<br>当设置了共享内存，使用limit_req指令在server 或 location中来限制速率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /search/ &#123;</div><div class="line">    limit_req zone=one burst=5;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，nginx不会再每秒处理多于一个请求在指定的location中。如果速率超过了请求限制，那么会将请求放入队列中延迟处理。burst参数设置了每秒处理请求的最大值，当超过了这个最大值，会返回503.<br>如果不想在设置了burst后有延迟处理，添加nodelay参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">limit_req zone=one burst=5 nodelay;</div></pre></td></tr></table></figure></p>
<ul>
<li>限制带宽<br>限制每个链接的带宽，可以使用limit_rate指令。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /download/ &#123;</div><div class="line">    limit_rate 50k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过这个设置，客户端最多能够下载50k内容通过一个单独的链接。然而，客户端能够开几个链接。所以如果想要更好的控制链接带宽，可以配合限制连接数使用。例如，一个IP一个连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /download/ &#123;</div><div class="line">    limit_conn addr 1;</div><div class="line">    limit_rate 50k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以允许客户端在下载一定量的数据后再进行限速：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">limit_rate_after 500k;</div><div class="line">limit_rate 20k;</div></pre></td></tr></table></figure></p>
<p>下面是一个完整的例子，限制了连接数和带宽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    limit_conn_zone $binary_remote_address zone=addr:10m</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        root /www/data;</div><div class="line">        limit_conn addr 5;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /download/ &#123;</div><div class="line">            limit_conn addr 1;</div><div class="line">            limit_rate 1m;</div><div class="line">            limit_rate 50k;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="限制访问TCP代理资源"><a href="#限制访问TCP代理资源" class="headerlink" title="限制访问TCP代理资源"></a>限制访问TCP代理资源</h2><h3 id="通过IP地址限制访问"><a href="#通过IP地址限制访问" class="headerlink" title="通过IP地址限制访问"></a>通过IP地址限制访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        listen 12345;</div><div class="line">        deny   192.168.1.2;</div><div class="line">        allow  192.168.1.1/24;</div><div class="line">        allow  2001:0db8::/32;</div><div class="line">        deny   all;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="限制TCP连接数"><a href="#限制TCP连接数" class="headerlink" title="限制TCP连接数"></a>限制TCP连接数</h3><p>可以有效的防止DOS攻击。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    limit_conn_zone $binary_remote_addr zone=ip_addr:10m;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大致和HTTP的配置方式差不多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    limit_conn_zone $binary_remote_addr zone=ip_addr:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line">        limit_conn ip_addr 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="限制带宽"><a href="#限制带宽" class="headerlink" title="限制带宽"></a>限制带宽</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    proxy_download_rate 100k;</div><div class="line">    proxy_upload_rate   50k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一个完整的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    limit_conn_zone $binary_remote_addr zone=ip_addr:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line">        limit_conn ip_addr 1;</div><div class="line">        proxy_download_rate 100k;</div><div class="line">        proxy_upload_rate   50k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;限制访问HTTP代理资源&quot;&gt;&lt;a href=&quot;#限制访问HTTP代理资源&quot; class=&quot;headerlink&quot; title=&quot;限制访问HTTP代理资源&quot;&gt;&lt;/a&gt;限制访问HTTP代理资源&lt;/h2&gt;&lt;h3 id=&quot;控制访问&quot;&gt;&lt;a href=&quot;#控制访问&quot; cla
    
    </summary>
    
    
      <category term="Nginx" scheme="http://chenpeng89.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记：五、负载均衡</title>
    <link href="http://chenpeng89.github.io/2016/07/18/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%94%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://chenpeng89.github.io/2016/07/18/Nginx学习笔记：五、负载均衡/</id>
    <published>2016-07-18T03:31:02.000Z</published>
    <updated>2016-09-20T07:33:56.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-负载均衡"><a href="#HTTP-负载均衡" class="headerlink" title="HTTP 负载均衡"></a>HTTP 负载均衡</h2><h3 id="负载一组服务器"><a href="#负载一组服务器" class="headerlink" title="负载一组服务器"></a>负载一组服务器</h3><p>在nginx中使用一组服务器之前，需要先定义一组服务器，在http块中使用upstream指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    upstream backend &#123;</div><div class="line">        server backend1.example.com weight=5;</div><div class="line">        server backend2.example.com;</div><div class="line">        server 192.0.0.1 backup;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想要将请求发送到一组后端服务器，还需要指定这组服务器的名称，使用 proxy_pass ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://backend;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="选择一个负载均衡的方法"><a href="#选择一个负载均衡的方法" class="headerlink" title="选择一个负载均衡的方法"></a>选择一个负载均衡的方法</h3><ol>
<li><p>轮询<br>根据服务器的权重将请求均匀的分布到所有服务器上。这个是默认的策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">   server backend1.example.com;</div><div class="line">   server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>连接数最小<br>将请求发送到目前连接数最小的服务器上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    least_conn;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ip_hash<br>由客户端IP决定发送到哪个服务器上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    ip_hash;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果哪个服务器需要暂时停止服务，可以使用down指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">    server backend3.example.com down;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>一致性hash<br>通过用户定义的key来决定请求分发到哪台服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    hash $request_uri consistent;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最低延迟和最小连接数<br>选取最低延迟和最小连接数的服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    least_time header;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>header : 从服务器接收到第一个字节所用的时间。<br>last_byte ： 从服务器接收全部响应所用的时间。</p>
<h3 id="服务器权重"><a href="#服务器权重" class="headerlink" title="服务器权重"></a>服务器权重</h3><p>默认情况下，nginx根据服务器的权重来进行轮训的分发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com weight=5;</div><div class="line">    server backend2.example.com;</div><div class="line">    server 192.0.0.1 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三个服务器设为 backup，只有当前两个服务器不可用时，它才能接收请求。</p>
<h3 id="服务器慢启动"><a href="#服务器慢启动" class="headerlink" title="服务器慢启动"></a>服务器慢启动</h3><p>服务器的慢启动能够保护从刚刚连接超时或者其他的原因不可用的状态恢复的服务器被连接淹没。<br>nginx慢启动可以逐步恢复服务器，一开始将服务器的权重设为0，然后逐步成为设置的权重。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com slow_start=30s;</div><div class="line">    server backend2.example.com;</div><div class="line">    server 192.0.0.1 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="session持久化"><a href="#session持久化" class="headerlink" title="session持久化"></a>session持久化</h3><p>session持久化意味着Nginx标识用户session并将请求发送到与之前相同的服务器上。<br>session支持三种session持久化方法：</p>
<ol>
<li>sticky cookie<br>使用这个方法，nginx会为第一个响应的upstream组添加一个session的cookie，并标识响应请求的服务器。当下次请求时，它会携带一个cookie的值，然后nginx将请求路由到相同的服务器上：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line"></div><div class="line">    sticky cookie srv_id expires=1h domain=.example.com path=/;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例子中，srv_id参数设置了cookie的名称。可选的expire参数设置了浏览器保持cookie的时间。可选的参数domian定义了一个设置cookie的domain。可选参数path定义了cookie设置的访问路径。这是最简单的session持久化方法。</p>
<ol>
<li><p>sticky route<br>nginx为第一次接受请求的客户端设置了一个route。所有后续请求将与server指令中识别服务器的route参数进行比较。<br>路由信息取自cookie或者URI。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com route=a;</div><div class="line">    server backend2.example.com route=b;</div><div class="line"></div><div class="line">    sticky route $route_cookie $route_uri;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>cookie learn<br>首先，nginx通过检查请求和响应来发现session标识。然后，nginx“学习”哪个upstream 服务器组和哪个session标识相关联。举荐的，这些标识被传进HTTPcookie。如果请求包含的session已经被“学习”，nginx将会直接将请求发送到关联的服务器上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">   server backend1.example.com;</div><div class="line">   server backend2.example.com;</div><div class="line"></div><div class="line">   sticky learn </div><div class="line">       create=$upstream_cookie_examplecookie</div><div class="line">       lookup=$cookie_examplecookie</div><div class="line">       zone=client_sessions:1m</div><div class="line">       timeout=1h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例子中，upstream的服务器在响应中通过设置cookie “EXAMPLECOOKIE”来创建了一个session。<br>必填的 create 参数指定了怎么创建一个新的session。在例子中，新的session是由upstream服务器发送的cookie “EXAMPLECOOKIE”创建的。<br>必填的参数 lookup 指定了怎么搜索已经存在的session。在例子中，从客户端发送的cookie “EXAMPLECOOKIE” 中查询已经存在的session。<br>必填的参数 zone 指定了一个保存所有session信息的共享内存。<br>这个策略不需要客户端保存任何cookie，所有信息保存在服务器端的共享内存中。</p>
<h3 id="限制连接数"><a href="#限制连接数" class="headerlink" title="限制连接数"></a>限制连接数</h3><p>如果MAX_CONNS已达到限制，该请求可以被放置到队列为提供该队列指令指定其进一步处理。该指令集，可以在队列中同时请求的最大数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com  max_conns=3;</div><div class="line">    server backend2.example.com;</div><div class="line"></div><div class="line">    queue 100 timeout=70;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有其它worker进程打开了空闲时keepalive，max_conn限制将会被忽略。结果是，连接到服务器的总数将会超过max_conns。</p>
<h3 id="被动的健康监测"><a href="#被动的健康监测" class="headerlink" title="被动的健康监测"></a>被动的健康监测</h3><p>当nginx认为一个服务器不可用时，它会暂时停止发送请求到这台服务器知道服务器被认为可用。<br>max_fails和fail_timeout —— 这俩是关联的，如果某台服务器在fail_timeout时间内出现了max_fails次连接失败，那么nginx就会认为那个服务器已经挂掉，从而在 fail_timeout时间内不再去查询它，fail_timeout的默认值是10s，max_fails的默认值是1（这意味着一发生错误就认为服务器挂掉），如果把max_fails设为0则表示把这个检查取消。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;                </div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com max_fails=3 fail_timeout=30s;</div><div class="line">    server backend3.example.com max_fails=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主动的健康监测"><a href="#主动的健康监测" class="headerlink" title="主动的健康监测"></a>主动的健康监测</h3><p>预先发送一个指定的请求到每个服务器，并检测响应信息是否符合检测中的可用条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    upstream backend &#123;</div><div class="line">        zone backend 64k;</div><div class="line"></div><div class="line">        server backend1.example.com;</div><div class="line">        server backend2.example.com;</div><div class="line">        server backend3.example.com;</div><div class="line">        server backend4.example.com;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://backend;</div><div class="line">            health_check;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>zone 指令定义了被worker进程共享的并用来存储服务器组配置的内存区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    proxy_pass http://backend;</div><div class="line">    health_check interval=10 fails=3 passes=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>健康监测的时间间隔是10s，在失败3次后会认为是不可用的，以后需要两次通过监测才能认为是可用的。<br>也可以指定URI进行监测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    proxy_pass http://backend;</div><div class="line">    health_check uri=/some/path;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还可以设置macth块来指定健康监测的响应结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    match server_ok &#123;</div><div class="line">        status 200-399;</div><div class="line">        body !~ &quot;maintenance mode&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://backend;</div><div class="line">            health_check match=server_ok;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以定义返回头中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">match welcome &#123;</div><div class="line">    status 200;</div><div class="line">    header Content-Type = text/html;</div><div class="line">    body ~ &quot;Welcome to nginx!&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用!可以定义非的条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">match not_redirect &#123;</div><div class="line">    status ! 301-303 307;</div><div class="line">    header ! Refresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用DNS配置HTTP负载均衡"><a href="#使用DNS配置HTTP负载均衡" class="headerlink" title="使用DNS配置HTTP负载均衡"></a>使用DNS配置HTTP负载均衡</h3><p>服务器组的配置可以在运行时使用DNS修改。<br>nginx可以监控IP地址对应的域名服务器的变化，并自动将变化应用于nginx，且不用重启。这可以通过在http块中使用resolver指令，和server指令后的 resolver参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    resolver 10.0.0.1 valid=300s ipv6=off;</div><div class="line">    resolver_timeout 10s;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://backend;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    upstream backend &#123;</div><div class="line">        zone backend 32k;</div><div class="line">        least_conn;</div><div class="line">        ...</div><div class="line">        server backend1.example.com resolve;</div><div class="line">        server backend2.example.com resolve;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个示例中,服务器的resolve参数指令将定期通过IP地址重新解析 backend1.example.com和backend2.example.com服务器。默认情况下,NGINX基于TTL重新解析DNS记录,但TTL值可以覆盖resolve指令的valid参数,在我们的示例中是5分钟。<br>如果一个域名对应多个IP地址，那么IP地址会被存到upstream配置中并被负载均衡。在例子中，服务器会使用least_conn来负载均衡。如果一个活多个IP地址被修改、添加或删除，那么这些服务器也会被重新负载。</p>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>nginx的服务器组可以通过HTTP接口来动态配置。配置指令可以用来查看所有服务器或者服务器组，修改服务器参数或者添加删除服务器。</p>
<ul>
<li><p>设置动态配置</p>
<ol>
<li><p>将zone指令放入upstream块中。zone 指令配置了一个区域来共享内存，并设置zone 的名称和大小。服务器组的配置被存放到这个zone中，所有的worker进程都使用同样的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">  		upstream appservers &#123;</div><div class="line">      		zone appservers 64k;</div><div class="line">      		server appserv1.example.com      weight=5;</div><div class="line">      		server appserv2.example.com:8080 fail_timeout=5s;</div><div class="line">      		server reserve1.example.com:8080 backup;</div><div class="line">      		server reserve2.example.com:8080 backup;</div><div class="line">  		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>配置 upstream_conf指令到location块中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  		location /upstream_conf &#123;</div><div class="line">      		upstream_conf;</div><div class="line">      		...</div><div class="line">  		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为其设置访问白名单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">   	location /upstream_conf &#123;</div><div class="line">   	    upstream_conf;</div><div class="line">   	    allow 127.0.0.1;</div><div class="line">   	    deny  all;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>一个完整的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">   	...</div><div class="line">   	# Configuration of the server group</div><div class="line">   	upstream appservers &#123;</div><div class="line">       	zone appservers 64k;</div><div class="line"></div><div class="line">       	server appserv1.example.com      weight=5;</div><div class="line">       	server appserv2.example.com:8080 fail_timeout=5s;</div><div class="line"></div><div class="line">       	server reserve1.example.com:8080 backup;</div><div class="line">       	server reserve2.example.com:8080 backup;</div><div class="line">   	&#125;</div><div class="line"></div><div class="line">   	server &#123;</div><div class="line">       	# Location that proxies requests to the group</div><div class="line">       	location / &#123;</div><div class="line">           	proxy_pass http://appservers;</div><div class="line">           	health_check;</div><div class="line">       	&#125;</div><div class="line"></div><div class="line">       	# Location for configuration requests</div><div class="line">        location /upstream_conf &#123;</div><div class="line">   	        upstream_conf;</div><div class="line">   	        allow 127.0.0.1;</div><div class="line">   	        deny  all;</div><div class="line">   	    &#125;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>动态配置持久化<br>上面的动态配置会随着nginx配置文件的reload而失效，为了让它继续能有效果，需要将upstream服务器从upstream块移动到一个指定的文件中，能够保持upstream服务器的状态。文件的路径要在 state指令中设置。在Linux中，比较推荐的路径是/var/lib/nginx/state/。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    upstream appservers &#123;</div><div class="line">        zone appservers 64k;</div><div class="line">        state /var/lib/nginx/state/appservers.conf;</div><div class="line"></div><div class="line">        # All these servers should be moved to the file using the upstream_conf API:</div><div class="line">        # server appserv1.example.com      weight=5;</div><div class="line">        # server appserv2.example.com:8080 fail_timeout=5s;</div><div class="line">        # server reserve1.example.com:8080 backup;</div><div class="line">        # server reserve2.example.com:8080 backup;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，文件只能被 upstream_conf API来修改，应该避免直接修改文件。</p>
<ul>
<li>动态配置Upstream服务器<br>使用HTTP请求来将配置命令传递给nginx。请求需要有一个合适的URI来获取到location中的upstream_conf指令。请求需要包含upstream参数来确定修改的服务器组。<br>查看所有backup的服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?upstream=appservers&amp;backup=</div></pre></td></tr></table></figure>
</li>
</ul>
<p>添加一个新的服务器到组里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?add=&amp;upstream=appservers&amp;server=appserv3.example.com:8080&amp;weight=2&amp;max_fails=3</div></pre></td></tr></table></figure></p>
<p>删除一个服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?remove=&amp;upstream=appservers&amp;id=2</div></pre></td></tr></table></figure></p>
<p>修改一个服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?upstream=appservers&amp;id=2&amp;down=</div></pre></td></tr></table></figure></p>
<h2 id="TCP-UDP负载均衡"><a href="#TCP-UDP负载均衡" class="headerlink" title="TCP/UDP负载均衡"></a>TCP/UDP负载均衡</h2><h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><p>首先，需要额皮质一个反向代理来使nginx通过TCP连接或者UDP报文将客户端数据发送到upstream组或者一个代理服务器。</p>
<ol>
<li><p>在顶级目录创建一个stream块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在stream块中定义一个或多个server块</p>
</li>
<li><p>在server块中定义listen指令来监听ip和端口。对于UDP，还需要包含udp参数。TCP在stream块中是默认的，所以listen没有tcp参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 12345;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        listen 53 udp;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过proxy_pass指令来定义将要跳转的代理服务器或者upstream组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    server &#123;</div><div class="line">        listen     12345;</div><div class="line"></div><div class="line">        #TCP traffic will be proxied to the &quot;stream_backend&quot; upstream group</div><div class="line">        proxy_pass stream_backend;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen     12346;</div><div class="line"></div><div class="line">        #TCP traffic will be proxied a proxied server</div><div class="line">        proxy_pass backend.example.com:12346;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen     53 udp;</div><div class="line"></div><div class="line">        #UDP traffic will be proxied to the &quot;dns_servers&quot; upstream group</div><div class="line">        proxy_pass dns_servers;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果你的代理服务器有多个网络接口，你可以配置nginx选一个源ip地址来连接到upstream服务器。这对于后端服务器仅接受指定IP地址访问是有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        listen     127.0.0.1:12345;</div><div class="line">        proxy_pass backend.example.com:12345;</div><div class="line">        proxy_bind 127.0.0.1:12345;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>可以调整两个缓冲区的大小，这两个缓冲区用于nginx缓存客户端和upstream的连接中的数据。如果数据比较小，buffer会自动缩小来节省存储资源。如果有大量的数据,可以通过减少socket的读/写操作次数来增加buffer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        listen            127.0.0.1:12345;</div><div class="line">        proxy_pass        backend.example.com:12345;</div><div class="line">        proxy_buffer_size 16k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置TCP-UDP负载均衡"><a href="#配置TCP-UDP负载均衡" class="headerlink" title="配置TCP/UDP负载均衡"></a>配置TCP/UDP负载均衡</h3><p>创建一组服务器或upstream组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    upstream stream_backend &#123;</div><div class="line">        ...    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    upstream dns_servers &#123;</div><div class="line">        ...    </div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>剩下和HTTP差不多，如有疑问：<a href="https://www.nginx.com/resources/admin-guide/tcp-load-balancing/" target="_blank" rel="external">https://www.nginx.com/resources/admin-guide/tcp-load-balancing/</a></p>
<h2 id="设置代理协议"><a href="#设置代理协议" class="headerlink" title="设置代理协议"></a>设置代理协议</h2><p>代理协议允许nginx接受客户端连接信息并通过HAproy等发送给代理服务器。</p>
<p>通过代理协议发送的信息包括客户端IP地址、代理服务器IP和它们的端口号。知道原始的IP地址有助于网站的语言设置、访问黑名单或一些简单的log和静态资源。</p>
<p>通过代理协议，nginx可以获取到原始的ip地址通过SSL, HTTP/2, SPDY, WebSocket, 和 TCP。</p>
<h3 id="使用SSL-HTTP-2-SPDY-和-WebSocket-代理协议"><a href="#使用SSL-HTTP-2-SPDY-和-WebSocket-代理协议" class="headerlink" title="使用SSL, HTTP/2, SPDY, 和 WebSocket 代理协议"></a>使用SSL, HTTP/2, SPDY, 和 WebSocket 代理协议</h3><ol>
<li><p>配置nginx接受代理协议报文头。在listen中添加proxy_protocol参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80   proxy_protocol;</div><div class="line">    listen 443  ssl proxy_protocol;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在set_real_ip_from 指令中，指定ip地址或者TCP代理的CIDR地址范围或者负载均衡器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    set_real_ip_from 192.168.1.0/24;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在real_ip_header指令中，添加proxy_protocol参数来保持客户端IP地址和端口号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    real_ip_header proxy_protocol;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过proxy_set_header directive 和 $proxy_protocol_addr变量从nginx传递IP地址到upstream服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_set_header X-Real-IP       $proxy_protocol_addr;</div><div class="line">proxy_set_header X-Forwarded-For $proxy_protocol_addr;</div></pre></td></tr></table></figure>
</li>
<li><p>在http层添加 $proxy_protocol_addr 变量到  log_format指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    log_format combined &apos;$proxy_protocol_addr - $remote_user [$time_local] &apos;</div><div class="line">                        &apos;&quot;$request&quot; $status $body_bytes_sent &apos;</div><div class="line">                        &apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="在TCP流上使用代理协议"><a href="#在TCP流上使用代理协议" class="headerlink" title="在TCP流上使用代理协议"></a>在TCP流上使用代理协议</h3><p>nginx能够就在TCP流上传递代理协议数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 12345;</div><div class="line">        proxy_pass example.com:12345;</div><div class="line">        proxy_protocol on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="完整的样例"><a href="#完整的样例" class="headerlink" title="完整的样例"></a>完整的样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    log_format combined &apos;$proxy_protocol_addr - $remote_user [$time_local] &apos;</div><div class="line">                        &apos;&quot;$request&quot; $status $body_bytes_sent &apos;</div><div class="line">                        &apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&apos;;</div><div class="line">    ...</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        server_name localhost;</div><div class="line"></div><div class="line">        listen 80   proxy_protocol;</div><div class="line">        listen 443  ssl proxy_protocol;</div><div class="line"></div><div class="line">        ssl_certificate      /etc/nginx/ssl/public.example.com.pem;</div><div class="line">        ssl_certificate_key  /etc/nginx/ssl/public.example.com.key;</div><div class="line"></div><div class="line">        set_real_ip_from 192.168.1.0/24;</div><div class="line">        real_ip_header   proxy_protocol;</div><div class="line"></div><div class="line">        location /app/ &#123;</div><div class="line">            proxy_pass       http://backend1;</div><div class="line">            proxy_set_header Host            $host;</div><div class="line">            proxy_set_header X-Real-IP       $proxy_protocol_addr;</div><div class="line">            proxy_set_header X-Forwarded-For $proxy_protocol_addr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">stream &#123;</div><div class="line">...</div><div class="line">    server &#123;</div><div class="line">        listen         12345;</div><div class="line">        proxy_pass     example.com:12345;</div><div class="line">        proxy_protocol on;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-负载均衡&quot;&gt;&lt;a href=&quot;#HTTP-负载均衡&quot; class=&quot;headerlink&quot; title=&quot;HTTP 负载均衡&quot;&gt;&lt;/a&gt;HTTP 负载均衡&lt;/h2&gt;&lt;h3 id=&quot;负载一组服务器&quot;&gt;&lt;a href=&quot;#负载一组服务器&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Nginx" scheme="http://chenpeng89.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记：四、配置SSL</title>
    <link href="http://chenpeng89.github.io/2016/07/18/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AESSL/"/>
    <id>http://chenpeng89.github.io/2016/07/18/Nginx学习笔记：四、配置SSL/</id>
    <published>2016-07-18T01:30:57.000Z</published>
    <updated>2016-09-20T07:33:48.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过HTTPS传递Web内容"><a href="#通过HTTPS传递Web内容" class="headerlink" title="通过HTTPS传递Web内容"></a>通过HTTPS传递Web内容</h2><h3 id="配置一个HTTPS服务"><a href="#配置一个HTTPS服务" class="headerlink" title="配置一个HTTPS服务"></a>配置一个HTTPS服务</h3><p>建立一个HTTPS的nginx服务器，在nginx.conf中指定服务器的ssl参数与listen指令，然后设置服务器证书和私钥文件的位置:</p>
<p>x509证书一般会用到三类文，key，csr，crt。</p>
<p>Key 是私用密钥openssl格，通常是rsa算法。</p>
<p>Csr 是证书请求文件，用于申请证书。在制作csr文件的时，必须使用自己的私钥来签署申，还可以设定一个密钥。</p>
<p>crt是CA认证后的证书文，（windows下面的，其实是crt），签署人用自己的key给你签署的凭证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen              443 ssl;</div><div class="line">    server_name         www.example.com;</div><div class="line">    ssl_certificate     www.example.com.crt;</div><div class="line">    ssl_certificate_key www.example.com.key;</div><div class="line">    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_ciphers         HIGH:!aNULL:!MD5;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器证书是一个公共实体。它被发送到每一个连接到服务器的客户端。私钥是一个安全的实体，并应被存储在与限制访问的文件。然而，Nginx的的master进程必须能够读取该文件。私钥也可以和公钥存储在同一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssl_certificate xxx.cert;</div><div class="line">ssl_certificate_key xxx.cert;</div></pre></td></tr></table></figure></p>
<p>在这种情况下，文件的访问权限也需要被限制。虽然公钥和私钥在一个文件中，但是只有公钥会被发送到客户端。</p>
<p>ssl_protocols 和 ssl_ciphers 指令可以用来限制连接的版本和SSL/TLS的加密方式。</p>
<h3 id="https服务优化"><a href="#https服务优化" class="headerlink" title="https服务优化"></a>https服务优化</h3><p>SSL会给CPU带来额外的开销。最耗CPU的是SSL的握手过程。下面有两个方法能够减少每个客户端操作的数量：</p>
<ul>
<li>使keepalive连接通过一个连接发送多个请求</li>
<li>重用SSL会话参数来避免并行和随后的SSL握手连接</li>
</ul>
<p>session存储在SSL的 session缓存中，并被worker进程共享，这个可以用ssl_session_cache 配置。1M的cache可以包含大约4000个session。默认情况下，cache的超时时间是5分钟。超时时间可以用 ssl_session_timeout 来设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">worker_processes auto;</div><div class="line"></div><div class="line">http &#123;</div><div class="line">    ssl_session_cache   shared:SSL:10m;</div><div class="line">    ssl_session_timeout 10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen              443 ssl;</div><div class="line">        server_name         www.example.com;</div><div class="line">        keepalive_timeout   70;</div><div class="line"></div><div class="line">        ssl_certificate     www.example.com.crt;</div><div class="line">        ssl_certificate_key www.example.com.key;</div><div class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SSL证书链"><a href="#SSL证书链" class="headerlink" title="SSL证书链"></a>SSL证书链</h3><p>一些浏览器会报出证书不是由权威机构颁发的，而其他的浏览器则不会有这个问题。这是由于发行机构的证书不是由权威机构的中级证书签发的。这种情况下，发行机构应该提供一个证书链来和服务器证书绑定。在绑定文件中，公钥证书应该在证书链之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat www.example.com.crt bundle.crt &gt; www.example.com.chained.crt</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen              443 ssl;</div><div class="line">    server_name         www.example.com;</div><div class="line">    ssl_certificate     www.example.com.chained.crt;</div><div class="line">    ssl_certificate_key www.example.com.key;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于名称的HTTPS服务"><a href="#基于名称的HTTPS服务" class="headerlink" title="基于名称的HTTPS服务"></a>基于名称的HTTPS服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen          443 ssl;</div><div class="line">    server_name     www.example.com;</div><div class="line">    ssl_certificate www.example.com.crt;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen          443 ssl;</div><div class="line">    server_name     www.example.org;</div><div class="line">    ssl_certificate www.example.org.crt;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于IP：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen          192.168.1.1:443 ssl;</div><div class="line">    server_name     www.example.com;</div><div class="line">    ssl_certificate www.example.com.crt;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen          192.168.1.2:443 ssl;</div><div class="line">    server_name     www.example.org;</div><div class="line">    ssl_certificate www.example.org.crt;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用HTTPS建立TCP连接"><a href="#使用HTTPS建立TCP连接" class="headerlink" title="使用HTTPS建立TCP连接"></a>使用HTTPS建立TCP连接</h2><p>nginx负责https的认证等操作，并把数据返回给后端的服务器处理，后端服务器是http服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    upstream stream_backend &#123;</div><div class="line">         server backend1.example.com:12345;</div><div class="line">         server backend2.example.com:12345;</div><div class="line">         server backend3.example.com:12345;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    server &#123;</div><div class="line">        listen                12345 ssl;</div><div class="line">        proxy_pass            stream_backend;</div><div class="line"> </div><div class="line">        ssl_certificate       /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key   /etc/ssl/certs/server.key;</div><div class="line">        ssl_protocols         SSLv3 TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">        ssl_ciphers           HIGH:!aNULL:!MD5;</div><div class="line">        ssl_session_cache     shared:SSL:20m;</div><div class="line">        ssl_session_timeout   4h;</div><div class="line">        ssl_handshake_timeout 30s;</div><div class="line">		ssl_session_tickets on;</div><div class="line">    …</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>session Ticket 是另一种session缓存。session信息存储在客户端，减少了服务端存储session的压力。当客户端恢复与服务端的交互后，它会提供session并且可以不用再进行握手之类的操作。</p>
<h2 id="为nginx和后端服务器的HTTP连接加密"><a href="#为nginx和后端服务器的HTTP连接加密" class="headerlink" title="为nginx和后端服务器的HTTP连接加密"></a>为nginx和后端服务器的HTTP连接加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    upstream backend.example.com &#123;</div><div class="line">        server backend1.example.com:443;</div><div class="line">        server backend2.example.com:443;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      80;</div><div class="line">        server_name www.example.com;</div><div class="line">        ...</div><div class="line"></div><div class="line">        location /upstream &#123;</div><div class="line">            proxy_pass                    https://backend.example.com;</div><div class="line">            proxy_ssl_certificate         /etc/nginx/client.pem;</div><div class="line">            proxy_ssl_certificate_key     /etc/nginx/client.key</div><div class="line">            proxy_ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">            proxy_ssl_ciphers             HIGH:!aNULL:!MD5;</div><div class="line">            proxy_ssl_trusted_certificate /etc/nginx/trusted_ca_cert.crt;</div><div class="line"></div><div class="line">            proxy_ssl_verify        on;</div><div class="line">            proxy_ssl_verify_depth  2;</div><div class="line">            proxy_ssl_session_reuse on;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend1.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend2.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="为nginx和后端服务器的TCP连接加密"><a href="#为nginx和后端服务器的TCP连接加密" class="headerlink" title="为nginx和后端服务器的TCP连接加密"></a>为nginx和后端服务器的TCP连接加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    upstream backend.example.com &#123;</div><div class="line">        server backend1.example.com:443;</div><div class="line">        server backend2.example.com:443;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      80;</div><div class="line">        server_name www.example.com;</div><div class="line">        ...</div><div class="line"></div><div class="line">        location /upstream &#123;</div><div class="line">            proxy_pass                    https://backend.example.com;</div><div class="line">            proxy_ssl_certificate         /etc/nginx/client.pem;</div><div class="line">            proxy_ssl_certificate_key     /etc/nginx/client.key</div><div class="line">            proxy_ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">            proxy_ssl_ciphers             HIGH:!aNULL:!MD5;</div><div class="line">            proxy_ssl_trusted_certificate /etc/nginx/trusted_ca_cert.crt;</div><div class="line"></div><div class="line">            proxy_ssl_verify        on;</div><div class="line">            proxy_ssl_verify_depth  2;</div><div class="line">            proxy_ssl_session_reuse on;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend1.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend2.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通过HTTPS传递Web内容&quot;&gt;&lt;a href=&quot;#通过HTTPS传递Web内容&quot; class=&quot;headerlink&quot; title=&quot;通过HTTPS传递Web内容&quot;&gt;&lt;/a&gt;通过HTTPS传递Web内容&lt;/h2&gt;&lt;h3 id=&quot;配置一个HTTPS服务&quot;&gt;&lt;a h
    
    </summary>
    
    
      <category term="Nginx" scheme="http://chenpeng89.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记：三、基本功能</title>
    <link href="http://chenpeng89.github.io/2016/07/11/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/"/>
    <id>http://chenpeng89.github.io/2016/07/11/Nginx学习笔记：三、基本功能/</id>
    <published>2016-07-11T07:59:00.000Z</published>
    <updated>2016-09-20T03:12:17.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><h3 id="设置虚拟服务器"><a href="#设置虚拟服务器" class="headerlink" title="设置虚拟服务器"></a>设置虚拟服务器</h3><p>nginx配置文件中至少需要一个定义了虚拟服务器的server块。当nginx处理请求时，它会首先选择虚拟服务器来处理请求。<br>虚拟服务器定义在http上下文的server块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        # Server configuration</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以在http上下文中定义多个server块。<br>server块通常包含一个listen指令来监听指定的ip的端口。支持ipv4/ipv6，ipv6的地址需要用（）包裹起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 127.0.0.1:8080;</div><div class="line">    # The rest of server configuration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果省略端口号，则使用标准端口号。如果省略ip，那么服务器将监听所有地址。如果省略listen指令，那么标准的端口号是80/tcp，默认的端口号是8000/tcp这取决于root的权限。</p>
<p>server_name 参数用来指定接受访问的host头中的相应参数。它的值可以是一个通配符。如果没有匹配的，那么将路由到默认的服务器上来处理。</p>
<h3 id="配置location"><a href="#配置location" class="headerlink" title="配置location"></a>配置location</h3><p>nginx可以将请求路由到不同的代理或者服务器上，基于请求的uri。这些都是依靠定义在server块中的localtion块来决定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    root html;</div><div class="line">    index  index.html  index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有两种类型的参数：前缀字符串和正则表达式。对于一个请求URI，他必须满足匹配前缀字符串。</p>
<p>正则表达式前面增加 ~ 表示区分大小写，~* 表示不区分大小写。下面的例子匹配所有带有.html或者.htm的URI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location ~ \.html? &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>为了找到最匹配URI的location，nginx会首先搜索前缀字符串，然后再搜索正则表达式。</strong></p>
<p>nginx的处理逻辑为：</p>
<ol>
<li>尝试匹配所有前缀字符串。</li>
<li>= 修饰符定义了一个URI和前缀字符串的精确匹配。如果发现精确匹配,搜索停止。</li>
<li>如果有^~修饰符，则最先考虑最长前缀字符串匹配,正则表达式不检查。</li>
<li>存储最长前缀匹配字符串。</li>
<li>尝试匹配正则表达式。</li>
<li>从第一个匹配的正则表达式跳出递归，并使用相应的location。</li>
<li>如果没有匹配的正则表达式，使用存储的最长匹配的前缀表达式（第4步）的location。</li>
</ol>
<p>location块中包含如何处理的逻辑，要么转到一个静态文件，要么将请求转给一个代理服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    location /images/ &#123;</div><div class="line">        root /data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://www.example.com;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>nginx允许在配置文件中使用自定义的变量。<br><code>set $variable value</code><br><code>map string $variable { ... }</code><br><code>geo [$address] $variable { ... }</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line"> geo $arg_boy $ttlsa_com &#123;</div><div class="line">        default 0;</div><div class="line">        127.0.0.1/24 24;</div><div class="line">        127.0.0.1/32 32;</div><div class="line">        8.8.8.8 2;</div><div class="line">&#125;</div><div class="line"> server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  test.ttlsa.com;</div><div class="line"> </div><div class="line">        location /hello &#123;</div><div class="line"> default_type text/plain;</div><div class="line"> echo $ttlsa_com;</div><div class="line"> echo $arg_boy;</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"># curl 127.0.0.1:8080/hello?boy=127.0.0.1</div><div class="line">32</div><div class="line">127.0.0.1</div><div class="line"># curl 127.0.0.1:8080/hello?boy=127.0.0.12</div><div class="line">24</div><div class="line">127.0.0.12</div></pre></td></tr></table></figure>
<h3 id="返回指定状态码"><a href="#返回指定状态码" class="headerlink" title="返回指定状态码"></a>返回指定状态码</h3><p>一些网站URI需要立即返回指定的错误代码或重定向代码，例如，如果一个页面被暂时或永久的移除，那么，最简单的方法是直接返回相应的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /wrong/url &#123;</div><div class="line">    return 404;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>return 的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">return code [text];</div><div class="line">return code URL;</div><div class="line">return URL;</div></pre></td></tr></table></figure></p>
<p>return 指令可以存在于location和server块中。</p>
<h3 id="重写URI请求"><a href="#重写URI请求" class="headerlink" title="重写URI请求"></a>重写URI请求</h3><p>一个请求的URI可以在处理请求过程中被重写多次，它包括一个可选的和两个必须的参数。第一个必须的参数是请求URI必须满足的正则表达式。第二个参数是用来替换请求URI的URI。可选的参数是一个标志位，它能停止进一步的重写处理或者发送重定向（301或302）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /users/ &#123;</div><div class="line">    rewrite ^/users/(.*)$ /show?user=$1 break;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>rewrite指令可以存在于server和location块中。在server块中，如果server的上下文被选中，那么server块中的rewrite只会执行一次。</p>
<p>rewrite指令用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rewrite regex replacement [flag];</div></pre></td></tr></table></figure></p>
<p>flag 有以下可选值：<br>last: 重新请求搜索是否还有匹配的locaton。<br>break: 不再搜索是否还有匹配的location。<br>redirect：返回一个暂时的重定向代码 ， 302，使用一个不以”<a href="http://&quot;或&quot;https://&quot;开头的代替的字符串。" target="_blank" rel="external">http://&quot;或&quot;https://&quot;开头的代替的字符串。</a><br>permanent： 返回一个永久的重定向代码，301.</p>
<h3 id="重写HTTP返回"><a href="#重写HTTP返回" class="headerlink" title="重写HTTP返回"></a>重写HTTP返回</h3><p>有时候你需要重写或者修改HTTP返回中的内容，把一个字符串替换成其它的。那么，你需要使用sub_filter指令来定义重写。这个指令支持变量和链操作来使复杂的操作变得简单。<br>sub_filter的替换匹配是不区分大小写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  www.github.com;</div><div class="line"> </div><div class="line">    root /data/site/www.github.com;    </div><div class="line"> </div><div class="line">    location / &#123;</div><div class="line">        sub_filter  github &apos;GIT&apos;;</div><div class="line">        sub_filter_types text/html;</div><div class="line">        sub_filter_once on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子将返回数据中的github替换为GIT，然后由于sub_filter_once on ， 所以只替换了一次。结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># curl www.github.com/2013/10/20131001_sub1.html           </div><div class="line">welcome to GIT!</div><div class="line">github TEAM!</div></pre></td></tr></table></figure></p>
<p>sub_filter 可以存在于 http, server, location 块。</p>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>使用error_page 指令，可以为特定的错误码自定义错误页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_page 404 /404.html;</div></pre></td></tr></table></figure></p>
<p>下面的例子中，将404转换为301，并重定向到http:/example.com/new/path.html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /old/path.html &#123;</div><div class="line">    error_page 404 =301 http:/example.com/new/path.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h2><h3 id="Root目录和索引文件"><a href="#Root目录和索引文件" class="headerlink" title="Root目录和索引文件"></a>Root目录和索引文件</h3><p>root指令制定了将要去搜索文件的根目录。为了获得文件路径，nginx为请求的URI添加了指定的root路径。root指令可以在http、server和location块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    root /www/data;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /images/ &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location ~ \.(mp3|mp4) &#123;</div><div class="line">        root /www/media;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子中，如果URI以/images/开始，那么，搜索的路径为/www/data/images/目录。如果URI以.mp3或者.mp4结尾，那么搜索的路径为/www/media/。</p>
<p>如果请求是以/结尾，那么，nginx将其认为是请求目录结构并查找目录里面的索引文件。index命令定义了索引文件名（默认名称为index.html）。接着上面的例子，如果请求是 /images/some/path/ ， nginx将传送文件/www/data/images/some/path/index.html，如果存在的话。如果不存在，nginx返回404。为了让NGINX返回一个自动生成的目录清单,加入autoindex指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /images/ &#123;</div><div class="line">    autoindex on;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以列举不只一个文件名在index指令下。nginx以指定的顺序搜索文件并返回第一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    index index.$geo.html index.htm index.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的$geo变量是一个自定义的geo。它的值取决于客户端的ip地址。</p>
<p>autoindex_exact_size on | off 表示是否显示大小。<br>autoindex_format html | xml | json | jsonp 输出格式<br>autoindex_localtime on | off  显示本地时间或UTC</p>
<h3 id="其它的命令"><a href="#其它的命令" class="headerlink" title="其它的命令"></a>其它的命令</h3><p>try_files 用来检查指定的文件或者目录是否存在，并设置一个重定向或者返回一个指定的状态码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    root /www/data;</div><div class="line"></div><div class="line">    location /images/ &#123;</div><div class="line">        try_files $uri /images/default.gif;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后一个参数可以是状态码或者位置。在下面的例子中，如果try_files的参数中的文件或目录不存在，则返回404。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    try_files $uri $uri/ $uri.html =404;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在下面的例子中，如果原始的URI和URI后面加上/的目录均不存在，那么请求会被重定向到一个代理服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    try_files $uri $uri/ @backend;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location @backend &#123;</div><div class="line">    proxy_pass http://backend.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提高nginx内容服务速度"><a href="#提高nginx内容服务速度" class="headerlink" title="提高nginx内容服务速度"></a>提高nginx内容服务速度</h3><p>加载速度是重要的考虑因素。做一些小幅的优化配置可能会大幅提高效率甚至达到最佳性能。</p>
<ul>
<li><p>开启sendfile<br>默认情况下，nginx自己控制文件传输，并在发送前把它拷贝到buffer中。使用sendfile命令可以减少拷贝到buffer的步骤，并且直接将一个文件描述符拷贝到另一个。另外,防止一个快速连接完全占用worker进程,可以在sendfile()调用sendfile_max_chunk指令限制传输的数据量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3 &#123;</div><div class="line">    sendfile           on;</div><div class="line">    sendfile_max_chunk 1m;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>开启tcp_nopush<br>配合sendfile一起使用tcp_nopush。一般情况下，在tcp交互的过程中，当应用程序接收到数据包后马上传送出去，不等待，而tcp_cork选项是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞，已经是默认了,tcp_nopush = on 会设置调用tcp_cork方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3 &#123;</div><div class="line">    sendfile   on;</div><div class="line">    tcp_nopush on;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>开启tcp_nodelay<br>与tcp_nopush 是互斥的，有数据的话会立即将数据包发送出去，有可能会造成网络拥堵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3  &#123;</div><div class="line">    tcp_nodelay       on;</div><div class="line">    keepalive_timeout 65;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>优化Backlog Queue<br>nginx处理连接请求也是一个非常重要的优化点。一般情况下，当一个连接建立后，它会被放入listen socket的listen队列。在普通负载下，这是一个小的甚至不存在的队列。但是高负载时，队列会显著增长，这可能导致连接断开或者高延迟。<br><strong>检查listen queue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -lan</div></pre></td></tr></table></figure>
</li>
</ul>
<p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Current listen queue sizes (qlen/incqlen/maxqlen)</div><div class="line">Listen         Local Address         </div><div class="line">0/0/128        *.12345            </div><div class="line">10/0/128        *.80       </div><div class="line">0/0/128        *.8080</div></pre></td></tr></table></figure></p>
<p>说明有10个在80端口的连接未被处理。<br><strong>设置OS</strong><br>设置 net.core.somaxconn 来增大OS的负载能力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vi   /etc/sysctl.conf</div><div class="line">net.core.somaxconn = 4096</div></pre></td></tr></table></figure></p>
<p><strong>设置nginx</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80 backlog 4096;</div><div class="line">    # The rest of server configuration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="发送请求到代理服务器"><a href="#发送请求到代理服务器" class="headerlink" title="发送请求到代理服务器"></a>发送请求到代理服务器</h3><p>当使用nginx代理时，会发送请求到代理服务器，获取相应，然后返回给客户端。它可以代理HTTP请求也可以代理非HTTP请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_pass http://www.example.com/link/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="发送请求头到代理服务器"><a href="#发送请求头到代理服务器" class="headerlink" title="发送请求头到代理服务器"></a>发送请求头到代理服务器</h3><p>默认情况下，nginx会重新定义请求头中的两个域，Host和Connection，Host被设置为$proxy_host变量，Connection被设置为 close。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>防止某个域传递到代理服务器，可以将其设置为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_set_header Accept-Encoding &quot;&quot;;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="设置Buffer"><a href="#设置Buffer" class="headerlink" title="设置Buffer"></a>设置Buffer</h3><p>一般情况下，nginx缓冲代理服务器的相应，直到收到整个相应信息才发送给客户端。缓冲机制能够优化慢客户端，因为如果对于慢客户端nginx同步响应，那么会浪费代理服务器时间。<br><strong>proxy_buffering</strong>，该指令设置缓冲区的大小和数量,从被代理的后端服务器取得的响应内容,会放置到这里. 默认情况下,一个缓冲区的大小等于内存页面大小,可能是4K也可能是8K,这取决于平台。proxy_buffers 8  4k/8k。<br><strong>proxy_buffer_size</strong>，该指令设置缓冲区大小,从代理后端服务器取得的第一部分的响应内容,会放到这里.小的响应header通常位于这部分响应内容里边.默认来说,该缓冲区大小等于指令 proxy_buffers所设置的;但是,你可以把它设置得更小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_buffers 16 4k;</div><div class="line">    proxy_buffer_size 2k;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果关闭buffer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_buffering off;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="绑定出口IP"><a href="#绑定出口IP" class="headerlink" title="绑定出口IP"></a>绑定出口IP</h3><p>如果你的代理服务器有多个网络接口，有时需要选择其中一个进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">location /app1/ &#123;</div><div class="line">    proxy_bind 127.0.0.1;</div><div class="line">    proxy_pass http://example.com/app1/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /app2/ &#123;</div><div class="line">    proxy_bind 127.0.0.2;</div><div class="line">    proxy_pass http://example.com/app2/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /app3/ &#123;</div><div class="line">    proxy_bind $server_addr;</div><div class="line">    proxy_pass http://example.com/app3/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h2><p>亚索形影数据对于减小传输数据是非常重要的。然而，在运行时进行压缩还有可能对系统有负面影响。nginx在发送相应数据前进行压缩，但是不会对已经压缩过的数据进行二次压缩（例如，对于代理服务器的）。</p>
<h3 id="开启压缩"><a href="#开启压缩" class="headerlink" title="开启压缩"></a>开启压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip on;</div></pre></td></tr></table></figure>
<p>通常情况下，nginx仅对MIME类型为text/html的相应进行压缩。为了添加压缩的类型，可以使用gzip_types命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_types text/plain application/xml;</div></pre></td></tr></table></figure></p>
<p>指定压缩响应的最小长度，使用gzip_min_length指令。默认是20bytes。（这里设置为1000）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_min_length 1000;</div></pre></td></tr></table></figure></p>
<p>一般情况下，nginx不会压缩代理服务器的请求响应。该请求来自代理服务器的事实是由Via头字段的请求中的存在来确定。使用gzip_proxied指令来配置这些响应的压缩。这个指令有很多参数，来确定哪种代理请求nginx需要压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_proxied no-cache no-store private expired auth;</div></pre></td></tr></table></figure></p>
<p>一个完整的例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    gzip on;</div><div class="line">    gzip_types      text/plain application/xml;</div><div class="line">    gzip_proxied    no-cache no-store private expired auth;</div><div class="line">    gzip_min_length 1000;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="开启解压缩"><a href="#开启解压缩" class="headerlink" title="开启解压缩"></a>开启解压缩</h3><p>一些客户端不支持gzip编码算法。同时，它又想要存储压缩数据或者压缩相应数据并存入缓存。为了成功发送到客户端，nginx支持在发送到最终客户端时解压缩数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /storage/ &#123;</div><div class="line">    gunzip on;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="发送压缩文件"><a href="#发送压缩文件" class="headerlink" title="发送压缩文件"></a>发送压缩文件</h3><p>使用gzip_static 命令可以发送一个压缩版本的文件到客户端，若要使用它需要在编译的时候把gzip_static模块编译进去：<br><code>./configure --with-http_gzip_static_module</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    gzip_static on;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当请求 /path/to/file，nginx会查找并发送/path/to/file.gz。如果文件不存在或者客户端不支持gzip，nginx会发送未压缩版本。<br>注意，gzip_static指令不支持实时压缩。它只是使用压缩工具预先压缩文件。要压缩在运行时的内容（不仅是静态内容），使用gzip的指令。</p>
<h2 id="页面内容缓存"><a href="#页面内容缓存" class="headerlink" title="页面内容缓存"></a>页面内容缓存</h2><p>nginx支持缓存，当开启缓存后，nginx缓存从代理服务器返回的数据，并将其缓存到硬盘上，当有请求过来时，先去缓存查找响应。</p>
<h3 id="开启响应缓存"><a href="#开启响应缓存" class="headerlink" title="开启响应缓存"></a>开启响应缓存</h3><p>将 proxy_cache_path 放到http块中来开启缓存。第一个参数是存放缓存文件的路径。keys_zone定义了用于存储缓存条目元数据的共享存储空间名称和大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache keys_zone=one:10m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将proxy_cache放入想进行缓存的协议类型、server块或者location块中。并指定proxy_cache_path中的key_zone。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache keys_zone=one:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        proxy_cache one;</div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://localhost:8000;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，key_zone定义的大小并不限制缓存相应数据的总量。缓存的响应数据本身存储为元数据的一个备份，存在指定的file上。为了限制缓存的数量，可以使用proxy_cache_path的max_size参数，缓存数量可以暂时超过max_size。</p>
<h3 id="控制缓存"><a href="#控制缓存" class="headerlink" title="控制缓存"></a>控制缓存</h3><p>缓存管理器会定期检查缓存的状态。如果缓存大小超过proxy_cache_path中 max_size参数设定的限制,缓存管理器删除最近最少访问的数据。正如前面提到的,缓存数据的数量可以暂时超过限制缓存管理器激活的时间期间。<br>缓存加载器仅会在nginx启动后启动一次。它会将之前缓存的数据加载进来。加载一次缓存可能会消耗大量资源，影响nginx启动后几分钟内的性能。下面有proxy_cacahe_path的几个参数来避免这一情况：</p>
<ul>
<li>loader_threshold ： 加载时间上限，单位是毫秒，默认为200毫秒。</li>
<li>loader_files： 一次迭代的最多条目数，默认是100。</li>
<li>loader_sleeps ： 迭代的间隔，单位是毫秒，默认50。</li>
</ul>
<p><code>proxy_cache_path /data/nginx/cache keys_zone=one:10m loader_threshold=300 loader_files=200;</code></p>
<h3 id="指定对哪个请求进行缓存"><a href="#指定对哪个请求进行缓存" class="headerlink" title="指定对哪个请求进行缓存"></a>指定对哪个请求进行缓存</h3><p>一般情况下，nginx缓存http的get和head方法响应的数据。nginx将请求字符串作为请求的key。如果缓存中存在和请求相同的key，nginx会直接用缓存来响应。可以在http，server，location的上下文中控制哪些进行缓存。</p>
<p>为了改变请求的单词来计算key，可以使用proxy_cache_key:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_key &quot;$host$request_uri$cookie_user&quot;;</div></pre></td></tr></table></figure></p>
<p>定义在必须在请求指定的最低次数以后，响应才会被缓存起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_min_uses 5;</div></pre></td></tr></table></figure></p>
<p>缓存除了GET和HEAD的其他请求，get和head也需要被列举出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_methods GET HEAD POST;</div></pre></td></tr></table></figure></p>
<h3 id="限制或绕过缓存"><a href="#限制或绕过缓存" class="headerlink" title="限制或绕过缓存"></a>限制或绕过缓存</h3><p>默认情况下，响应数据会一直在缓存中。它们只有在缓存超过最大值时，并且它们是最少命中的，才会被淘汰。nginx可以设置淘汰策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_cache_valid 200 302 10m;</div><div class="line">proxy_cache_valid 404      1m;</div></pre></td></tr></table></figure></p>
<p>上面的例子中，返回200或者302都被认为是在10分钟以内有效的。返货404在1分钟以内也是有效的。也可以使用<code>any</code>来设置第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_valid any 5m;</div></pre></td></tr></table></figure></p>
<p>可以定义proxy_cache_bypass指令来决定是否使用cache响应请求。每个参数定义了一个条件并且由变量组成。如果至少有一个参数为空并且不等于0，nginx不会从cache查找响应，会直接去后端服务器请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;</div></pre></td></tr></table></figure></p>
<p><code>proxy_cache_bypass string ...;</code></p>
<p>控制哪些请求不进行缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_no_cache $http_pragma $http_authorization;</div></pre></td></tr></table></figure></p>
<h3 id="从缓存中清除内容"><a href="#从缓存中清除内容" class="headerlink" title="从缓存中清除内容"></a>从缓存中清除内容</h3><p>NGINX可以从缓存中删除过期的缓存文件。这是非常必要的,删除过期的缓存内容,防止同时提供新老版本的web页面。清除缓存时，nginx会收到一个特别的“清除”请求包含一个自定义HTTP头,或“清除”的HTTP方法。</p>
<ul>
<li>配置缓存清除<br>下面配置一个清除的HTTP方法并删除匹配的URL。<br>在http块中，新建一个变量，如下面的 $purge_method ， 它依赖于$request_method变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">        PURGE 1;</div><div class="line">        default 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在location块中已经定义了cache，在 proxy_cache_purge 指令中，指定了会被清除cache的条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen      80;</div><div class="line">    server_name www.example.com;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass  https://localhost:8002;</div><div class="line">        proxy_cache mycache;</div><div class="line"></div><div class="line">        proxy_cache_purge $purge_method;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当 $request_method 为PURGE，则清除。否则不清除。</p>
<ul>
<li>发送清除指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -X PURGE -D – &quot;https://www.example.com/*&quot;</div><div class="line">HTTP/1.1 204 No Content</div><div class="line">Server: nginx/1.5.7</div><div class="line">Date: Sat, 01 Dec 2015 16:33:04 GMT</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上例中，指定的URI中的缓存文件并不删除，它们还会继续存储在磁盘上，直到nginx来操作处理。</p>
<ul>
<li><p>限制访问清除指令<br>比较推荐的是通过设置IP白名单来限制访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">geo $purge_allowed &#123;</div><div class="line">   default         0;  # deny from other</div><div class="line">   10.0.0.1        1;  # allow from localhost</div><div class="line">   192.168.0.0/24  1;  # allow from 10.0.0.0/24</div><div class="line">&#125;</div><div class="line"></div><div class="line">map $request_method $purge_method &#123;</div><div class="line">   PURGE   $purge_allowed;</div><div class="line">   default 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>完全删除cache文件<br><code>proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=mycache:10m purger=on;</code><br>在 proxy_cache_path 加上 purger=on参数。</p>
</li>
<li>完整的例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=mycache:10m purger=on;</div><div class="line"></div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">        PURGE 1;</div><div class="line">        default 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      80;</div><div class="line">        server_name www.example.com;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass        https://localhost:8002;</div><div class="line">            proxy_cache       mycache;</div><div class="line">            proxy_cache_purge $purge_method;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    geo $purge_allowed &#123;</div><div class="line">       default         0;</div><div class="line">       10.0.0.1        1;</div><div class="line">       192.168.0.0/24  1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">       PURGE   $purge_allowed;</div><div class="line">       default 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Byte范围的缓存"><a href="#Byte范围的缓存" class="headerlink" title="Byte范围的缓存"></a>Byte范围的缓存</h3><p>有时候，将数据放入缓存中是一个很费时的操作，特别是大文件。当第一次请求开始下载一个大文件时，下一次请求必须等待整个文件下载并放入缓存后才能被服务。<br>nginx可以使用cache slice module 来处理。文件被分成较小的“片”。每个请求范围选择特定的片,如果这个范围没有被缓存,那么将会把它放到缓存中。然后其它所有请求这个片数据的请求都会被这个缓存响应。<br>开启范围级别的缓存：</p>
<ol>
<li>为nginx编译进slice模块。</li>
<li><p>指定每个片的大小。片大小应足以使切片快速下载。设置太小可能会导致过度的内存使用和大量的文件描述符,过大的值可能会导致延迟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    slice  1m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在cache key中加入$slice_range<br><code>proxy_cache_key $uri$is_args$args$slice_range;</code></p>
</li>
<li>开启响应的206代码<br><code>proxy_cache_valid 200 206 1h;</code></li>
<li>在发往代理服务器的HTTP头的Range里面加入$slice_range。<br><code>proxy_set_header  Range $slice_range;</code></li>
<li>综合样例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    slice             1m;</div><div class="line">    proxy_cache       cache;</div><div class="line">    proxy_cache_key   $uri$is_args$args$slice_range;</div><div class="line">    proxy_set_header  Range $slice_range;</div><div class="line">    proxy_cache_valid 200 206 1h;</div><div class="line">    proxy_pass        http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Web服务&quot;&gt;&lt;a href=&quot;#Web服务&quot; class=&quot;headerlink&quot; title=&quot;Web服务&quot;&gt;&lt;/a&gt;Web服务&lt;/h2&gt;&lt;h3 id=&quot;设置虚拟服务器&quot;&gt;&lt;a href=&quot;#设置虚拟服务器&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
    
      <category term="Nginx" scheme="http://chenpeng89.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记：二、进程和运行时</title>
    <link href="http://chenpeng89.github.io/2016/07/11/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    <id>http://chenpeng89.github.io/2016/07/11/Nginx学习笔记：二、进程和运行时/</id>
    <published>2016-07-11T03:10:31.000Z</published>
    <updated>2016-09-20T03:12:17.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>nginx包含一个master进程和一个或多个worker进程。<br>master进程的主要职责是读取和使用配置文件，同时管理worker进程。<br>worker进程用来处理用户请求。Nginx依赖OS的机制来有效的分发请求给worker进程。worker进程的数量定义位于nginx.conf配置文件上，它可以是固定的数目也可以自适应cpu的核心数。<br>定义worker进程的数母，主要参考几个方面，cpu的核心数、存储数据的硬盘数以及负载模式。当不清楚使用哪种策略时，设定为自适应cpu核心数(“auto”)是一个好的方法。</p>
<h2 id="操作Nginx"><a href="#操作Nginx" class="headerlink" title="操作Nginx"></a>操作Nginx</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>重载配置，你可以停止并重启nginx或者发送一个信号给master进程。使用-s发送信号给运行中的nginx。<br><code>nginx -s signal</code><br>signal的值可以为<br>quit<br>reload<br>reopen<br>stop</p>
<p>可以直接用kill命令来直接放松信号到master进程。master进程的ID默认情况下存在 /usr/local/nginx/logs 或者 /var/run 的nginx.pid 文件中。可以在nginx.conf中设置。<br>有两种方式来通过这些信号去控制 Nginx，第一是通过 kill – XXX <pid> 来控制 Nginx，其中 XXX 就是上表中列出的信号名。如果系统中只有一个 Nginx 进程，那也可以通过 killall 命令来完成，例如运行 killall – s HUP nginxPID 来让 Nginx 重新加载配置。<br>master进程有如下信号：<br>TERM, INT     快速关闭程序，中止当前正在处理的请求<br>QUIT     处理完当前请求后，关闭程序<br>HUP     重新加载配置，并开启新的工作进程，关闭就的进程，此操作不会中断请求<br>USR1     重新打开日志文件，用于切换日志，例如每天生成一个新的日志文件<br>USR2     平滑升级可执行程序<br>WINCH     从容关闭工作进程 </pid></p>
<p>单独的worker进程也可以通过信号量来控制，虽然并不是必须的。<br>TERM, INT    快速关闭进程<br>QUIT    处理完当前请求后，关闭进程<br>USR1    重新打开日志文件，用于切换日志，例如每天生成一个新的日志文件<br>WINCH    调试异常终止（需要启用debug_points ）</p>
<h3 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h3><p>为了nginx能够重读配置文件，HUP信号将发送给master进程，master进程首先检查信号的有效性，然后使用新的配置，打开日志文件和心得监听socket。如果这步失败了，那么将回滚并使用旧的配置。如果成功了，会开启新的worker进程，并发送信息给旧的worker进程让它们优雅停机。旧的进程关闭监听socket并继续服务旧的客户端，当所有客户端请求被服务后，旧的worker进程会停机。</p>
<h3 id="分割日志文件"><a href="#分割日志文件" class="headerlink" title="分割日志文件"></a>分割日志文件</h3><p>为了分割日志文件，首先，它们需要被重命名。在那之后，需要向master进程发送USR1信号。master进程会重新打开所有当前打开的日志文件，并将它们分配给当前worker进程正在运行的无权限的用户作为所有者。在成功重新打开日志文件后，master进程会关闭所有打开的文件并发送消息给worker进程来重新打开文件。worker进程也需要立刻打开新文件并关闭旧文件。其结果是，旧文件可以立即适用于后处理，例如压缩。</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>为了升级服务，需要使用新的可执行文件替换旧的。在USR2信号发送到master进程后，master进程首先会将pid文件名加上一个.oldbin后缀。/usr/local/nginx/logs/nginx.pid.oldbin。然后启动一个新的可执行文件来启动新的worker进程。</p>
<p>之后，所有的worker进程（新的和旧的）都继续接收请求，如果WINCH信号发送到了，master进程，那么将会通知worker进程去优雅停机。</p>
<p>经历一段时间后，只有新的worker进程可以处理请求。</p>
<p>需要注意的是，旧的master进程不会关闭监听socket，并且如果需要，它还可以重新启动。如果由于一些原因，新的可执行文件不能使用了，那么会出现以下两种情况中的一种：</p>
<ul>
<li>发送HUP信号到旧的master进程，旧的master进程不重新读配置文件，但会启动一个新的worker进程。在那之后，发送QUIT到新的master进程，所有新的进程将优雅停止。</li>
<li>发送 TERM 信号到新的master进程。然后新的master进程会发送信息到它的worker进程，告诉他们立即停止（如果有新的进程因为某些原因未停止，那么会发送KILL信号来强制停止）。当新的master进程停止后，旧的master进程自动会启动新的worker进程。</li>
</ul>
<p>如果新的master进程退出了，那么旧的，master进程会抛弃带有.oldbin的文件。</p>
<p>如果更新成功，那么旧的master进程会被发送QUIT信号，然后只有新的进程存活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;nginx包含一个master进程和一个或多个worker进程。&lt;br&gt;master进程的主要职责是读取和使用配置文件，同时管理worker
    
    </summary>
    
    
      <category term="Nginx" scheme="http://chenpeng89.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记: 一、入门</title>
    <link href="http://chenpeng89.github.io/2016/07/11/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E3%80%81%E5%85%A5%E9%97%A8/"/>
    <id>http://chenpeng89.github.io/2016/07/11/Nginx学习笔记：一、入门/</id>
    <published>2016-07-11T02:32:41.000Z</published>
    <updated>2016-09-20T03:12:17.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装nginx需要先安装c++ 编译器、pcre 、zlib以及openssl。</p>
<ol>
<li>安装c++ 编译器<br><code>yum install -y gcc gcc-c++</code></li>
<li><p>安装pcre</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz</div><div class="line">$ tar -zxf pcre-8.39.tar.gz</div><div class="line">$ cd pcre-8.39</div><div class="line">$ ./configure</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>安装zlib</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ wget http://zlib.net/zlib-1.2.8.tar.gz</div><div class="line">$ tar -zxf zlib-1.2.8.tar.gz</div><div class="line">$ cd zlib-1.2.8</div><div class="line">$ ./configure</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>安装openssl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ wget http://www.openssl.org/source/openssl-1.0.2f.tar.gz</div><div class="line">$ tar -zxf openssl-1.0.2f.tar.gz</div><div class="line">$ cd openssl-1.0.2f</div><div class="line">$ ./configure  --prefix=/usr/local/openssl</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>安装nginx<br>先下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ wget http://nginx.org/download/nginx-1.11.2.tar.gz</div><div class="line">$ tar zxf nginx-1.11.2.tar.gz</div><div class="line">$ cd nginx-1.11.2</div></pre></td></tr></table></figure>
</li>
</ol>
<p>编译安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./configure --with-pcre=../pcre-8.39 --with-zlib=../zlib-1.28 --with-openssl=../openssl</div><div class="line">$ make &amp; make install</div></pre></td></tr></table></figure></p>
<ol>
<li>启动nginx <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd /usr/local/nginx/sbin</div><div class="line">$ ./nginx</div></pre></td></tr></table></figure>
</li>
</ol>
<p>验证是否启动成功了<br><code>curl -I 127.0.0.1</code><br><img src="http://i.imgur.com/HbB3BQh.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装nginx需要先安装c++ 编译器、pcre 、zlib以及openssl。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装c++ 编译器&lt;br&gt;&lt;co
    
    </summary>
    
    
      <category term="Nginx" scheme="http://chenpeng89.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化策略</title>
    <link href="http://chenpeng89.github.io/2016/07/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>http://chenpeng89.github.io/2016/07/07/Redis持久化策略/</id>
    <published>2016-07-07T02:24:32.000Z</published>
    <updated>2016-09-20T07:32:50.250Z</updated>
    
    <content type="html"><![CDATA[<p>Redis提供了两种持久化策略，一种是快照方式（point-in-time snapshot），另一种是只追加文件（append-only file）方式。</p>
<h2 id="快照方式"><a href="#快照方式" class="headerlink" title="快照方式"></a>快照方式</h2><p>快照方式会在某个时刻将所有数据都写入到硬盘中。用户可以根据Redis的配置命令<code>config get dir</code>和<code>config get dbfilename</code>来知道快照文件写入的路径和文件名。</p>
<p>创建快照的方式有以下几种：</p>
<ul>
<li>客户端发送  <code>bgsave</code> 命令（windows不支持此命令），Redis会调用fork创建一个进程来进行备份操作，父进程继续接收执行命令。</li>
<li>客户端发送  <code>save</code> 命令，Redis会进行备份操作，在备份完成之前，不相应其它命令请求。一般不使用此命令，只有在没有足够内存去执行<code>bgsave</code>情况下才使用此命令。</li>
<li>在配置中设置了 <code>save</code> 选项，比如设置为 <code>save 60 10000</code> ， 当60s内有10000次写入则触发bgsave。</li>
<li>当使用 <code>shutdown</code> 关闭Redis时，会先执行<code>save</code>命令，并阻塞所有客户端。</li>
<li>当Redis连接另一Redis，并向对方发送<code>sync</code>开始一次复制命令，如果redis没有正在执行<code>bgsave</code> 或 没有刚刚执行完 <code>bgsave</code>，那么会执行一次<code>bgsave</code>。</li>
</ul>
<p>缺点：<br>如果在进行下一次备份的时候服务器crash了，那么将丢失上次备份到现在的所有记录。</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>aof会将被执行的写命令写到aof文件的末尾，每次恢复的时候直接执行aof文件中的写命令就可以了。用户可以在<code>appendonly</code>配置中打开aof。<code>appendfsync</code>可以控制aof的频率。<code>always</code>是每次写命令都要同步到硬盘，这样会严重降低redis的速度。<code>everysec</code>每秒进行一次同步，显式将多个写命令同步到硬盘，一般使用这个选项。<code>no</code>由OS来确定何时同步。</p>
<p>由于aof文件会越来越大，一是会占用过大的硬盘空间，二是数据恢复会需要很长时间。为了解决这个问题，redis提供了一个<code>bgrewriteaof</code>命令创建一个子进程来移除aof的冗余命令并重写aof文件。redis还提供了<code>auto-aof-rewrite-percentage</code>和<code>auto-aof-rewrite-min-size</code>来自动执行<code>bgrewriteaof</code>。当设置了 <code>auto-aof-rewrite-percentage 100</code>和<code>auto-aof-rewrite-min-size 64mb</code>时，并启动了aof，当aof文件大于64mb 并且aof文件比上一次重写大了至少1倍时，redis将会执行<code>bgrewriteaof</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis提供了两种持久化策略，一种是快照方式（point-in-time snapshot），另一种是只追加文件（append-only file）方式。&lt;/p&gt;
&lt;h2 id=&quot;快照方式&quot;&gt;&lt;a href=&quot;#快照方式&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
    
      <category term="Redis" scheme="http://chenpeng89.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Solr学习笔记：二、Document、Field和Schema的设计</title>
    <link href="http://chenpeng89.github.io/2016/06/29/Solr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E3%80%81%E6%96%87%E6%A1%A3%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%91%98%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://chenpeng89.github.io/2016/06/29/Solr学习笔记：二、文档、变量和摘要的设计/</id>
    <published>2016-06-29T01:28:58.000Z</published>
    <updated>2016-09-20T07:33:01.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Solr的工作流程很简单。你先给它添加你想要知道的信息，然后问它要。你给它信息的过程叫 indexing 或者 updating。你问它要信息的过程叫 query。Solr可以在schema为实体的不同变量、类型建立索引。</p>
<p>Solr的基本信息单元是document，它是一个描述某种事物的数据集合。document是由field组成的，它是更具体的信息。比如，鞋子的尺码、姓名都可以是field。field可以是多种类型，Solr允许用户定义field的类型：field type，定义准确的field type可以帮你准确的查找结果。</p>
<p>field analysis告诉了Solr如何建立索引。比如你会遇见这样的问题，一个人的传记中，会有”the” , “a “ 等这样的词，通过field analysis你可以告诉Solr怎么进行分词。它是field type 中的重要组成部分。</p>
<p>Solr将field type 等信息存在schema文件中。文件的名称和路径取决于你如何初始化Solr或者以后会怎样修改它。</p>
<p><strong>managed-schema</strong> – 是在运行时可以通过Schema API来修改的Solr schema文件。如果你使用别的名称，你可以显式的指定它，但是内容的更新需要Solr自动来完成。</p>
<p><strong>schema.xml</strong> – 它是传统的schema文件名，用户可以通过 ClassicIndexSchemaFactory 来手动编辑它。</p>
<p>如果你使用Cloud模式，你不会在本地文件系统中找到这个文件，可以通过Schema API或者Solr Admin UI 中的Cloud Screens看到。</p>
<p>不论你怎样定义文件名，问价你的结构是不会变的。如果你使用managed schema，那么原则上你只能通过Schema API来改变它，绝不能手动变更。如果你不使用 managed schema ， 那么你只能通过手动改变文件，Schema API不能操作任何改变。<br>如果你使用SolrCloud但是没有使用Schema API，那么你需要从ZooKeeper中使用upconfig或者downconfig命令来对schema.xml做一个本地备份和上传修改。</p>
<h2 id="Field-type"><a href="#Field-type" class="headerlink" title="Field type"></a>Field type</h2><p>field type 包括下面四种信息类型：</p>
<p><strong>field type 名称（必须）。</strong><br><strong>类型的实现类（必须）。</strong><br><strong>如果类型是 TextField ， 需要添加field analysis。</strong><br><strong>field type 属性 ， 依赖于实现类，一些属性是必须的。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_general"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span> <span class="attr">positionIncrementGap</span>=<span class="string">"100"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"solr.StandardTokenizerFactory"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.StopFilterFactory"</span> <span class="attr">ignoreCase</span>=<span class="string">"true"</span> <span class="attr">words</span>=<span class="string">"stopwords.txt"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- in this example, we will only use synonyms at query time</span></div><div class="line">    &lt;filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/&gt;</div><div class="line">    --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.LowerCaseFilterFactory"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"query"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"solr.StandardTokenizerFactory"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.StopFilterFactory"</span> <span class="attr">ignoreCase</span>=<span class="string">"true"</span> <span class="attr">words</span>=<span class="string">"stopwords.txt"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.SynonymFilterFactory"</span> <span class="attr">synonyms</span>=<span class="string">"synonyms.txt"</span> <span class="attr">ignoreCase</span>=<span class="string">"true"</span> <span class="attr">expand</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.LowerCaseFilterFactory"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的例子中，包含了field type名称 text-general，实现类 solr.TextField。实现类是用来保证field呗正确处理。在schema.xml中，solr字符串是org.apache.solr.schema 或 org.apache.solr.analysis的缩写。因此，solr.TextField 实际上是 org.apache.solr.schema.TextField。</p>
<h3 id="field-type属性"><a href="#field-type属性" class="headerlink" title="field type属性"></a>field type属性</h3><h4 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h4><ul>
<li>name – field type名称。用来定义field。强烈建议名称只包含字母数字或下划线字符,而不是从数字开头。</li>
<li>class – 存储或索引数据的class的名称。如果你使用solr开头，那么类似solr.TextField会有效，如果使用第三方的类，那么需要写全类名和包名。</li>
<li>positionIncrementGap – 对于多个值的field，指定多个值之间的距离，防止错误的匹配。integer。</li>
<li>autoGeneratePhraseQueries – 用于 text field。如果设为true，Solr自动为相邻的短语生成词组查询。如果设为false，短语必须加上双引号才能被视为一个词组。true/false</li>
<li>docValuesFormat – 为此类型的field定义一个DocValuesFormat ，这需要一个schema-aware解析器。例如solrconfig.xml中定义的SchemaCodecFactory。</li>
<li>postingsFormat – 为此类型的field定义一个postingsFormat，这需要一个schema-aware解析器。例如solrconfig.xml中定义的SchemaCodecFactory 。</li>
</ul>
<p>注意： Lucene向下兼容时只支持默认的解析器。如果你选择在schema.xml中自定义postingsFormat 或 docValuesFormat，更新到以后的版本时，需要切换为默认的解析器，并且在更新前重新优化你的index，或者重建你的index。</p>
<h3 id="field默认属性"><a href="#field默认属性" class="headerlink" title="field默认属性"></a>field默认属性</h3><p>这些属性既可以在field type中被指定，也可以在单独的field中被field type提供的值所覆盖。默认的值依赖于FieldType的class，进而可能依赖于<schema>中的version属性。</schema></p>
<ul>
<li>indexed – 如果设为true，field的值可以用来检索文档。  true/false ， 默认为true。</li>
<li>stored – 如果设为true，field的实际值可以用来被查询。  true/false ， 默认为true。</li>
<li>docValues – 如果设为true，field的值会被放入一个以列为主的DocValues结构中。true/false ， 默认为false。</li>
<li>sortMissingFirst/sortMissingLast – 当查询的field没有找到时，控制返回数据的排序方式。（没有field的排在有的之前/没有field的排在有的之后 ， 而不管请求时的排序方式）true/false ， 默认为false。</li>
<li>multiValued – 如果设为true，说明一个单独的文档可能包含这个field type 的多个值。true/false ， 默认为false。</li>
<li>omitNorms – 如果设为true，则省略了与这个field相关的规范。默认情况下，对于不执行analysis的字段类型设为true。只有全文字段或者需要index-time boost 的字段才需要规范。true/false。</li>
<li>omitTermFreqAndPositions – 如果设为true，则不用存储term的频率和position等信息。对于不需要这些信息的字段是一个性能的提升，减少磁盘空间。依赖于位置的字段查询将查找不到信息。这个属性对于所有非text的field默认为true。</li>
<li>omitPositions – 和omitTermFreqAndPositions 相似，但是保留词汇的频率信息。true or false</li>
<li>termVectors/termPositions/termOffsets/termPayloads – 这些选项指导Solr为每个文档维护全局向量，包括 position，offset ， 和负载信息。这些能用于加速高亮和其它辅助的功能，但是增加了词汇的index长度。他们对于一般使用Solr所必要的。true or false，默认false。</li>
<li>required – 阻止添加不包含该字段的任何文档。true or false ，默认为false。</li>
<li>useDocValuesAsStored – 如果docValues可用，并且本字段设为true，那么当匹配成功时，会将字段当做store field进行返回（即使它的store = false）。</li>
</ul>
<h3 id="field-type"><a href="#field-type" class="headerlink" title="field type"></a>field type</h3><ul>
<li>BinaryField – 二进制数据。</li>
<li>BoolField – bool ， 1，t，T都被认为true，其它都为false。</li>
<li>CollationField – 支持Unicode类型的查询排序集合。</li>
<li>CurrencyField – 支持货币和汇率。</li>
<li>DateRangeField – 支持日期范围检索。</li>
<li>ExternalFileField – 拉取磁盘上文件中的值。</li>
<li>EnumField – 枚举类型。</li>
<li>ICUCollationField – 支持Unicode类型的集合来进行排序和范围查询。</li>
<li>LatLonType – 经纬度坐标对。维度在前。</li>
<li>PointType – 一个N维空间的点。用于查询蓝图或者CAD上的资源。</li>
<li>PreAnalyzedField – 提供了一种发送给Solr的序列化令牌流，可选的独立存储的field的值，并不通过任何额外的文本处理将信息存储和索引。</li>
<li>RandomSortField – 不包含一个值。查询后将返回一个随机顺序的结果。使用动态field时使用这个功能。</li>
<li>SpatialRecursivePrefixTreeFieldType – 接受 纬度,精度 这样的字符串或者其他WKT格式的类型。</li>
<li>StrField – 字符串（UTF8或者Unicode编码），用于小的field并且这些字段不会被标记或者分析。他们有一个硬限制，就是小于32K。</li>
<li>TextField – Text类型，一般用于多单词或者多标记。</li>
<li>TrieDateField – 日期类型。代表一个毫秒精度的时间点。precisionStep=”0” 实现高效的日期排序，并减小了索引的大小。precisionStep=”8” (默认的)实现了高效的范围查询。</li>
<li>TrieDoubleField – Double类型。precisionStep=”0” 实现高效的数字排序，并减小了索引的大小。precisionStep=”8” (默认的)实现了高效的范围查询。</li>
<li>TrieField – 如果使用了这个类型，那么 type 属性必须被指定，有效的值为:integer, long, float, double, date 。使用这个field 和使用其它 Trie field 一样：实现高效的数字排序，并减小了索引的大小。precisionStep=”8” (默认的)实现了高效的范围查询。</li>
<li>TrieFloatField/TrieIntField/TrieLongField – float/int/long。precisionStep=”0” 实现高效的数字排序，并减小了索引的大小。precisionStep=”8” (默认的)实现了高效的范围查询。</li>
<li>UUIDField – 一般唯一标识符。传一个值为“NEW”的值然后Solr将会创建一个新的UUID。注意，在SolrCloud模式下使用UUID不是一个好的做法，因为每一个备份节点的每一个文档都会有一个唯一的UUID。当添加文档时使用UUIDUpdateProcessorFactory 来生成UUID是一个好的做法。</li>
</ul>
<h3 id="定义Field"><a href="#定义Field" class="headerlink" title="定义Field"></a>定义Field</h3><p>Field一般定义在schema.xml中。<br><code>&lt;field name=&quot;price&quot; type=&quot;float&quot; default=&quot;0.0&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</code></p>
<h3 id="拷贝Field"><a href="#拷贝Field" class="headerlink" title="拷贝Field"></a>拷贝Field</h3><p><code>&lt;copyField source=&quot;cat&quot; dest=&quot;text&quot; maxChars=&quot;30000&quot; /&gt;</code><br>source 是被拷贝的数据，des是拷贝到的field。定义在schema.xml中。<br>在上面的例子中，会将cat拷贝到text。field的拷贝实在analysis之前的，意味着你能够对相同的内容返回两个field（两个field使用不同的analysis链并存在不同的索引下）。<br>使用时需要设置field的 multivalued=”true”。</p>
<p>也可以使用通配符：<br><code>&lt;copyField source=&quot;*_t&quot; dest=&quot;text&quot; maxChars=&quot;25000&quot; /&gt;</code></p>
<h3 id="动态Field"><a href="#动态Field" class="headerlink" title="动态Field"></a>动态Field</h3><p><code>&lt;dynamicField name=&quot;*_i&quot; type=&quot;int&quot; indexed=&quot;true&quot;  stored=&quot;true&quot;/&gt;</code></p>
<p>动态field可以更灵活的使用Solr。</p>
<h3 id="其它Schema元素"><a href="#其它Schema元素" class="headerlink" title="其它Schema元素"></a>其它Schema元素</h3><ul>
<li><p>uniqueKey – 用于表示一个唯一的文档，不是必须的。<br><code>&lt;uniqueKey&gt;id&lt;/uniqueKey&gt;</code></p>
</li>
<li><p>Similarity<br>Similarity 是一个Lucene类，用于在搜索时对文档的评分。<br>TODO…</p>
</li>
</ul>
<h3 id="Schema-API"><a href="#Schema-API" class="headerlink" title="Schema API"></a>Schema API</h3><h4 id="API的入口点"><a href="#API的入口点" class="headerlink" title="API的入口点"></a>API的入口点</h4><ul>
<li>/schema – 检索信息，或者增加、删除，替换field，动态field，复制field或者field type。</li>
<li>/schema/fields – 检索指定field的信息或指定名称的field。</li>
<li>/schema/dynamicfields – 检索所有符合规则的动态field信息。</li>
<li>/schema/fieldtypes – 检索所有指定field type 的信息。</li>
<li>/schema/copyfields – 检索所有copy field的信息。</li>
<li>/schema/name – 检索schema名称。</li>
<li>/schema/version – 检索schema版本。</li>
<li>/schema/uniquekey – 检索定义的uniqueKey。</li>
<li>/schema/similarity – 检索全局similarity 定义。</li>
<li>/schema/solrqueryparser/defaultoperator – 检索默认操作。</li>
</ul>
<p><code>http://localhost:8983/solr/gettingstarted/schema</code></p>
<h4 id="修改Schema"><a href="#修改Schema" class="headerlink" title="修改Schema"></a>修改Schema</h4><p><code>POST /collection/schema</code><br>为了添加、删除，修改field、动态field规则、copy field规则、新field type，你可以发送POST请求到/collection/schema/。</p>
<ul>
<li>add-field – 添加一个带参数的field。</li>
<li>delete-field – 删除一个field。</li>
<li>replace-field – 用一个不同配置的field替换现有的。</li>
<li>add-dynamic-field – 添加一个带参数的动态规则。</li>
<li>delete-dynamic-field – 删除一个动态field规则。</li>
<li>replace-dynamic-field – 替换一个动态field规则。</li>
<li>add-field-type – 添加一个field type。</li>
<li>delete-field-type – 删除一个field type。</li>
<li>replace-field-type – 替换一个field type。</li>
<li>add-copy-field – 添加一个copy field规则。</li>
<li>delete-copy-field – 删除一个copy field规则。</li>
</ul>
<p>这些命令可以在单独的POST请求或在同一个POST请求。命令按指定的顺序执行。<br>每个请求都会返回状态和处理请求所用的时间，但是不会包含整个schema。</p>
<p>当使用API修改schema时，一个core重载会自动发生，以便使更改可立即用于其后索引的文档。之前的被索引的文档不会自动被处理，当使用被改变的schema时，它们必须重新索引。</p>
<ul>
<li><p>新增Field<br>add-field 命令向schema中添加一个新的field。如果存在同名的，那么抛出异常。当定义一个了一个手动编辑的schema.xml，所有的属性都可以通过API传递。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-field":&#123;</div><div class="line">     "name":"sell-by",</div><div class="line">     "type":"tdate",</div><div class="line">     "stored":true &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>删除field<br>delete-field 命令将会删除一个field，如果field不存在或者field是被copy的field，那么会抛出异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "delete-field" : &#123; "name":"sell-by" &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>替换Field<br>replace-field 命令会替换一个field。你需要提供field的完整定义。这个命令不会部分改变field，是整个替换。如果field不存在则抛出异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "replace-field":&#123;</div><div class="line">     "name":"sell-by",</div><div class="line">     "type":"date",</div><div class="line">     "stored":false &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>添加动态Field规则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-dynamic-field":&#123;</div><div class="line">     "name":"*_s",</div><div class="line">     "type":"string",</div><div class="line">     "stored":true &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>删除动态field规则<br>delete-dynamic-field 命令删除一个动态field规则。如果动态field规则不存在或者schema包含一个copy field作为源或者目标只和这个动态field匹配，那么会抛出一个异常。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "delete-dynamic-field":&#123; "name":"*_s" &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
<ul>
<li><p>替换动态field规则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "replace-dynamic-field":&#123;</div><div class="line">     "name":"*_s",</div><div class="line">     "type":"text_general",</div><div class="line">     "stored":false &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>添加一个新的field type</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-field-type" : &#123;</div><div class="line">     "name":"myNewTxtField",</div><div class="line">     "class":"solr.TextField",</div><div class="line">     "positionIncrementGap":"100",</div><div class="line">     "analyzer" : &#123;</div><div class="line">        "charFilters":[&#123;</div><div class="line">           "class":"solr.PatternReplaceCharFilterFactory",</div><div class="line">           "replacement":"$1$1",</div><div class="line">           "pattern":"([a-zA-Z])\\\\1+" &#125;],</div><div class="line">        "tokenizer":&#123; </div><div class="line">           "class":"solr.WhitespaceTokenizerFactory" &#125;,</div><div class="line">        "filters":[&#123;</div><div class="line">           "class":"solr.WordDelimiterFilterFactory",</div><div class="line">           "preserveOriginal":"0" &#125;]&#125;&#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的例子中，我么那只能定义一个单独的analyzer。如果我们想定义单独的分析器，我们需要用分开的 indexAnalyzer 和 queryAnalyzer 代替上面的analyzer。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-field-type":&#123;</div><div class="line">     "name":"myNewTextField",</div><div class="line">     "class":"solr.TextField",</div><div class="line">     "indexAnalyzer":&#123;</div><div class="line">        "tokenizer":&#123;</div><div class="line">           "class":"solr.PathHierarchyTokenizerFactory", </div><div class="line">           "delimiter":"/" &#125;&#125;,</div><div class="line">     "queryAnalyzer":&#123;</div><div class="line">        "tokenizer":&#123; </div><div class="line">           "class":"solr.KeywordTokenizerFactory" &#125;&#125;&#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
<ul>
<li><p>删除一个Field type<br>使用delete-field-type 删除一个field type。如果这个field type 不存在或者它已经被引用，那么会抛出异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "delete-field-type":&#123; "name":"myNewTxtField" &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>替换field type </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "replace-field-type":&#123;</div><div class="line">     "name":"myNewTxtField",</div><div class="line">     "class":"solr.TextField",</div><div class="line">     "positionIncrementGap":"100",</div><div class="line">     "analyzer":&#123;</div><div class="line">        "tokenizer":&#123; </div><div class="line">           "class":"solr.StandardTokenizerFactory" &#125;&#125;&#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>新增一个新的copy field 规则<br>参数：<br><strong>source</strong> – 源field。<br><strong>dest</strong> – 将一个field或一组field拷贝到的目的field。<br><strong>maxChars</strong> – 拷贝的字符数量的上限。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-copy-field":&#123;</div><div class="line">     "source":"shelf",</div><div class="line">     "dest":[ "location", "catchall" ]&#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
<ul>
<li><p>删除一个copy field 规则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "delete-copy-field":&#123; "source":"shelf", "dest":"location" &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
<li><p>单个POST中加入多命令<br>支持在单个的post中加入多命令，API支持事务。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-field-type":&#123;</div><div class="line">     "name":"myNewTxtField",</div><div class="line">     "class":"solr.TextField",</div><div class="line">     "positionIncrementGap":"100",</div><div class="line">     "analyzer":&#123;</div><div class="line">        "charFilters":[&#123;</div><div class="line">           "class":"solr.PatternReplaceCharFilterFactory",</div><div class="line">           "replacement":"$1$1",</div><div class="line">           "pattern":"([a-zA-Z])\\\\1+" &#125;],</div><div class="line">        "tokenizer":&#123; </div><div class="line">           "class":"solr.WhitespaceTokenizerFactory" &#125;,</div><div class="line">        "filters":[&#123;</div><div class="line">           "class":"solr.WordDelimiterFilterFactory",</div><div class="line">           "preserveOriginal":"0" &#125;]&#125;&#125;,</div><div class="line">   "add-field" : &#123;</div><div class="line">      "name":"sell-by",</div><div class="line">      "type":"myNewTxtField",</div><div class="line">      "stored":true &#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure>
</li>
</ul>
<p>重复的命令，可以修改成下面这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-field":&#123;</div><div class="line">     "name":"shelf",</div><div class="line">     "type":"myNewTxtField",</div><div class="line">     "stored":true &#125;,</div><div class="line">  "add-field":&#123;</div><div class="line">     "name":"location",</div><div class="line">     "type":"myNewTxtField",</div><div class="line">     "stored":true &#125;,</div><div class="line">  "add-copy-field":&#123;</div><div class="line">     "source":"shelf",</div><div class="line">      "dest":[ "location", "catchall" ]&#125;</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure></p>
<p>可以修改成：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H 'Content-type:application/json' --data-binary '&#123;</div><div class="line">  "add-field":[</div><div class="line">     &#123; "name":"shelf",</div><div class="line">       "type":"myNewTxtField",</div><div class="line">       "stored":true &#125;,</div><div class="line">     &#123; "name":"location",</div><div class="line">       "type":"myNewTxtField",</div><div class="line">       "stored":true &#125;]</div><div class="line">&#125;' http://localhost:8983/solr/gettingstarted/schema</div></pre></td></tr></table></figure></p>
<ul>
<li>修改所有副本的schema<br>在SolrCloud模式下，对schema的修改将会传播到集合中的所有节点。你可以通过在request中传递updateTimeoutSecs参数来设置所有节点确认的超时时间。这可以在规定的时间内确认所有节点都更新完毕，使你的系统更加健壮。如果确认信息没在指定时间到达，那么请求会失败并且报出异常，异常包括失败节点的错误信息。大部分情况下，唯一的做法是等待一段时间后重新请求，如果问题仍然存在，那么可以根据服务日志来查找解决问题。如果你不使用updateTimeoutSecs参数，接收节点的默认是在更新ZooKeeper后立即返回，这样，你就不能确保所有的节点都更新成功。</li>
</ul>
<h4 id="检索Schema信息"><a href="#检索Schema信息" class="headerlink" title="检索Schema信息"></a>检索Schema信息</h4><ul>
<li>检索全部Schema<br><code>GET /collection/schema</code><br>输入：<br>路径参数：<br>collection – 集合或core名称。<br>查询参数：<br>wt : 默认是json格式，可选的有 json、xml、schema.xml。</li>
</ul>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema?wt=json</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"responseHeader"</span>:&#123;</div><div class="line">    <span class="attr">"status"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"QTime"</span>:<span class="number">5</span>&#125;,</div><div class="line">  <span class="attr">"schema"</span>:&#123;</div><div class="line">    <span class="attr">"name"</span>:<span class="string">"example"</span>,</div><div class="line">    <span class="attr">"version"</span>:<span class="number">1.5</span>,</div><div class="line">    <span class="attr">"uniqueKey"</span>:<span class="string">"id"</span>,</div><div class="line">    <span class="attr">"fieldTypes"</span>:[&#123;</div><div class="line">        <span class="attr">"name"</span>:<span class="string">"alphaOnlySort"</span>,</div><div class="line">        <span class="attr">"class"</span>:<span class="string">"solr.TextField"</span>,</div><div class="line">        <span class="attr">"sortMissingLast"</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">"omitNorms"</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">"analyzer"</span>:&#123;</div><div class="line">          <span class="attr">"tokenizer"</span>:&#123;</div><div class="line">            <span class="attr">"class"</span>:<span class="string">"solr.KeywordTokenizerFactory"</span>&#125;,</div><div class="line">          <span class="attr">"filters"</span>:[&#123;</div><div class="line">              <span class="attr">"class"</span>:<span class="string">"solr.LowerCaseFilterFactory"</span>&#125;,</div><div class="line">            &#123;</div><div class="line">              <span class="attr">"class"</span>:<span class="string">"solr.TrimFilterFactory"</span>&#125;,</div><div class="line">            &#123;</div><div class="line">              <span class="attr">"class"</span>:<span class="string">"solr.PatternReplaceFilterFactory"</span>,</div><div class="line">              <span class="attr">"replace"</span>:<span class="string">"all"</span>,</div><div class="line">              <span class="attr">"replacement"</span>:<span class="string">""</span>,</div><div class="line">              <span class="attr">"pattern"</span>:<span class="string">"([^a-z])"</span>&#125;]&#125;&#125;,</div><div class="line">...</div><div class="line">    <span class="string">"fields"</span>:[&#123;</div><div class="line">        <span class="attr">"name"</span>:<span class="string">"_version_"</span>,</div><div class="line">        <span class="attr">"type"</span>:<span class="string">"long"</span>,</div><div class="line">        <span class="attr">"indexed"</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">"stored"</span>:<span class="literal">true</span>&#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"name"</span>:<span class="string">"author"</span>,</div><div class="line">        <span class="attr">"type"</span>:<span class="string">"text_general"</span>,</div><div class="line">        <span class="attr">"indexed"</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">"stored"</span>:<span class="literal">true</span>&#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"name"</span>:<span class="string">"cat"</span>,</div><div class="line">        <span class="attr">"type"</span>:<span class="string">"string"</span>,</div><div class="line">        <span class="attr">"multiValued"</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">"indexed"</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">"stored"</span>:<span class="literal">true</span>&#125;,</div><div class="line">...</div><div class="line">    <span class="string">"copyFields"</span>:[&#123;</div><div class="line">        <span class="attr">"source"</span>:<span class="string">"author"</span>,</div><div class="line">        <span class="attr">"dest"</span>:<span class="string">"text"</span>&#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"source"</span>:<span class="string">"cat"</span>,</div><div class="line">        <span class="attr">"dest"</span>:<span class="string">"text"</span>&#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"source"</span>:<span class="string">"content"</span>,</div><div class="line">        <span class="attr">"dest"</span>:<span class="string">"text"</span>&#125;,</div><div class="line">...</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"source"</span>:<span class="string">"author"</span>,</div><div class="line">        <span class="attr">"dest"</span>:<span class="string">"author_s"</span>&#125;]&#125;&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>列出field<br><code>GET /collection/schema/fields</code></li>
</ul>
<p><code>GET /collection/schema/fields/fieldname</code></p>
<p>路径参数：<br>collection – 集合或core名称。<br>fieldname – 指定的field名称。</p>
<p>查询参数：<br><strong>fl</strong> – 逗号、空格分隔的要求返回的field。如果不指定，所有field都会被返回。<br><strong>includeDynamic</strong> – 默认是false。如果设为true，并且fl参数被指定或者fieldname路径参数被使用，匹配的动态field将被包含在response中并且被dynamicBase属性标识。如果不指定fl和fieldname，那么includeDynamic将被忽略。如果设为false，符合的动态field将不会被返回。<br><strong>showDefaults</strong> – 默认是false。如果设为true，那么所有缺省字段的属性将会被返回。如果设为false，那么只有明确设定的字段属性会被返回。</p>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/fields?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"fields"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"indexed"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"_version_"</span>,</div><div class="line">            <span class="attr">"stored"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"long"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"indexed"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"author"</span>,</div><div class="line">            <span class="attr">"stored"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"text_general"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"indexed"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"multiValued"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"cat"</span>,</div><div class="line">            <span class="attr">"stored"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span></div><div class="line">        &#125;,</div><div class="line">...</div><div class="line">    ],</div><div class="line">    <span class="attr">"responseHeader"</span>: &#123;</div><div class="line">        <span class="attr">"QTime"</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">"status"</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>查询动态field<br><code>GET /collection/schema/dynamicfields</code><br><code>GET /collection/schema/dynamicfields/name</code></li>
</ul>
<p>查询参数</p>
<p><strong>showDefaults</strong> – 默认为false，如果设为true，那么所有缺省属性都会被返回，如果false，那么只会返回显式赋值的属性。</p>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/dynamicfields?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"dynamicFields"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"indexed"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"*_coordinate"</span>,</div><div class="line">            <span class="attr">"stored"</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"tdouble"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"multiValued"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"ignored_*"</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"ignored"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"random_*"</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"random"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"indexed"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"multiValued"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"attr_*"</span>,</div><div class="line">            <span class="attr">"stored"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"text_general"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"indexed"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"multiValued"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"*_txt"</span>,</div><div class="line">            <span class="attr">"stored"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"text_general"</span></div><div class="line">        &#125;</div><div class="line">...</div><div class="line">    ],</div><div class="line">    <span class="attr">"responseHeader"</span>: &#123;</div><div class="line">        <span class="attr">"QTime"</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">"status"</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>列出Copy field<br><code>GET /collection/schema/copyfields</code></li>
</ul>
<p>参数：<br>source.fl – 用逗号或空格来隔离出要返回的源字段，不设的话，会返回全部字段。<br>dest.fl – 用逗号或空格来隔离出要返回的目标字段，不设的话，会返回全部字段。</p>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/copyfields?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"copyFields"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"dest"</span>: <span class="string">"text"</span>,</div><div class="line">            <span class="attr">"source"</span>: <span class="string">"author"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"dest"</span>: <span class="string">"text"</span>,</div><div class="line">            <span class="attr">"source"</span>: <span class="string">"cat"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"dest"</span>: <span class="string">"text"</span>,</div><div class="line">            <span class="attr">"source"</span>: <span class="string">"content"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"dest"</span>: <span class="string">"text"</span>,</div><div class="line">            <span class="attr">"source"</span>: <span class="string">"content_type"</span></div><div class="line">        &#125;,</div><div class="line">...</div><div class="line">    ],</div><div class="line">    <span class="attr">"responseHeader"</span>: &#123;</div><div class="line">        <span class="attr">"QTime"</span>: <span class="number">3</span>,</div><div class="line">        <span class="attr">"status"</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>显示Schema名字<br><code>GET /collection/schema/name</code></li>
</ul>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/name?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"responseHeader"</span>:&#123;</div><div class="line">    <span class="attr">"status"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"QTime"</span>:<span class="number">1</span>&#125;,</div><div class="line">  <span class="attr">"name"</span>:<span class="string">"example"</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li>显示schema版本<br><code>GET /collection/schema/version</code></li>
</ul>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/version?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"responseHeader"</span>:&#123;</div><div class="line">    <span class="attr">"status"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"QTime"</span>:<span class="number">2</span>&#125;,</div><div class="line">  <span class="attr">"version"</span>:<span class="number">1.5</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li>列出UniqueKey<br><code>GET /collection/schema/uniquekey</code></li>
</ul>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/uniquekey?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"responseHeader"</span>:&#123;</div><div class="line">    <span class="attr">"status"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"QTime"</span>:<span class="number">2</span>&#125;,</div><div class="line">  <span class="attr">"uniqueKey"</span>:<span class="string">"id"</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li>显示全局Similarity<br><code>GET /collection/schema/similarity</code></li>
</ul>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/similarity?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"responseHeader"</span>:&#123;</div><div class="line">    <span class="attr">"status"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"QTime"</span>:<span class="number">1</span>&#125;,</div><div class="line">  <span class="attr">"similarity"</span>:&#123;</div><div class="line">    <span class="attr">"class"</span>:<span class="string">"org.apache.solr.search.similarities.DefaultSimilarityFactory"</span>&#125;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>查询默认查询操作器<br><code>GET /collection/schema/solrqueryparser/defaultoperator</code></li>
</ul>
<p><code>curl http://localhost:8983/solr/gettingstarted/schema/solrqueryparser/defaultoperator?wt=json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"responseHeader"</span>:&#123;</div><div class="line">    <span class="attr">"status"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"QTime"</span>:<span class="number">2</span>&#125;,</div><div class="line">  <span class="attr">"defaultOperator"</span>:<span class="string">"OR"</span>&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Solr的工作流程很简单。你先给它添加你想要知道的信息，然后问它要。你给它信息的过程叫 indexing 或者 updating。你问它要信
    
    </summary>
    
    
      <category term="Solr" scheme="http://chenpeng89.github.io/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>Solr学习笔记：三、使用Solr管理员界面</title>
    <link href="http://chenpeng89.github.io/2016/06/24/Solr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8Solr%E7%AE%A1%E7%90%86%E5%91%98%E7%95%8C%E9%9D%A2/"/>
    <id>http://chenpeng89.github.io/2016/06/24/Solr学习笔记：三、使用Solr管理员界面/</id>
    <published>2016-06-24T02:14:30.000Z</published>
    <updated>2016-09-20T07:33:11.330Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍的是Solr的管理员界面（Admin UI）使用方法。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Solr提供了一个Web界面，让Solr管理员和程序员更直观的看到Solr的配置，运行查询和分析来微调Solr配置，访问在线文档等等。<br><img src="http://i.imgur.com/E1IjbG0.png" alt=""></p>
<h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><p>在页面最下面就可以找到帮助信息栏。</p>
<p><img src="http://i.imgur.com/jVS9Seh.png" alt=""></p>
<p>它包括如下链接：</p>
<ul>
<li>Documentation ： 定向到Apache Solr的文档地址。<a href="https://lucene.apache.org/solr/。" target="_blank" rel="external">https://lucene.apache.org/solr/。</a></li>
<li>Issue Tracker ： 定向到Apache Solr项目的JIRA上。<a href="https://issues.apache.org/jira/browse/SOLR。" target="_blank" rel="external">https://issues.apache.org/jira/browse/SOLR。</a></li>
<li>IRC Channel ： 定向到描述怎么加入Solr IRC聊天室的Apache Wiki上面。<a href="https://wiki.apache.org/solr/IRCChannels。" target="_blank" rel="external">https://wiki.apache.org/solr/IRCChannels。</a></li>
<li>Community forum ： 定位到描述加入Solr用户协会的email地址列表的Wiki上。</li>
<li>Solr Query Syntax : 定位到Solr的 “查询语法和解析” 文档章节。</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Logging界面显示了最近的Solr节点日志。<br><img src="http://i.imgur.com/nzYtDIm.png" alt=""></p>
<p>在Logging下面有一个Level链接，点击后可以看到classpath 和classname的路径。黄色高亮的行说明class是可以打log的。点击高亮的行，会出现让你选择日志等级的菜单。粗体字符表示这个class不会被root日志等级的修改所影响。</p>
<p><img src="http://i.imgur.com/2pr27kv.png" alt="">    </p>
<h2 id="Cloud-界面"><a href="#Cloud-界面" class="headerlink" title="Cloud 界面"></a>Cloud 界面</h2><p>Cloud界面显示了不同样式的Cloud的结构图。包含”Tree”, “Graph”, “Graph (Radial)” 和 “Dump”。</p>
<p><img src="http://i.imgur.com/rzjXfBU.png" alt=""></p>
<p>上面的Graph显示了包含两个分片和两个备份的“gettingstarted”集群，还包含了一个分片的films集群。</p>
<p><img src="http://i.imgur.com/qRTXptp.png" alt=""></p>
<p>Graph (Radial) 以另一种不同的试图展示了上面的集群结构。</p>
<p><img src="http://i.imgur.com/7JRF8YO.png" alt=""></p>
<p>Tree 展示的是ZooKeeper上的数据结构目录，包含了 live_nodes 和 overseer 的状态，还有集群特定的信息，比如 state.json ， 当前分片的leader，配置文件等。</p>
<p>最后的 Dump 选项，可以返回包含所有节点的JSON文档。可以用来导出Solr保存在ZooKeeper上的所有快照数据同时也能够debug SolrCloud 。</p>
<h2 id="Collections-Core-Admin"><a href="#Collections-Core-Admin" class="headerlink" title="Collections / Core Admin"></a>Collections / Core Admin</h2><p><img src="http://i.imgur.com/WbvOpPF.png" alt=""><br>Collections 界面提供了基本的操作Collections的功能。<br>如果使用的是single模式，则显示的是Core Admin。<br>主页面显示了一个在你集群中的集合列表。点击集合的姓名会显示一些基本的元数据，包括 集合的定义，当前分片和备份，增加和删除单个备份。</p>
<h2 id="Java-Properties"><a href="#Java-Properties" class="headerlink" title="Java Properties"></a>Java Properties</h2><p><img src="http://i.imgur.com/RkRpv35.png" alt=""><br>Java Properties 界面可以看到Solr JVM的所有参数，比如 classpath ， 文件编码，JVM内存，操作系统等。</p>
<h2 id="Thread-Dump"><a href="#Thread-Dump" class="headerlink" title="Thread Dump"></a>Thread Dump</h2><p><img src="http://i.imgur.com/dFV9Gll.png" alt=""><br>Thread Dump 界面能让你检查当前活动的线程。每个线程都被列出来并可以查看堆栈状态。左边的图标显示了堆栈状态，例如，每个绿色的对勾图标显示线程在”RUNNABLE”状态。在线程名称右侧，展开向下的箭头可以看到线程的堆栈。</p>
<p>线程状态</p>
<ul>
<li>NEW – 线程还没开始运行。</li>
<li>RUNNABLE – 线程在JVM中运行。</li>
<li>BLOCKED – 线程等待锁而阻塞。</li>
<li>WAITING – 线程无限期等待另一个线程的一个特定操作。</li>
<li>TIMED_WAITING – 线程在制定的时间等待另一个线程的一个特定操作。</li>
<li>TERMINATED – 线程结束。</li>
</ul>
<h2 id="针对集合的工具"><a href="#针对集合的工具" class="headerlink" title="针对集合的工具"></a>针对集合的工具</h2><p>在左边的菜单中，有一个下拉框，可以选择Core或者Collection，当使用Cloud模式时，可以选择Collection，选择后，会有一个二级菜单出现在下拉框下方。<br><img src="http://i.imgur.com/JTFKXlA.png" alt=""></p>
<p>主要包含以下几个功能：</p>
<ul>
<li>Analysis<br>通过Analysis页面可以根据字段检查数据的处理，字段类型和动态字段配置。可以分析内容将在索引期间或在查询处理期间如何进行处理，并分别或同时查看结果。理想情况下，你会希望内容会被持续处理，那么这个页面可以让你验证字段类型或者字段分析链中的设置。<br><img src="http://i.imgur.com/jiAaW0A.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节主要介绍的是Solr的管理员界面（Admin UI）使用方法。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Solr提供了一个Web界面，让Solr管理员和程序员更直
    
    </summary>
    
    
      <category term="Solr" scheme="http://chenpeng89.github.io/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>DataInputStream中read和readFully方法的区别【转】</title>
    <link href="http://chenpeng89.github.io/2016/06/21/DataInputStream%E4%B8%ADread%E5%92%8CreadFully%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://chenpeng89.github.io/2016/06/21/DataInputStream中read和readFully方法的区别【转】/</id>
    <published>2016-06-21T05:38:45.000Z</published>
    <updated>2016-09-20T03:12:17.542Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>其实read(byte[] b)方法和readFully(byte []b)都是利用InputStream中read（）方法，每次读取的也是一个字节，只是读取字节数组的方式不同，查询jdk中源代码发现。</p>
</li>
<li><p>read(byte[] b)方法实质是读取流上的字节直到流上没有字节为止，如果当声明的字节数组长度大于流上的数据长度时就提前返回，而readFully(byte[] b)方法是读取流上指定长度的字节数组，也就是说如果声明了长度为len的字节数组，readFully(byte[] b)方法只有读取len长度个字节的时候才返回，否则阻塞等待，如果超时，则会抛出异常 EOFException。</p>
</li>
<li>那么当发送了长度为len的字节，那么为什么用read方法用户收不全呢，揪其原因我们发现消息在网络中传输是没那么理想的，我们发的那部分字节数组在传送过程中可能在接受信息方的缓存当中或者在传输线路，极端情况下可能在发送方的缓存当中，这样就不在流上，所以read方法提前返回了，这样就造成了各种错误。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;其实read(byte[] b)方法和readFully(byte []b)都是利用InputStream中read（）方法，每次读取的也是一个字节，只是读取字节数组的方式不同，查询jdk中源代码发现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;read(byte
    
    </summary>
    
    
      <category term="DataInputStream" scheme="http://chenpeng89.github.io/tags/DataInputStream/"/>
    
      <category term="read" scheme="http://chenpeng89.github.io/tags/read/"/>
    
      <category term="readFully" scheme="http://chenpeng89.github.io/tags/readFully/"/>
    
  </entry>
  
  <entry>
    <title>Solr学习笔记：N、配置</title>
    <link href="http://chenpeng89.github.io/2016/06/13/Solr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AN%E3%80%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://chenpeng89.github.io/2016/06/13/Solr学习笔记：N、配置/</id>
    <published>2016-06-13T09:37:25.000Z</published>
    <updated>2016-09-20T03:12:17.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>Solr服务在运行时需要访问它的home目录，home目录包含了Solr的重要配置和索引信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/solr-6.0.1/server/solr</div><div class="line">&lt;solr-home-directory&gt;/</div><div class="line">   solr.xml</div><div class="line">   core_name1/</div><div class="line">      core.properties</div><div class="line">      conf/</div><div class="line">         solrconfig.xml</div><div class="line">         managed-schema</div><div class="line">      data/</div><div class="line">   core_name2/</div><div class="line">      core.properties</div><div class="line">      conf/</div><div class="line">         solrconfig.xml</div><div class="line">         managed-schema</div><div class="line">      data/</div></pre></td></tr></table></figure></p>
<p>##solr.xml<br>其中，solr.xml包含了Solr服务的配置。<br>你可以在home目录或者zookeeper上找到solr.xml文件，默认情况下，它是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;solr&gt;</div><div class="line"> </div><div class="line">  &lt;solrcloud&gt;</div><div class="line">    &lt;str name=&quot;host&quot;&gt;$&#123;host:&#125;&lt;/str&gt;</div><div class="line">    &lt;int name=&quot;hostPort&quot;&gt;$&#123;jetty.port:8983&#125;&lt;/int&gt;</div><div class="line">    &lt;str name=&quot;hostContext&quot;&gt;$&#123;hostContext:solr&#125;&lt;/str&gt;</div><div class="line">    &lt;int name=&quot;zkClientTimeout&quot;&gt;$&#123;zkClientTimeout:15000&#125;&lt;/int&gt;</div><div class="line">    &lt;bool name=&quot;genericCoreNodeNames&quot;&gt;$&#123;genericCoreNodeNames:true&#125;&lt;/bool&gt;</div><div class="line">  &lt;/solrcloud&gt;</div><div class="line"> </div><div class="line">  &lt;shardHandlerFactory name=&quot;shardHandlerFactory&quot;</div><div class="line">    class=&quot;HttpShardHandlerFactory&quot;&gt;</div><div class="line">    &lt;int name=&quot;socketTimeout&quot;&gt;$&#123;socketTimeout:0&#125;&lt;/int&gt;</div><div class="line">    &lt;int name=&quot;connTimeout&quot;&gt;$&#123;connTimeout:0&#125;&lt;/int&gt;</div><div class="line">  &lt;/shardHandlerFactory&gt;</div><div class="line"> </div><div class="line">&lt;/solr&gt;</div></pre></td></tr></table></figure></p>
<p>从上面的配置可以看到，默认情况下，solr配置了<solrcloud>，但是这并不意味着solr已经运行在cloud模式下，除非在启动时指定 -DzkHost 或者 -DzkRun ， 否则它会被忽略。</solrcloud></p>
<p>下面介绍详细参数：</p>
<ul>
<li><code>&lt;solr&gt;</code>标签<br><code>&lt;solr&gt;</code>是文件的根标签，下面列出它的子节点</li>
</ul>
<ol>
<li><code>adminHandler</code> – 定义了处理用户请求的Hnadler。如果不设置，则使用默认的CoreAdminHandler，如果要自定义handler，则需要继承CoreAdminHandler。例如：<code>&lt;str name=&quot;adminHandler&quot;&gt;com.myorg.MyAdminHandler&lt;/str&gt;</code>。</li>
<li><code>collectionsHandler</code> – 同上，用于自定义CollectionsHandler 的实现。</li>
<li><code>infoHandler</code> – 同上，用于自定义infoHandler的实现。</li>
<li><code>coreLoadThreads</code> – 指定用来并行加载core的线程数。</li>
<li><code>coreRootDirectory</code> – 指定core的根目录，默认为SOLR_HOME。</li>
<li><code>managementPath</code> – 当前没有作用。</li>
<li><code>sharedLib</code> – 指定一个被所有core共享的lib的目录。这个目录下的所有jar都将被添加到Solr插件搜索的路径中。这个路径是和Solr的顶层容器Solr Home相关的。用户自定义的handler也可以放在此目录下。</li>
<li><code>shareSchema</code> – 如果这个参数设为 true，那么多个指向同一个Schema资源文件的core将引用同样的 IndexSchema对象。共享IndexSchema对象将使加载core变得更快。如果你要使用这个功能，请确保没有 特定的针对某个core的属性 用在你的Schema文件中。</li>
<li><code>transientCacheSize</code> – 定义有多少个transient = true 的core能在将最近最少使用的core换成新的core之前加载。</li>
<li><code>configSetBaseDir</code> – 定义core的configsets存放的目录路径。默认是SOLR_HOME/configsets。</li>
</ol>
<ul>
<li><code>&lt;solrcloud&gt;</code>标签<br>这个标签定义了和SolrCloud相关的几个参数。除非在启动时使用了 -DzkRun 或者 -DzkHost ， 否则这一部分将被忽略。</li>
</ul>
<ol>
<li><code>distribUpdateConnTimeout</code> – 用于设置集群内部更新时潜在的“connTimeout”。</li>
<li><code>distribUpdateSoTimeout</code> – 用于设置集群内部更新时潜在的“socketTimeout”。</li>
<li><code>host</code> – Solr用来访问core的hostname。</li>
<li><code>hostContext</code> – Solr web服务中Servlet的上下文路径。</li>
<li><code>hostPort</code> – Solr用于访问core的端口号。在默认的solr.xml中，一般设为${jetty.port:8983}，它将使用在Jetty中定义的Solr端口，否则会使用8983。</li>
<li><code>leaderVoteWait</code> – 当SolrCloud启动时，假设在没有宕机的情况下，每个Solr节点等待所有已知分片的备份时间。</li>
<li><code>leaderConflictResolveWait</code> – 当试图为一个分片选举一个leader时，这个属性设置了一个备份等待处理冲突的最长时间。临时的状态信息冲突可能发生在轮流的重启动过程中，尤其是当运行监视主机的节点重启的时候。典型地，默认值180000（millis）足够实现冲突的解决。当你的SolrCloud中有成百上千个小的collection的时候，你可能需要增加这个值。</li>
<li><code>zkClientTimeout</code> – 连接ZooKeeper服务的超时时间。</li>
<li><code>zkHost</code> – 用来管理Solr集群状态的ZooKeeper的URL。</li>
<li><code>genericCoreNodeNames</code> – 如果设置为true，节点的名称就不取决于节点的地址，而是一个由Core标识的通用的名字。当不同的机器接管这一服务时，这样的名字会更容易被理解。</li>
<li><code>zkCredentialsProvider &amp;  zkACLProvider</code> – 当使用 ZooKeeper Access Control 时可选的参数。</li>
</ol>
<ul>
<li><code>&lt;logging&gt;</code>标签</li>
</ul>
<ol>
<li><code>class</code> – 用于实现日志的类。对应的JAR必须能被solr有效使用，可以考虑在solrconfig.xml中使用<lib>指出。</lib></li>
<li><code>enabled</code> – true/false，是否允许使用日志。</li>
</ol>
<ul>
<li><code>&lt;logging&gt;&lt;watcher&gt;</code>标签</li>
</ul>
<ol>
<li><code>size</code> – 缓存日志的数量。</li>
<li><code>threshold</code> – 日志等级，高于该等级的日志才能被记录。</li>
</ol>
<ul>
<li><p><code>&lt;shardHandlerFactory&gt;</code>标签<br>指定分片handler。<br><code>&lt;shardHandlerFactory name=&quot;ShardHandlerFactory&quot; class=&quot;qualified.class.name&quot;&gt;</code>。<br>由于是自定义的实现方式，因此，它的子元素是和具体实现相关的。</p>
</li>
<li><p>在solr.xml中设置jvm参数<br>Solr支持在solr.xml中替换JVM运行参数，它允许在运行时指定多重配置。具体语法是： ${propertyname[:option default value]}。它允许定义默认的状态，这个状态可以在solr启动时被覆盖。如果没有指定一个默认值，那么这个属性必须在运行时指定，否则在解析solr.xml文件时会产生错误。<br>设置JVM参数一般在启动JVM时使用 -D 标识。这个可以在solr.xml中作为变量使用。<br>例如：在下面展示的solr.xml中，使用“java -DsocketTimeout=1000 -jar start.jar”启动solr会使用1000ms覆盖HttpShardHandlerFactory socket的超时属性，取代原本默认的值“0”——但是，connTimeout选项仍会使用默认呢的值“0”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;solr&gt;</div><div class="line">  &lt;shardHandlerFactory name=&quot;shardHandlerFactory&quot;</div><div class="line">                       class=&quot;HttpShardHandlerFactory&quot;&gt;</div><div class="line">    &lt;int name=&quot;socketTimeout&quot;&gt;$&#123;socketTimeout:0&#125;&lt;/int&gt;</div><div class="line">    &lt;int name=&quot;connTimeout&quot;&gt;$&#123;connTimeout:0&#125;&lt;/int&gt;</div><div class="line">  &lt;/shardHandlerFactory&gt;</div><div class="line">&lt;/solr&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="core-properties"><a href="#core-properties" class="headerlink" title="core.properties"></a>core.properties</h2><p>core.properties文件是一个简单的Java属性文件，其中每一行是一个key=value对，比如：name=core1。注意这里不支持引用。</p>
<ul>
<li>core.properties文件位置<br>core的配置文件core.properties一般位于solr.home的子目录下。Solr没有限制core.properties在目录树的深度，也没限制可定义的core数。core可以定义在目录树任何地方，除了已经存在的core目录下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./cores/core1/core.properties</div><div class="line">./cores/core1/coremore/core5/core.properties</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个例子中，只有core1是有效的。</p>
<p>下面的例子是合法的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./cores/somecores/core1/core.properties</div><div class="line">./cores/somecores/core2/core.properties</div><div class="line">./cores/othercores/core3/core.properties</div><div class="line">./cores/extracores/deepertree/core4/core.properties</div></pre></td></tr></table></figure></p>
<p>Solr可以分成多个core，每一个core有自己的配置和索引。core可以服务于一个单个应用或者许多个不同的应用，但是他们都被一个统一的管理员界面来管理。Solr支持热部署，即在运行时增加、删除甚至替换core都不用停止或者重启Solr。<br>core.properties文件可以是空的。假设core.properties位于./cores/core目录下，但是是空的，那么，core的名称将为core1，那么core1实例路径为../cores.core1 ， data路径为 ../cores/core1/data。</p>
<ul>
<li>配置参数</li>
</ul>
<ol>
<li><code>name</code> – SolrCore的名称，可以在CoreAdminHandler上运行命令时使用它查找SolrCore。</li>
<li><code>config</code> – 当前core的配置文件名称，默认为 solrconfig.xml。</li>
<li><code>schema</code> – 当前core的模式文件的名字，默认是schema.xml。</li>
<li><code>dataDir</code> – 当前core的data目录路径，可以是绝对路径，也可以是相对于 instanceDir 的相对路径。</li>
<li><code>configSet</code> – 定义configset的名称，可以用它来配置core。</li>
<li><code>properties</code> – 当前core的properties文件名称，值可以是绝对路径也可以是相对于 instanceDir 的相对路径。</li>
<li><code>transient</code> – 如果设为true，当Solr达到transientCacheSize上限时，可能会卸载当前core。默认值是false。最近最少被使用的core最先进行卸载。在SolrCloud模式下，不推荐设为true。</li>
<li><code>loadOnStartup</code> – 如果设为true（默认值），当前core会在solr启动时被加载。在SolrCloud模式下，不推荐设为false。</li>
<li><code>coreNodeName</code> – 仅应用在SolrCloud模式下，它是coreNode的唯一标识符。默认情况下，它是自动生成的，但是这个属性可以允许你手动分配一个新的core代替已经存在的，使用相同的coreNodeName指定一个新的机器，那么它会取代原有的SolrCore。一般用于更换有故障的机器。</li>
<li><code>uLogDir</code> – 这个core（SolrCloud）的更新日志的绝对或相对路径。</li>
<li><code>shard</code> – 指定这个core上的shard。</li>
<li><code>collection</code> – 这个core所属的collection的名字。</li>
<li><code>roles</code> – 一个未来将会用于SolrCloud的参数，或者用户用来标记在自己使用的节点的方法。</li>
</ol>
<h2 id="solrconfig-xml"><a href="#solrconfig-xml" class="headerlink" title="solrconfig.xml"></a>solrconfig.xml</h2><p>solrconfig.xml是Solr中参数最多的配置文件。当配置Solr时，你通常要使用solrconfig.xml来配置，不管是直接使用solrconfig.xml还是通过ConfigAPI创建Configuration Overlays来覆盖solrconfig.xml中的配置。</p>
<p>在solrconfig.xml中，可以配置以下几个重要的属性：</p>
<ol>
<li>request handlers ， 用于在Solr中处理请求，例如：向索引中添加文档或者为请求返回查询结果。</li>
<li>liseners ，用于监听特定查询事件。listener能用做为触发器，比如，使用cache来处理常见查询。</li>
<li>Request Dispatcher，用于处理HTTP请求。</li>
<li>Admin Web 界面。</li>
<li>和复制备份相关的参数。</li>
</ol>
<p>solrconfig.xml文件位于每个collection的conf/目录下。Solr也提供了一些带有注释且包含多种实用配置的案例，可以在server/solr/configsets/ 找到。</p>
<ul>
<li><p>设置DataDir<br>指定data的目录，可以是绝对路径也可以是针对instance的相对路径。<br><code>&lt;dataDir&gt;/var/data/solr/&lt;/dataDir&gt;</code></p>
</li>
<li><p>设置索引的DirectoryFactory<br>默认情况下，solr.StandardDirectoryFactory是基于当前文件系统的，它会选择出当前JVM和平台最好的实现。你可以强制指定 solr.MMapDirectoryFactory, solr.NIOFSDirectoryFactory, 或者 solr.SimpleFSDirectoryFactory作为实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;directoryFactory name=&quot;DirectoryFactory&quot;</div><div class="line">                  class=&quot;$&#123;solr.directoryFactory:solr.StandardDirectoryFactory&#125;&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>solr.RAMDirectoryFactory是基于内存的，因此是不能持久化的，而且不能复制。使用这个DirectoryFactory将索引储存在RAM中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;directoryFactory class=&quot;org.apache.solr.core.RAMDirectoryFactory&quot;/&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>lib目录<br>solrconfig.xml可以用lib标签来加载插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;lib dir=&quot;../../../contrib/extraction/lib&quot; regex=&quot;.*\.jar&quot; /&gt;</div><div class="line">&lt;lib dir=&quot;../../../dist/&quot; regex=&quot;solr-cell-\d.*\.jar&quot; /&gt;</div><div class="line"> </div><div class="line">&lt;lib dir=&quot;../../../contrib/clustering/lib/&quot; regex=&quot;.*\.jar&quot; /&gt;</div><div class="line">&lt;lib dir=&quot;../../../dist/&quot; regex=&quot;solr-clustering-\d.*\.jar&quot; /&gt;</div><div class="line"> </div><div class="line">&lt;lib dir=&quot;../../../contrib/langid/lib/&quot; regex=&quot;.*\.jar&quot; /&gt;</div><div class="line">&lt;lib dir=&quot;../../../dist/&quot; regex=&quot;solr-langid-\d.*\.jar&quot; /&gt;</div><div class="line"> </div><div class="line">&lt;lib dir=&quot;../../../contrib/velocity/lib&quot; regex=&quot;.*\.jar&quot; /&gt;</div><div class="line">&lt;lib dir=&quot;../../../dist/&quot; regex=&quot;solr-velocity-\d.*\.jar&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>Schema Factory<br>Solr的Schema API允许远程客户端通过REST风格的接口访问和修改Schema信息。<br>Solr API的”read”功能能支持所有Schema类型，而使用程序修改Schema则需要依靠<code>&lt;schemaFactory&gt;</code>。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!-- An example of Solr&apos;s implicit default behavior if no</div><div class="line">     no schemaFactory is explicitly defined.</div><div class="line">--&gt;</div><div class="line"> &lt;schemaFactory class=&quot;ManagedIndexSchemaFactory&quot;&gt;</div><div class="line">   &lt;bool name=&quot;mutable&quot;&gt;true&lt;/bool&gt;</div><div class="line">   &lt;str name=&quot;managedSchemaResourceName&quot;&gt;managed-schema&lt;/str&gt;</div><div class="line"> &lt;/schemaFactory&gt;</div></pre></td></tr></table></figure>
<ol>
<li><code>mutable</code> – 控制是否能改变Schema中的数据。当允许使用Schema API修改数据时，必须设为true。</li>
<li><code>managedSchemaResourceName</code> – 是一个可选的参数，默认为“managed-schema” ， 用来设置schema文件的名称，不可以设置为“schema.xml”。</li>
</ol>
<p>以上的是默认设置，你可以使用Schema API修改schema，然后将mutable设为false，这样，就可以锁上schema并且保护修改。</p>
<ul>
<li>Classic schema.xml<br>为使用托管模式的另一种方法是显式配置ClassicIndexSchemaFactory。ClassicIndexSchemaFactory需要使用schema.xml的配置，并且在运行时不允许程序修改Schema。schema.xml必须手动修改并且仅当Solr集合加载时加载。<br><code>&lt;schemaFactory class=&quot;ClassicIndexSchemaFactory&quot;/&gt;</code></li>
</ul>
<p><strong>将schema.xml转换为Managed Schema</strong><br>如果你当前的Solr集合使用ClassicIndexSchemaFactory，</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;Solr服务在运行时需要访问它的home目录，home目录包含了Solr的重要配置和索引信息。&lt;br&gt;&lt;figure cla
    
    </summary>
    
    
      <category term="Solr" scheme="http://chenpeng89.github.io/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>Solr学习笔记：一、入门</title>
    <link href="http://chenpeng89.github.io/2016/06/13/Solr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E3%80%81%E5%85%A5%E9%97%A8/"/>
    <id>http://chenpeng89.github.io/2016/06/13/Solr学习笔记：一、入门/</id>
    <published>2016-06-13T02:24:25.000Z</published>
    <updated>2016-09-20T03:12:17.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Solr是一个用Java语言开发的，基于Lucene的开源全文搜索服务器。它包含了lucene提供的索引和搜索、拼写检查、命中结果高亮和先进的分析/标记等功能，同时，它还提供了层面搜索（有些类似于group by 的功能）等高级功能，并简化了开发难度。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>前文说了，Solr是基于Java开发的，因此需要在JRE环境下运行。下面介绍在Linux下安装Solr的步骤。</p>
<p>Solr要求JRE版本为1.8或者以上。如果不确定自己的机器是否安装jre或者jre的版本，可以使用下面的命令看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ java -version</div><div class="line">  java version &quot;1.8.0_92&quot;</div><div class="line">  Java(TM) SE Runtime Environment (build 1.8.0_92-b14)</div><div class="line">  Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)</div></pre></td></tr></table></figure></p>
<p>如果没安装或者版本低于1.8的话，先安装JRE。</p>
<p>然后下载Solr，<a href="http://lucene.apache.org/solr/" target="_blank" rel="external"><strong>solr-6.0.1.tgz</strong></a>。</p>
<p>下载后解压之。<br><code>tar zxf solr-6.0.1.tgz</code></p>
<p>解压成功后就可以准备运行了。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><strong>开启</strong></p>
<p>Solr的运行很简单。首先进入bin目录。<br><code>cd bin</code><br>然后启动Solr。<br><code>$ ./solr start</code><br>然后看到下面的提示，就说明运行成功了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./solr start</div><div class="line">Waiting up to 30 seconds to see Solr running on port 8983 [\]  </div><div class="line">Started Solr server on port 8983 (pid=92928). Happy searching!</div></pre></td></tr></table></figure></p>
<p>这时可以看到，Solr默认的绑定端口时8983，当然，你也可以自定义绑定的端口号：<br><code>./solr start -p 8984</code></p>
<p>Solr默认是运行在后台的服务，你也可以自定义让它在前台显示：<br><code>./solr start -f</code></p>
<p>Solr提供了一些有用的例子来帮助大家学习它的关键的功能，可以通过 -e 来指定运行的配置：<br><code>./solr -e techproducts</code></p>
<p><strong>停止</strong></p>
<p>当Solr运行在前台时，你就可以通过Ctrl+C来停止它。如果是后台运行，则需要用<br><code>./solr stop</code></p>
<p><strong>检测Solr运行状态</strong><br>如果你不确定本地是否运行了solr，使用下面命令来检测：<br><code>./solr status</code></p>
<p><strong>更多功能，可以使用 <code>./solr -help</code>来查询。</strong></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Solr提供了管理后台，可以通过登录 <a href="http://localhost:8983/solr/" target="_blank" rel="external">http://localhost:8983/solr/</a> 来查看。<br><img src="http://i.imgur.com/aNcuJp0.png" alt=""></p>
<p><strong>创建一个核心</strong><br>核心，有些类似于数据库的中的库，在solr中将文档存到核心的目录下。如果之前你没有使用solr提供的例子来启动的话，我们就需要创建一个新的核心来进行接下来的工作。<br><code>./solr create -c gettingstarted</code></p>
<p>查看具体配置，可以这样：<br><code>/solr create -help</code></p>
<p><strong>添加文档</strong><br>Solr通过查询文档来实现搜索功能。Solr维护了一个有内容结构的概要，但是没有文档的话，Solr什么也查不到，所以，在使用Solr前，要先加入有搜索内容的文档。</p>
<p>Solr中自带的文档来自于 example/ 的子目录下。</p>
<p>在 bin/ 目录下，有一个 post 的命令行工具，可以通过它来将不同类别的内容发送给Solr，包括Solr原生的XML、JSON、CSV等，具体的可以通过 <code>./post -help</code>来了解。</p>
<p>执行命令：<br><code>./post -c gettingstarted example/exampledocs/*.xml</code><br>这就将exampledocs目录中的xml文件导入到了Solr中。</p>
<p><strong>查询</strong><br>接下来就可以使用查询了。最简单的方式是使用URL并包含查询参数。例如：<br><a href="http://localhost:8983/solr/gettingstarted/select?q=video" target="_blank" rel="external">http://localhost:8983/solr/gettingstarted/select?q=video</a></p>
<p>查询所有文档中数据段有 “video” 的数据。<br>查询结果包含两部分，一部分是响应头信息（responseHeader），另一部分是响应主体信息（result），包含了查询的数据结果。Solr可以将结果输出为 XML，JSON,PHP,Ruby和用户自定义的数据格式。</p>
<p>你也可以指定返回的数据字段：<br><a href="http://localhost:8983/solr/gettingstarted/select?q=video&amp;fl=id,name,price" target="_blank" rel="external">http://localhost:8983/solr/gettingstarted/select?q=video&amp;fl=id,name,price</a></p>
<p>或者返回字段中的字段数值范围：<br><a href="http://localhost:8983/solr/gettingstarted/select?q=price:0" target="_blank" rel="external">http://localhost:8983/solr/gettingstarted/select?q=price:0</a> TO 400&amp;fl=id,name,price</p>
<p>层面搜索是Solr中一个重要的功能，使用它需要在参数中加上 facet=true&amp;facet.field=xxx：<br><a href="http://localhost:8983/solr/gettingstarted/select?q=price:[0" target="_blank" rel="external">http://localhost:8983/solr/gettingstarted/select?q=price:[0</a> TO 400]&amp;fl=id,name,price&amp;facet=true&amp;facet.field=cat</p>
<p>也可以缩小查询结果范围<br><a href="http://localhost:8983/solr/gettingstarted/select?q=price:0" target="_blank" rel="external">http://localhost:8983/solr/gettingstarted/select?q=price:0</a> TO 400&amp;fl=id,name,price&amp;facet=true&amp;facet.field=cat&amp;fq=cat:software</p>
<h2 id="Solr-脚本"><a href="#Solr-脚本" class="headerlink" title="Solr 脚本"></a>Solr 脚本</h2><p>Solr提供了一个脚本，位于 bin/solr ，可以用来开启和停止Solr，创建删除Solr节点或集合，检查Solr状态和配置分片。</p>
<ul>
<li>启动或重启<br><code>./solr start  [option]</code><br><code>./solt start -help</code><br><code>./solr restart [option]</code><br><code>./solt restart -help</code></li>
</ul>
<p><strong>参数</strong></p>
<ol>
<li><code>-a &quot;&lt;string&gt;&quot;</code> – 使用补充的JVM参数开启Solr，例如以-X开头的，如果你传以-D开头的JVM参数，那么可以省略 -a 选项。</li>
<li><code>-cloud</code> – 以SolrCloud模式启动Solr，并访问Solr内置的zookeeper。这个选项可以省略为 -c 。如果你想运行完整版的zookeeper代替solr内置的，那么，可以使用 -z 参数。</li>
<li><code>-d &lt;dir&gt;</code> – 定义server的目录，默认是 $SOLR_HOME/server。一般不会覆盖这个选项。如果在同一个host上运行多个solr实例，普遍的会用 -s 选项来使用同一个server目录，并使用唯一一个Solr home目录。</li>
<li><p><code>-e &lt;name&gt;</code> – 使用一个样例配置来启动Solr，这些例子会帮助你更快的学习Solr，并使用指定的功能。 可用的为：<br>cloud<br>techproducts<br>dih<br>schemaless</p>
</li>
<li><p><code>-f</code> – 在前端启动Solr，与 -e 不能同时使用。</p>
</li>
<li><code>-h &lt;hostname&gt;</code> – 使用定义的host启动solr。如果不指定，默认是localhost。</li>
<li><code>-m &lt;memory&gt;</code> – 设置JVM堆内存。<code>bin/solr start -m 1g</code>。</li>
<li><code>-noprompt</code> – 启动Solr时忽略其它选项。使用所有默认值可能会带来副作用。<br>例如，当使用cloud 样例时，一个交互会话会引导你通过几个选项配置你的SolrCloud集群。如果你想要所有都是默认的，那么你可以简单的添加 -noprompt选项在你的请求中。</li>
<li><code>-p &lt;port&gt;</code> – 在指定的端口上启动Solr，默认为 8983。</li>
<li><code>-s &lt;dir&gt;</code> – 设置solr的solr home目录。Solr将会在这个目录下创建core。它允许你运行多个Solr实例在同一个host上，同时重用同一个server目录时设置 -d 参数。如果设置它，需要在目录下包含solr.xml文件，除非在zookeeper上已经存在了solr.xml。默认值是 server/solr。<br>当使用 -e 时，这个选项会被忽略。</li>
<li><code>-V</code> – 启动Solr时，在启动脚本上显示详细信息。</li>
<li><code>-z &lt;zkHost&gt;</code> – 使用zookeeper 连接字符串启动solr。这个选项只在使用 -c 选项时起作用，来启动solrcloud模式中的solr。如果这个选项没设置，那么会启动内置的zookeeper实例并用它对solrcloud进行操作。 <code>bin/solr start -c -z server1:2181,server2:2181</code>。</li>
</ol>
<p><strong>SolrCloudMode</strong><br>当使用zookeeper连接字符串启动时，那么会连接到zookeeper并加入到集群中。否则，会使用内置的zookeeper，端口号为 solr运行的端口号 + 1000。<br><strong><font color="red">注意：如果你的zookeeper连接字符串是一个改变了根目录的，比如： localhost:2181/solr ，那么你需要在使用 bin/solr 启动脚本启动SolrCloud之前启动/solr znode。要做到这一点，你需要使用Solr附带的zkcli.sh脚本。例如：</font></strong><br><code>server/scripts/cloud-scripts/zkcli.sh -zkhost localhost:2181/solr -cmd bootstrap -solrhome server/solr</code>。</p>
<p><strong>使用Solr提供的样例</strong><br><strong>cloud</strong> – 样例会在单机上启动 1-4 个solrcloud节点，启动时，交互会话将引导你选择 configsets 、集群节点数，端口号和创建的collection 名称。当使用这个样例时，可以从 $SOLR_HOME/server/solr/configsets 选择合适的configsets。</p>
<p><strong>techproducts</strong> – 这个样例运行在单机模式下，包含了文档样例。样例位于 $SOLR_HOME/example/exampledocs 。configsets位于$SOLR_HOME/server/solr/configsets/sample_techproducts_configs。</p>
<p><strong>dih</strong> – 这个样例运行在单机模式下，使用的是 DataImportHandler (DIH) ，通过不同的dataconfig.xml来支持多种不同类型的数据。configset用来设置DIH，它位于$SOLR_HOME/example/example-DIH/solr/conf。</p>
<p><strong>schemaless</strong> – 这个样例运行在单机模式下，使用了一个 管理模式 ，并提供了一个非常小的预定义 schema。Solr将会运行在Schemaless Mode下，Solr会动态创建字段并猜测收到文件中字段的类型。configset位于 $SOLR_HOME/server/solr/configsets/data_driven_schema_configs。</p>
<ul>
<li>停止</li>
</ul>
<p>Stop命令会向Solr节点发送STOP请求，并优雅停机。命令会等待Solr节点5s来优雅停机，然后会直接强迫kill进程。</p>
<p><code>bin/solr stop [options]</code><br><code>bin/solr stop -help</code></p>
<p><strong>参数</strong><br><strong>-p <port></port></strong> – 停止运行的Solr节点。如果你运行了多个Solr或者SolrCloud模式下，你需要指定不同的端口或者使用-all条件。bin/solr stop -p 8983</p>
<p><strong>-all</strong> – 停止所有有有效PID的Solr实例。bin/solr stop -all</p>
<p><strong>-k <key></key></strong> – 用于停止的Key，用于防止无意中误操作停止Solr，默认的key是solrrocks。bin/solr stop -k solrrocks</p>
<ul>
<li>信息相关</li>
</ul>
<p><strong>版本</strong><br><code>$ bin/solr version</code></p>
<p><strong>状态</strong></p>
<p>运行后会以JSON格式显示所有Solr节点。状态命令使用SOLR_PID_DIR环境变量来定位进程ID文件并查找运行中的实例，SOLR_PID_DIR变量默认位于bin目录下。</p>
<p><code>bin/solr status</code></p>
<p><strong>健康监测</strong><br>当使用SolrCloud模式下，健康监测命令会产生JSON格式的报告。报告会提供每一个分片备份的状态，包括提交文档数量和它当前状态。</p>
<p><code>bin/solr healthcheck [options]</code></p>
<p><code>bin/solr healthcheck -help</code></p>
<p><code>-c &lt;collection&gt;</code> – 运行指定名称集合的健康监测。 bin/solr healthcheck -c gettingstarted</p>
<p><code>-z &lt;zkhost&gt;</code> – ZooKeeper 连接字符串，默认是 localhost:9983。如果在其它端口上运行Solr，需要指定ZooKeeper的连接字符串。默认情况下，它是Solr的端口号+1000。</p>
<ul>
<li>集合和Core<br>bin/solr 脚本可以帮助你创建新的collection（在SolrCloud模式下）或者 core（在独立模式下），或者删除集合。</li>
</ul>
<p><strong>Create</strong></p>
<font color="red"><br>注意：使用create命令前要注意你需要是启动Solr的用户。如果你使用的是Linux/Unix安装脚本，那么一般使用名为 solr 的用户来执行。如果Solr运行在solr用户中但是你用root用户创建core，那么Solr将不能写入开始脚本创建的目录。<br>如果运行在SolrCloud模式下，这就没什么问题。在cloud模式下，所有配置都存在ZooKeeper中，并且create脚本不需要创建目录或者拷贝配置文件。Solr自身会创建必要的目录。<br></font>

<p>create命令会自动检测Solr是否运行在独立模式下，会相应的创建core或者集合。</p>
<p><code>bin/solr create options</code></p>
<p><code>bin/solr create -help</code></p>
<p><code>-c &lt;name&gt;</code> – 创建core或者collection。  bin/solr create -c mycollection</p>
<p><code>-d &lt;confdir&gt;</code> – 配置文件路径。默认是data_driven_schema_configs。bin/solr create -d basic_configs</p>
<p><code>-n &lt;configName&gt;</code> – 配置。bin/solr create -n basic</p>
<p><code>-p &lt;port&gt;</code> – 在指定端口号创建Solr实例。bin/solr create -p 8983</p>
<p><code>-s &lt;shards&gt; -shards</code> – 集合中分片的数目，默认是1，只运行在SolrCloud模式下。bin/solr create -s 2</p>
<p><code>-rf &lt;replicas&gt; -replicationFactor</code> – 集合中每个文档的拷贝数量。默认是1。bin/solr create -rf 2</p>
<p><strong>Delete</strong><br>delete命令检测到运行的Solr，并删除指定core或者collection。<br><code>bin/solr delete [options]</code></p>
<p><code>bin/solr delete -help</code></p>
<p>如果在SolrCloud模式下，delete命令会检查指定删除的collection的配置是否呗其它collection使用。如果没有，那么将从ZooKeeper中删除。</p>
<p><code>-c &lt;name&gt;</code> – 删除指定名称的core或collection。bin/solr delete -c mycoll</p>
<p><code>-deleteConfig &lt;true|false&gt;</code> – 从ZooKeeper中删除配置目录。默认是true。如果配置被别的collection使用，那么设为true也不会被删除。bin/solr delete -deleteConfig false</p>
<p><code>-p &lt;port&gt;</code> – 删除指定端口号的solr实例。默认的，会删除当前运行的实例。bin/solr delete -p 8983</p>
<ul>
<li>ZooKeeper相关操作<br>bin/solr 脚本也允许一些操作来影响ZooKeeper。</li>
</ul>
<p><code>bin/solr zk [options]</code></p>
<p><code>bin/solr zk -help</code></p>
<p>在初始化ZooKeeper前，Solr需要至少启动一次。当ZooKeeper初始化后，Solr不需要再在任何节点上运行这些命令。</p>
<p><strong>上传配置</strong><br>使用如下ZooKeeper的子命令来上传预设值的配置集合/自定义配置集合。</p>
<p><code>-upconfig</code> – 从本地上传配置集合到ZooKeeper。    -upconfig</p>
<p><code>-n &lt;name&gt;</code> – ZooKeeper上的配置名。命令将会上传配置到”configs” ZooKeeper 节点，并命名为指定的名字。-n myconfig</p>
<p><code>-d &lt;configset dir&gt;</code> – 指定上传配置的路径。它需要有一个conf路径，并且下面包括solrconfig.xml等。-d directory_under_configsets<br>-d /absolute/path/to/configset/source</p>
<p><code>-z &lt;zkHost&gt;</code> – ZooKeeper 连接字符串。-z 123.321.23.43:2181</p>
<p>样例： <code>bin/solr zk -upconfig -z 111.222.333.444:2181 -n mynewconfig -d /path/to/configset</code></p>
<p>上面的例子不会自动起作用，它只会将配置上传到ZooKeeper，可以使用Collections API的RELOAD相关方法使它生效。</p>
<p><strong>下载配置集</strong><br><code>-downconfig</code> – 将ZooKeeper上的配置下载到本地。-downconfig</p>
<p><code>-n &lt;name&gt;</code> – 需要下载的配置集的名，Admin UI&gt;&gt;Cloud&gt;&gt;tree&gt;&gt;configs node下列出了所有可用配置集。-n myconfig </p>
<p><code>-d &lt;configset dir&gt;</code> – 将下载的配置集存到哪个目录。-d directory_under_configsets -d /absolute/path/to/configset/destination</p>
<p><code>-z &lt;zkHost&gt;</code> – ZooKeeper 连接字符串。-z 123.321.23.43:2181</p>
<p>样例：<br><code>bin/solr zk -downconfig -z 111.222.333.444:2181 -n mynewconfig -d /path/to/configset</code> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Solr是一个用Java语言开发的，基于Lucene的开源全文搜索服务器。它包含了lucene提供的索引和搜索、拼写检查、命中结果高亮和先进
    
    </summary>
    
    
      <category term="Solr" scheme="http://chenpeng89.github.io/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor学习笔记:二、简单实现</title>
    <link href="http://chenpeng89.github.io/2016/06/06/Disruptor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E3%80%81%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://chenpeng89.github.io/2016/06/06/Disruptor学习笔记：二、简单实现/</id>
    <published>2016-06-06T08:17:47.000Z</published>
    <updated>2016-09-20T03:12:17.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接下来实现一个简单的producer和consume，讲一个Long值从producer传递给consumer，并在consumer中打印出来。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>首先，定义一个数据传递的载体，Event。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"LongEvent&#123;"</span> +</div><div class="line">                <span class="string">"value="</span> + value +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了实现Disruptor的events的预分配，我们创建一个EventFactory来创建Event。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一旦我们定义了Event，那么肯定要有consumer来消费它。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Event: "</span> + event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来需要创建Producer来发布Event。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Disruptor&lt;LongEvent&gt; disruptor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceEvent</span><span class="params">()</span></span>&#123;</div><div class="line">        EventFactory&lt;LongEvent&gt; eventFactory = <span class="keyword">new</span> LongEventFactory();</div><div class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</div><div class="line">        <span class="keyword">int</span> ringBufferSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// RingBuffer 大小，必须是 2 的 N 次方；</span></div><div class="line">        disruptor = <span class="keyword">new</span> Disruptor&lt;LongEvent&gt;(eventFactory , ringBufferSize , executor , ProducerType.SINGLE , <span class="keyword">new</span> YieldingWaitStrategy());</div><div class="line">        EventHandler&lt;LongEvent&gt; eventHandler = <span class="keyword">new</span> LongEventHandler();</div><div class="line">        disruptor.handleEventsWith(eventHandler);</div><div class="line">        disruptor.start();</div><div class="line">        ringBuffer = disruptor.getRingBuffer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发布Event。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span></span>&#123;</div><div class="line">        Producer producer = <span class="keyword">new</span> Producer();</div><div class="line">        producer.provideService();</div><div class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = Producer.ringBuffer;</div><div class="line">        <span class="keyword">long</span> sequence = ringBuffer.next(); <span class="comment">//请求下一个事件序号</span></div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            LongEvent event = ringBuffer.get(sequence);</div><div class="line">            <span class="keyword">long</span> data = <span class="number">1000L</span>;</div><div class="line">            event.set(data);</div><div class="line">            ringBuffer.publish(sequence);</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            Producer.disruptor.shutdown();<span class="comment">//关闭 disruptor，方法会堵塞，直至所有的事件都得到处理；</span></div><div class="line"><span class="comment">//            Producer.executor.shutdown();//关闭 disruptor 使用的线程池；如果需要的话，必须手动关闭， disruptor 在 shutdown 时不会自动关闭；</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Publisher publisher = <span class="keyword">new</span> Publisher();</div><div class="line">        publisher.publish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行main方法，接下来就可以看到运行结果了。<br><code>Event: LongEvent{value=1000}</code></p>
<p>明显可以看出，相比于使用简单的队列，事件发布机制更多地参与了进来。这是由于我们希望的Event预分配内存。最低要求通过两个阶段来发布信息，先调用ring buffer的数据槽，再发布可用的数据。同时有必要将Event的发布封装到try/finally 中。如果我们调用RingBuffer中的数据槽（calling RingBuffer.next()），那么接下来我们必须发布这个sequence。如果不这么做的话，会导致Disruptor状态异常。特别是，当使用multi-producer时，它将会使consumer阻塞，并且只能通过重启来恢复。</p>
<h2 id="Version-3-的Translators实现方式"><a href="#Version-3-的Translators实现方式" class="headerlink" title="Version 3 的Translators实现方式"></a>Version 3 的Translators实现方式</h2><p>在3.0版本，Disruptor提供了一个丰富的Lambda风格的api，来帮助开发人员封装RingBuffer里面复杂的逻辑。所以，3.0以后的版本推荐通过 Event Publisher/Event Translator来发布Event。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducerWithTranslator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongEventProducerWithTranslator</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventTranslatorOneArg&lt;LongEvent , Long&gt; TRANSLATOR = <span class="keyword">new</span> EventTranslatorOneArg&lt;LongEvent,Long&gt;()&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translateTo</span><span class="params">(LongEvent longEvent, <span class="keyword">long</span> l, Long data)</span> </span>&#123;</div><div class="line">            longEvent.set(data);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(Long data)</span></span>&#123;</div><div class="line">        ringBuffer.publishEvent(TRANSLATOR , data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用这种方法的优势在于Translator的代码可以单独做成一个类，容易进行单元测试。Disruptor为此提供了多个接口(EventTranslator, EventTranslatorOneArg, EventTranslatorTwoArg 等)。</p>
<p>接下来，发布Event。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventMain</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//Executor用来为consumer创建新的线程</span></div><div class="line">        Executor executor = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">        LongEventFactory factory = <span class="keyword">new</span> LongEventFactory();</div><div class="line"></div><div class="line">        <span class="comment">//指定ringBuffer的大小，必须为2的倍数</span></div><div class="line">        <span class="keyword">int</span> bufferSize = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">        Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;LongEvent&gt;(factory ,bufferSize , executor);</div><div class="line"></div><div class="line">        disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler());</div><div class="line"></div><div class="line">        <span class="comment">//启动Disruptor，启动所有线程</span></div><div class="line">        disruptor.start();</div><div class="line"></div><div class="line">        <span class="comment">//从Disruptor获取用来发布的ringBuffer</span></div><div class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</div><div class="line"></div><div class="line">        LongEventProducerWithTranslator producer = <span class="keyword">new</span> LongEventProducerWithTranslator(ringBuffer);</div><div class="line">        producer.onData(<span class="number">1000L</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单一Producer和多Producer"><a href="#单一Producer和多Producer" class="headerlink" title="单一Producer和多Producer"></a>单一Producer和多Producer</h2><p>提高并发系统性能的最好的方式是采用单一作家原则，Disruptor已经应用了它。如果你的Disruptor系统中只有一个Producer线程，那么你可以利用这点获得额外的性能。</p>
<h2 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h2><p>Disruptor默认的等待策略是BlockingWaitStrategy，BlockingWaitStrategy使用锁和条件变量来控制线程的唤醒。Disruptor还提供其它等待策略。</p>
<h3 id="SleepingWaitStrategy"><a href="#SleepingWaitStrategy" class="headerlink" title="SleepingWaitStrategy"></a>SleepingWaitStrategy</h3><p>在多次循环尝试不成功后，选择让出CPU，等待下次调度，多次调度后仍不成功，尝试前睡眠一个纳秒级别的时间再尝试。这种策略平衡了延迟和CPU资源占用，但延迟不均匀。</p>
<h3 id="YieldingWaitStrategy"><a href="#YieldingWaitStrategy" class="headerlink" title="YieldingWaitStrategy"></a>YieldingWaitStrategy</h3><p>在多次循环尝试不成功后，选择让出CPU，等待下次调。平衡了延迟和CPU资源占用，但延迟也比较均匀。</p>
<h3 id="BusySpinWaitStrategy"><a href="#BusySpinWaitStrategy" class="headerlink" title="BusySpinWaitStrategy"></a>BusySpinWaitStrategy</h3><p>自旋等待，类似Linux Kernel使用的自旋锁。低延迟但同时对CPU资源的占用也多。</p>
<h2 id="Disruptor-DSL"><a href="#Disruptor-DSL" class="headerlink" title="Disruptor DSL"></a>Disruptor DSL</h2><p>Disruptor提供了一个简单的DSL风格的API来简化Event handler开发。</p>
<h3 id="并行的Event-Handler"><a href="#并行的Event-Handler" class="headerlink" title="并行的Event Handler"></a>并行的Event Handler</h3><p>首先创建和ringbuffer相关的配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Disruptor&lt;ValueEvent&gt; disruptor =</div><div class="line">  <span class="keyword">new</span> Disruptor&lt;ValueEvent&gt;(ValueEvent.EVENT_FACTORY, EXECUTOR,</div><div class="line">                            <span class="keyword">new</span> SingleThreadedClaimStrategy(RING_SIZE),</div><div class="line">                            <span class="keyword">new</span> SleepingWaitStrategy());</div></pre></td></tr></table></figure></p>
<p>然后我们将它传入一个Executor实例，并在它的线程内执行event handler。<br>然后我们添加event handler来并行处理Event handler。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disruptor.handleEventsWith(handler1, handler2, handler3, handler4);</div></pre></td></tr></table></figure></p>
<p>最后，开启event handler线程，并且获得配置好的RingBuffer。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RingBuffer&lt;ValueEvent&gt; ringBuffer = disruptor.start();</div></pre></td></tr></table></figure></p>
<p>接下来Producer就可以使用RingBuffer的nextEvent并将events放入ringbuffer。</p>
<h3 id="有依赖关系的Event-handler"><a href="#有依赖关系的Event-handler" class="headerlink" title="有依赖关系的Event handler"></a>有依赖关系的Event handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disruptor.handleEventsWith(handler1).then(handler2, handler3, handler4);</div></pre></td></tr></table></figure>
<p>handler1必须先执行，handler2,3,4会并行。<br>也可以实现多个handler链。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">disruptor.handleEventsWith(handler1).then(handler2);</div><div class="line">disruptor.handleEventsWith(handler3).then(handler4);</div></pre></td></tr></table></figure></p>
<h3 id="使用自定义EventProcessor"><a href="#使用自定义EventProcessor" class="headerlink" title="使用自定义EventProcessor"></a>使用自定义EventProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RingBuffer&lt;TestEvent&gt; ringBuffer = disruptor.getRingBuffer();</div><div class="line">SequenceBarrier barrier = ringBuffer.newBarrier();</div><div class="line"><span class="keyword">final</span> MyEventProcessor customProcessor = <span class="keyword">new</span> MyEventProcessor(ringBuffer, barrier);</div><div class="line">disruptor.handleEventsWith(processor);</div><div class="line">disruptor.start();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SequenceBarrier barrier = disruptor.after(batchEventHandler1, batchEventHandler2).asBarrier();</div><div class="line"><span class="keyword">final</span> MyEventProcessor customProcessor = <span class="keyword">new</span> MyEventProcessor(ringBuffer, barrier);</div></pre></td></tr></table></figure>
<h3 id="发布Event"><a href="#发布Event" class="headerlink" title="发布Event"></a>发布Event</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyPublisher</span><span class="params">(Disruptor disruptor)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">this</span>.disruptor = disruptor;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</div><div class="line">    &#123;</div><div class="line">      computedValue = doLongRunningComputation();</div><div class="line">      disruptor.publishEvent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translateTo</span><span class="params">(MyEvent event, <span class="keyword">long</span> sequence)</span></span></div><div class="line">  &#123;</div><div class="line">    event.setComputedValue(computedValue);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">doLongRunningComputation</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;接下来实现一个简单的producer和consume，讲一个Long值从producer传递给consumer，并在consumer中打印出
    
    </summary>
    
    
      <category term="Disruptor" scheme="http://chenpeng89.github.io/tags/Disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor学习笔记:一、入门</title>
    <link href="http://chenpeng89.github.io/2016/06/06/Disruptor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E3%80%81%E5%85%A5%E9%97%A8/"/>
    <id>http://chenpeng89.github.io/2016/06/06/Disruptor学习笔记：一、入门/</id>
    <published>2016-06-06T02:41:46.000Z</published>
    <updated>2016-09-20T03:12:17.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Disruptor是LMAX公司开源的一个高性能的线程间通讯库，它关注的是并发，高性能和非阻塞算法，现在已经是LMAX交易系统的核心构件。</p>
<p>Disruptor是一个非阻塞队列，它的作用是在同一进程中的几个线程间移动数据。和普通队列比起来，它有以下特点：</p>
<ul>
<li>通过Consumer依赖关系图将Events广播给Consumer。</li>
<li>为Events提前分配内存。</li>
<li>无锁（可选）。</li>
</ul>
<h2 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h2><ul>
<li>Ring Buffer: 用于对通过Disruptor移动的数据进行存储和更新，在一些比较复杂的场景中，可以由用户自定义实现。</li>
<li>Sequence: 使用递增的序号来管理进行数据交换的Event，Disruptor对数据的处理过程总是按照序号逐个递增。因此，Sequence可以用来跟踪标识事件处理者（RingBuffer/Consumer）的处理进度。Sequence包含了AtomicLong的大部分并发特性，但是Sequence可以防止不同Sequence之间CPU缓存伪共享的问题。</li>
<li>Sequencer: Sequencer是Disruptor的核心。它有两个实现，single producer, multi producer，定义了producer和consumer之间快速、正确的传递数据（Event）的并发算法。</li>
<li>Sequence Barrier: 它由Sequencer创建，它包含了Sequencer发布的主要Sequence和所有相关消费者的Sequence的引用。它还能决定是否有供消费者来消费的Event的逻辑。</li>
<li>Wait Strategy: Wait Strategy决定了consumer怎样等待producer放入Disruptor的数据。</li>
<li>Event: 从producer到consumer的数据传递单元。它是由用户自己定义的。Disruptor中没有任何关于它的代码。</li>
<li>EventProcessor:主要的事件循环，用于处理Disruptor中的Event，并且拥有消费者的Sequence。它有一个实现类是BatchEventProcessor，包含了event loop有效的实现，并且将回调到一个EventHandler接口的实现对象。</li>
<li>EventHandler: Disruptor 定义的事件处理接口，由用户实现，用于处理事件，是 Consumer 的真正实现。</li>
<li>Producer: 即生产者，只是泛指调用 Disruptor 发布事件的用户代码，Disruptor 没有定义特定接口或类型。</li>
</ul>
<p><img src="http://i.imgur.com/I5EnXdb.png" alt=""></p>
<h2 id="广播事件"><a href="#广播事件" class="headerlink" title="广播事件"></a>广播事件</h2><p>这个是Disruptor和队列的最大的不同。当有多个consumer监听同一个Disruptor，那么Event会发布给所有的consumer，而队列，则是一个单独的Event只能发给一个consumer。Disruptor一般在当你需要并行处理相同的数据的情况下使用。<br>在LMAX中的典型例子是，我们有三个操作，传输（将输入的数据写入持久化文件），复制（将输入的数据发送到远程机器上备份），业务逻辑处理。当使用Executor并行处理不同事件时，可以使用WorkerPool。</p>
<h2 id="Consumer依赖图"><a href="#Consumer依赖图" class="headerlink" title="Consumer依赖图"></a>Consumer依赖图</h2><p>为了支持现实中的并发处理，consumer之间的协作是非常必要的。参考上图的例子，保证bussiness logic consumer在journalling和replication consumer执行完再执行是非常必要的。我们将这种概念成为gating。gating出现在两种情况。首先，我们要保证消费者不会发生过载情况。这可以通过为Disruptor添加相关的Consumer来实现（调用RingBuffer.addGatingConsumers()方法）。其次，前面提到的那种情况可以通过创建包含Sequence的SequenceBarrier来实现，Sequence需要在保证先完成它们处理逻辑的组件（比如类似bussiness logic consumer等）里面创建。</p>
<h2 id="Event内存预分配"><a href="#Event内存预分配" class="headerlink" title="Event内存预分配"></a>Event内存预分配</h2><p>Disruptor一个重要的目标就是低延迟。在低延迟系统中，减少和消除内存分配是很必要的。在基于java的系统中，目标就是减少由于gc引起的延迟。<br>为了解决这个问题，Disruptor可以为Events预分配内存。在用户提供构造器和EventFactory时，它们将会被RingBuffer中的每一个实体调用。当发布新数据到Disruptor时，API允许用户得到构造对象，以便于它们能够在那个存储对象上调用方法或更新域。Disruptor提供了保证，只要它们正确的实现，那么这些操作将是线程安全的。</p>
<h2 id="无锁（可选）"><a href="#无锁（可选）" class="headerlink" title="无锁（可选）"></a>无锁（可选）</h2><p>另一个实现低延迟的关键细节就是大规模使用无锁算法来实现Disruptor。所有内存的可见性和正确性是通过使用 memory barriers（内存屏障，就是它让一个处理器内的内存状态对其他处理器可见。） 或 compare-and-swap（CAS,CAS有三个操作参数：内存地址，期望值，要修改的新值，当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，这时候失败返回，当相等的时候，将内存中的值改为新的值，并返回成功。） 来实现的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Disruptor是LMAX公司开源的一个高性能的线程间通讯库，它关注的是并发，高性能和非阻塞算法，现在已经是LMAX交易系统的核心构件。&lt;
    
    </summary>
    
    
      <category term="Disruptor" scheme="http://chenpeng89.github.io/tags/Disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis学习笔记：四、动态SQL</title>
    <link href="http://chenpeng89.github.io/2016/06/03/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81SQL/"/>
    <id>http://chenpeng89.github.io/2016/06/03/Mybatis学习笔记：四、动态SQL/</id>
    <published>2016-06-03T05:46:20.000Z</published>
    <updated>2016-09-20T07:32:08.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mybatis另一个重要的特性就是动态SQL，利用这一特性，可以简化Java代码。<br>Mybatis的动态SQL主要包含以下几种语句：</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;select id=&quot;findActiveBlogLike&quot;</div><div class="line">     resultType=&quot;Blog&quot;&gt;</div><div class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’ </div><div class="line">  &lt;if test=&quot;title != null&quot;&gt;</div><div class="line">    AND title like #&#123;title&#125;</div><div class="line">  &lt;/if&gt;</div><div class="line">  &lt;if test=&quot;author != null and author.name != null&quot;&gt;</div><div class="line">    AND author_name like #&#123;author.name&#125;</div><div class="line">  &lt;/if&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure>
<h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose,when,otherwise"></a>choose,when,otherwise</h2><p>choose有些类似于switch。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;select id=&quot;findActiveBlogLike&quot;</div><div class="line">     resultType=&quot;Blog&quot;&gt;</div><div class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</div><div class="line">  &lt;choose&gt;</div><div class="line">    &lt;when test=&quot;title != null&quot;&gt;</div><div class="line">      AND title like #&#123;title&#125;</div><div class="line">    &lt;/when&gt;</div><div class="line">    &lt;when test=&quot;author != null and author.name != null&quot;&gt;</div><div class="line">      AND author_name like #&#123;author.name&#125;</div><div class="line">    &lt;/when&gt;</div><div class="line">    &lt;otherwise&gt;</div><div class="line">      AND featured = 1</div><div class="line">    &lt;/otherwise&gt;</div><div class="line">  &lt;/choose&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;select id=&quot;findActiveBlogLike&quot;</div><div class="line">     resultType=&quot;Blog&quot;&gt;</div><div class="line">  SELECT * FROM BLOG </div><div class="line">  WHERE </div><div class="line">  &lt;if test=&quot;state != null&quot;&gt;</div><div class="line">    state = #&#123;state&#125;</div><div class="line">  &lt;/if&gt; </div><div class="line">  &lt;if test=&quot;title != null&quot;&gt;</div><div class="line">    AND title like #&#123;title&#125;</div><div class="line">  &lt;/if&gt;</div><div class="line">  &lt;if test=&quot;author != null and author.name != null&quot;&gt;</div><div class="line">    AND author_name like #&#123;author.name&#125;</div><div class="line">  &lt;/if&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure>
<p>考虑一个问题，当上面if代码段中，如果两个结果都为false，那么sql就变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM BLOG </div><div class="line">  WHERE</div></pre></td></tr></table></figure></p>
<p>或者第一个为false，第二个为true，则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM BLOG</div><div class="line">WHERE </div><div class="line">AND title like ‘someTitle’</div></pre></td></tr></table></figure></p>
<p>这样显然是有问题的，Mybatis简单的为我们解决了这一问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;select id=&quot;findActiveBlogLike&quot;</div><div class="line">     resultType=&quot;Blog&quot;&gt;</div><div class="line">  SELECT * FROM BLOG </div><div class="line">  &lt;where&gt; </div><div class="line">    &lt;if test=&quot;state != null&quot;&gt;</div><div class="line">         state = #&#123;state&#125;</div><div class="line">    &lt;/if&gt; </div><div class="line">    &lt;if test=&quot;title != null&quot;&gt;</div><div class="line">        AND title like #&#123;title&#125;</div><div class="line">    &lt;/if&gt;</div><div class="line">    &lt;if test=&quot;author != null and author.name != null&quot;&gt;</div><div class="line">        AND author_name like #&#123;author.name&#125;</div><div class="line">    &lt;/if&gt;</div><div class="line">  &lt;/where&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p><code>where</code>元素会在至少有一个<code>if</code>条件为true的情况下才会插入<code>WHERE</code>，也会知道如何去除<code>OR</code>|<code>AND</code>。</p>
<p>我们也能通过<code>trim</code>来解决这一问题，可以通过自定义<code>trim</code>来定制我们想要的功能。比如，上面的<code>where</code>元素等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;select id=&quot;queryUser&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;</div><div class="line">   SELECT * FROM users</div><div class="line">   &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;</div><div class="line">      AND id = #&#123;id&#125;</div><div class="line">   &lt;/trim&gt;</div><div class="line"> &lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p><code>prefixOverrides</code>会自动忽略里面的<code>AND</code>，并且插入<code>prefix</code>中指定的内容<code>WHERE</code>，这样，执行时的SQL会变成：<br><code>SELECT * FROM users WHERE id = #{id}</code><br>用于动态更新的标签为<code>SET</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;</div><div class="line">  update Author</div><div class="line">    &lt;set&gt;</div><div class="line">      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;</div><div class="line">      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;</div><div class="line">      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</div><div class="line">      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;</div><div class="line">    &lt;/set&gt;</div><div class="line">  where id=#&#123;id&#125;</div><div class="line">&lt;/update&gt;</div></pre></td></tr></table></figure></p>
<p>这里，<code>set</code>会动态前置<code>set</code>，并忽略无关的逗号。</p>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>主要用于对集合的遍历:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</div><div class="line">  SELECT *</div><div class="line">  FROM POST P</div><div class="line">  WHERE ID in</div><div class="line">  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;mylist&quot;</div><div class="line">      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</div><div class="line">        #&#123;item&#125;</div><div class="line">  &lt;/foreach&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>其中item为每次迭代取到的值，index为迭代次数。<br>当collection是map时，index是键。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code>元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;</div><div class="line">  &lt;bind name=&quot;pattern&quot; value=&quot;&apos;%&apos; + _parameter.getTitle() + &apos;%&apos;&quot; /&gt;</div><div class="line">  SELECT * FROM BLOG</div><div class="line">  WHERE title LIKE #&#123;pattern&#125;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<h2 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;insert id=&quot;insert&quot;&gt;</div><div class="line">  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;</div><div class="line">    &lt;if test=&quot;_databaseId == &apos;oracle&apos;&quot;&gt;</div><div class="line">      select seq_users.nextval from dual</div><div class="line">    &lt;/if&gt;</div><div class="line">    &lt;if test=&quot;_databaseId == &apos;db2&apos;&quot;&gt;</div><div class="line">      select nextval for seq_users from sysibm.sysdummy1&quot;</div><div class="line">    &lt;/if&gt;</div><div class="line">  &lt;/selectKey&gt;</div><div class="line">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</div><div class="line">&lt;/insert&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Mybatis另一个重要的特性就是动态SQL，利用这一特性，可以简化Java代码。&lt;br&gt;Mybatis的动态SQL主要包含以下几种语句：&lt;
    
    </summary>
    
    
      <category term="Mybatis" scheme="http://chenpeng89.github.io/tags/Mybatis/"/>
    
  </entry>
  
</feed>
