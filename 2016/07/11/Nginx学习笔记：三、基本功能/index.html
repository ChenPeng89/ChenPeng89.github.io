<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Nginx," />





  <link rel="alternate" href="/atom.xml" title="ChenPeng's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Web服务设置虚拟服务器nginx配置文件中至少需要一个定义了虚拟服务器的server块。当nginx处理请求时，它会首先选择虚拟服务器来处理请求。虚拟服务器定义在http上下文的server块中。12345http &amp;#123;    server &amp;#123;        # Server configuration    &amp;#125;&amp;#125;
可以在http上下文中定义多个server">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx学习笔记：三、基本功能">
<meta property="og:url" content="http://chenpeng89.github.io/2016/07/11/Nginx学习笔记：三、基本功能/index.html">
<meta property="og:site_name" content="ChenPeng's Blog">
<meta property="og:description" content="Web服务设置虚拟服务器nginx配置文件中至少需要一个定义了虚拟服务器的server块。当nginx处理请求时，它会首先选择虚拟服务器来处理请求。虚拟服务器定义在http上下文的server块中。12345http &amp;#123;    server &amp;#123;        # Server configuration    &amp;#125;&amp;#125;
可以在http上下文中定义多个server">
<meta property="og:updated_time" content="2016-09-20T03:12:17.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nginx学习笔记：三、基本功能">
<meta name="twitter:description" content="Web服务设置虚拟服务器nginx配置文件中至少需要一个定义了虚拟服务器的server块。当nginx处理请求时，它会首先选择虚拟服务器来处理请求。虚拟服务器定义在http上下文的server块中。12345http &amp;#123;    server &amp;#123;        # Server configuration    &amp;#125;&amp;#125;
可以在http上下文中定义多个server">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6332319628039030000,
      author: '����'
    }
  };
</script>

  <title> Nginx学习笔记：三、基本功能 | ChenPeng's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ChenPeng's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Nginx学习笔记：三、基本功能
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-11T15:59:00+08:00" content="2016-07-11">
              2016-07-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><h3 id="设置虚拟服务器"><a href="#设置虚拟服务器" class="headerlink" title="设置虚拟服务器"></a>设置虚拟服务器</h3><p>nginx配置文件中至少需要一个定义了虚拟服务器的server块。当nginx处理请求时，它会首先选择虚拟服务器来处理请求。<br>虚拟服务器定义在http上下文的server块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        # Server configuration</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以在http上下文中定义多个server块。<br>server块通常包含一个listen指令来监听指定的ip的端口。支持ipv4/ipv6，ipv6的地址需要用（）包裹起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 127.0.0.1:8080;</div><div class="line">    # The rest of server configuration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果省略端口号，则使用标准端口号。如果省略ip，那么服务器将监听所有地址。如果省略listen指令，那么标准的端口号是80/tcp，默认的端口号是8000/tcp这取决于root的权限。</p>
<p>server_name 参数用来指定接受访问的host头中的相应参数。它的值可以是一个通配符。如果没有匹配的，那么将路由到默认的服务器上来处理。</p>
<h3 id="配置location"><a href="#配置location" class="headerlink" title="配置location"></a>配置location</h3><p>nginx可以将请求路由到不同的代理或者服务器上，基于请求的uri。这些都是依靠定义在server块中的localtion块来决定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    root html;</div><div class="line">    index  index.html  index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有两种类型的参数：前缀字符串和正则表达式。对于一个请求URI，他必须满足匹配前缀字符串。</p>
<p>正则表达式前面增加 ~ 表示区分大小写，~* 表示不区分大小写。下面的例子匹配所有带有.html或者.htm的URI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location ~ \.html? &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>为了找到最匹配URI的location，nginx会首先搜索前缀字符串，然后再搜索正则表达式。</strong></p>
<p>nginx的处理逻辑为：</p>
<ol>
<li>尝试匹配所有前缀字符串。</li>
<li>= 修饰符定义了一个URI和前缀字符串的精确匹配。如果发现精确匹配,搜索停止。</li>
<li>如果有^~修饰符，则最先考虑最长前缀字符串匹配,正则表达式不检查。</li>
<li>存储最长前缀匹配字符串。</li>
<li>尝试匹配正则表达式。</li>
<li>从第一个匹配的正则表达式跳出递归，并使用相应的location。</li>
<li>如果没有匹配的正则表达式，使用存储的最长匹配的前缀表达式（第4步）的location。</li>
</ol>
<p>location块中包含如何处理的逻辑，要么转到一个静态文件，要么将请求转给一个代理服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    location /images/ &#123;</div><div class="line">        root /data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://www.example.com;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>nginx允许在配置文件中使用自定义的变量。<br><code>set $variable value</code><br><code>map string $variable { ... }</code><br><code>geo [$address] $variable { ... }</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line"> geo $arg_boy $ttlsa_com &#123;</div><div class="line">        default 0;</div><div class="line">        127.0.0.1/24 24;</div><div class="line">        127.0.0.1/32 32;</div><div class="line">        8.8.8.8 2;</div><div class="line">&#125;</div><div class="line"> server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  test.ttlsa.com;</div><div class="line"> </div><div class="line">        location /hello &#123;</div><div class="line"> default_type text/plain;</div><div class="line"> echo $ttlsa_com;</div><div class="line"> echo $arg_boy;</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"># curl 127.0.0.1:8080/hello?boy=127.0.0.1</div><div class="line">32</div><div class="line">127.0.0.1</div><div class="line"># curl 127.0.0.1:8080/hello?boy=127.0.0.12</div><div class="line">24</div><div class="line">127.0.0.12</div></pre></td></tr></table></figure>
<h3 id="返回指定状态码"><a href="#返回指定状态码" class="headerlink" title="返回指定状态码"></a>返回指定状态码</h3><p>一些网站URI需要立即返回指定的错误代码或重定向代码，例如，如果一个页面被暂时或永久的移除，那么，最简单的方法是直接返回相应的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /wrong/url &#123;</div><div class="line">    return 404;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>return 的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">return code [text];</div><div class="line">return code URL;</div><div class="line">return URL;</div></pre></td></tr></table></figure></p>
<p>return 指令可以存在于location和server块中。</p>
<h3 id="重写URI请求"><a href="#重写URI请求" class="headerlink" title="重写URI请求"></a>重写URI请求</h3><p>一个请求的URI可以在处理请求过程中被重写多次，它包括一个可选的和两个必须的参数。第一个必须的参数是请求URI必须满足的正则表达式。第二个参数是用来替换请求URI的URI。可选的参数是一个标志位，它能停止进一步的重写处理或者发送重定向（301或302）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /users/ &#123;</div><div class="line">    rewrite ^/users/(.*)$ /show?user=$1 break;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>rewrite指令可以存在于server和location块中。在server块中，如果server的上下文被选中，那么server块中的rewrite只会执行一次。</p>
<p>rewrite指令用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rewrite regex replacement [flag];</div></pre></td></tr></table></figure></p>
<p>flag 有以下可选值：<br>last: 重新请求搜索是否还有匹配的locaton。<br>break: 不再搜索是否还有匹配的location。<br>redirect：返回一个暂时的重定向代码 ， 302，使用一个不以”<a href="http://&quot;或&quot;https://&quot;开头的代替的字符串。" target="_blank" rel="external">http://&quot;或&quot;https://&quot;开头的代替的字符串。</a><br>permanent： 返回一个永久的重定向代码，301.</p>
<h3 id="重写HTTP返回"><a href="#重写HTTP返回" class="headerlink" title="重写HTTP返回"></a>重写HTTP返回</h3><p>有时候你需要重写或者修改HTTP返回中的内容，把一个字符串替换成其它的。那么，你需要使用sub_filter指令来定义重写。这个指令支持变量和链操作来使复杂的操作变得简单。<br>sub_filter的替换匹配是不区分大小写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  www.github.com;</div><div class="line"> </div><div class="line">    root /data/site/www.github.com;    </div><div class="line"> </div><div class="line">    location / &#123;</div><div class="line">        sub_filter  github &apos;GIT&apos;;</div><div class="line">        sub_filter_types text/html;</div><div class="line">        sub_filter_once on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子将返回数据中的github替换为GIT，然后由于sub_filter_once on ， 所以只替换了一次。结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># curl www.github.com/2013/10/20131001_sub1.html           </div><div class="line">welcome to GIT!</div><div class="line">github TEAM!</div></pre></td></tr></table></figure></p>
<p>sub_filter 可以存在于 http, server, location 块。</p>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>使用error_page 指令，可以为特定的错误码自定义错误页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_page 404 /404.html;</div></pre></td></tr></table></figure></p>
<p>下面的例子中，将404转换为301，并重定向到http:/example.com/new/path.html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /old/path.html &#123;</div><div class="line">    error_page 404 =301 http:/example.com/new/path.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h2><h3 id="Root目录和索引文件"><a href="#Root目录和索引文件" class="headerlink" title="Root目录和索引文件"></a>Root目录和索引文件</h3><p>root指令制定了将要去搜索文件的根目录。为了获得文件路径，nginx为请求的URI添加了指定的root路径。root指令可以在http、server和location块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    root /www/data;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /images/ &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location ~ \.(mp3|mp4) &#123;</div><div class="line">        root /www/media;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子中，如果URI以/images/开始，那么，搜索的路径为/www/data/images/目录。如果URI以.mp3或者.mp4结尾，那么搜索的路径为/www/media/。</p>
<p>如果请求是以/结尾，那么，nginx将其认为是请求目录结构并查找目录里面的索引文件。index命令定义了索引文件名（默认名称为index.html）。接着上面的例子，如果请求是 /images/some/path/ ， nginx将传送文件/www/data/images/some/path/index.html，如果存在的话。如果不存在，nginx返回404。为了让NGINX返回一个自动生成的目录清单,加入autoindex指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /images/ &#123;</div><div class="line">    autoindex on;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以列举不只一个文件名在index指令下。nginx以指定的顺序搜索文件并返回第一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    index index.$geo.html index.htm index.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的$geo变量是一个自定义的geo。它的值取决于客户端的ip地址。</p>
<p>autoindex_exact_size on | off 表示是否显示大小。<br>autoindex_format html | xml | json | jsonp 输出格式<br>autoindex_localtime on | off  显示本地时间或UTC</p>
<h3 id="其它的命令"><a href="#其它的命令" class="headerlink" title="其它的命令"></a>其它的命令</h3><p>try_files 用来检查指定的文件或者目录是否存在，并设置一个重定向或者返回一个指定的状态码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    root /www/data;</div><div class="line"></div><div class="line">    location /images/ &#123;</div><div class="line">        try_files $uri /images/default.gif;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后一个参数可以是状态码或者位置。在下面的例子中，如果try_files的参数中的文件或目录不存在，则返回404。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    try_files $uri $uri/ $uri.html =404;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在下面的例子中，如果原始的URI和URI后面加上/的目录均不存在，那么请求会被重定向到一个代理服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    try_files $uri $uri/ @backend;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location @backend &#123;</div><div class="line">    proxy_pass http://backend.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提高nginx内容服务速度"><a href="#提高nginx内容服务速度" class="headerlink" title="提高nginx内容服务速度"></a>提高nginx内容服务速度</h3><p>加载速度是重要的考虑因素。做一些小幅的优化配置可能会大幅提高效率甚至达到最佳性能。</p>
<ul>
<li><p>开启sendfile<br>默认情况下，nginx自己控制文件传输，并在发送前把它拷贝到buffer中。使用sendfile命令可以减少拷贝到buffer的步骤，并且直接将一个文件描述符拷贝到另一个。另外,防止一个快速连接完全占用worker进程,可以在sendfile()调用sendfile_max_chunk指令限制传输的数据量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3 &#123;</div><div class="line">    sendfile           on;</div><div class="line">    sendfile_max_chunk 1m;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>开启tcp_nopush<br>配合sendfile一起使用tcp_nopush。一般情况下，在tcp交互的过程中，当应用程序接收到数据包后马上传送出去，不等待，而tcp_cork选项是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞，已经是默认了,tcp_nopush = on 会设置调用tcp_cork方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3 &#123;</div><div class="line">    sendfile   on;</div><div class="line">    tcp_nopush on;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>开启tcp_nodelay<br>与tcp_nopush 是互斥的，有数据的话会立即将数据包发送出去，有可能会造成网络拥堵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3  &#123;</div><div class="line">    tcp_nodelay       on;</div><div class="line">    keepalive_timeout 65;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>优化Backlog Queue<br>nginx处理连接请求也是一个非常重要的优化点。一般情况下，当一个连接建立后，它会被放入listen socket的listen队列。在普通负载下，这是一个小的甚至不存在的队列。但是高负载时，队列会显著增长，这可能导致连接断开或者高延迟。<br><strong>检查listen queue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -lan</div></pre></td></tr></table></figure>
</li>
</ul>
<p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Current listen queue sizes (qlen/incqlen/maxqlen)</div><div class="line">Listen         Local Address         </div><div class="line">0/0/128        *.12345            </div><div class="line">10/0/128        *.80       </div><div class="line">0/0/128        *.8080</div></pre></td></tr></table></figure></p>
<p>说明有10个在80端口的连接未被处理。<br><strong>设置OS</strong><br>设置 net.core.somaxconn 来增大OS的负载能力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vi   /etc/sysctl.conf</div><div class="line">net.core.somaxconn = 4096</div></pre></td></tr></table></figure></p>
<p><strong>设置nginx</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80 backlog 4096;</div><div class="line">    # The rest of server configuration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="发送请求到代理服务器"><a href="#发送请求到代理服务器" class="headerlink" title="发送请求到代理服务器"></a>发送请求到代理服务器</h3><p>当使用nginx代理时，会发送请求到代理服务器，获取相应，然后返回给客户端。它可以代理HTTP请求也可以代理非HTTP请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_pass http://www.example.com/link/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="发送请求头到代理服务器"><a href="#发送请求头到代理服务器" class="headerlink" title="发送请求头到代理服务器"></a>发送请求头到代理服务器</h3><p>默认情况下，nginx会重新定义请求头中的两个域，Host和Connection，Host被设置为$proxy_host变量，Connection被设置为 close。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>防止某个域传递到代理服务器，可以将其设置为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_set_header Accept-Encoding &quot;&quot;;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="设置Buffer"><a href="#设置Buffer" class="headerlink" title="设置Buffer"></a>设置Buffer</h3><p>一般情况下，nginx缓冲代理服务器的相应，直到收到整个相应信息才发送给客户端。缓冲机制能够优化慢客户端，因为如果对于慢客户端nginx同步响应，那么会浪费代理服务器时间。<br><strong>proxy_buffering</strong>，该指令设置缓冲区的大小和数量,从被代理的后端服务器取得的响应内容,会放置到这里. 默认情况下,一个缓冲区的大小等于内存页面大小,可能是4K也可能是8K,这取决于平台。proxy_buffers 8  4k/8k。<br><strong>proxy_buffer_size</strong>，该指令设置缓冲区大小,从代理后端服务器取得的第一部分的响应内容,会放到这里.小的响应header通常位于这部分响应内容里边.默认来说,该缓冲区大小等于指令 proxy_buffers所设置的;但是,你可以把它设置得更小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_buffers 16 4k;</div><div class="line">    proxy_buffer_size 2k;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果关闭buffer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_buffering off;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="绑定出口IP"><a href="#绑定出口IP" class="headerlink" title="绑定出口IP"></a>绑定出口IP</h3><p>如果你的代理服务器有多个网络接口，有时需要选择其中一个进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">location /app1/ &#123;</div><div class="line">    proxy_bind 127.0.0.1;</div><div class="line">    proxy_pass http://example.com/app1/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /app2/ &#123;</div><div class="line">    proxy_bind 127.0.0.2;</div><div class="line">    proxy_pass http://example.com/app2/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /app3/ &#123;</div><div class="line">    proxy_bind $server_addr;</div><div class="line">    proxy_pass http://example.com/app3/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h2><p>亚索形影数据对于减小传输数据是非常重要的。然而，在运行时进行压缩还有可能对系统有负面影响。nginx在发送相应数据前进行压缩，但是不会对已经压缩过的数据进行二次压缩（例如，对于代理服务器的）。</p>
<h3 id="开启压缩"><a href="#开启压缩" class="headerlink" title="开启压缩"></a>开启压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip on;</div></pre></td></tr></table></figure>
<p>通常情况下，nginx仅对MIME类型为text/html的相应进行压缩。为了添加压缩的类型，可以使用gzip_types命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_types text/plain application/xml;</div></pre></td></tr></table></figure></p>
<p>指定压缩响应的最小长度，使用gzip_min_length指令。默认是20bytes。（这里设置为1000）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_min_length 1000;</div></pre></td></tr></table></figure></p>
<p>一般情况下，nginx不会压缩代理服务器的请求响应。该请求来自代理服务器的事实是由Via头字段的请求中的存在来确定。使用gzip_proxied指令来配置这些响应的压缩。这个指令有很多参数，来确定哪种代理请求nginx需要压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_proxied no-cache no-store private expired auth;</div></pre></td></tr></table></figure></p>
<p>一个完整的例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    gzip on;</div><div class="line">    gzip_types      text/plain application/xml;</div><div class="line">    gzip_proxied    no-cache no-store private expired auth;</div><div class="line">    gzip_min_length 1000;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="开启解压缩"><a href="#开启解压缩" class="headerlink" title="开启解压缩"></a>开启解压缩</h3><p>一些客户端不支持gzip编码算法。同时，它又想要存储压缩数据或者压缩相应数据并存入缓存。为了成功发送到客户端，nginx支持在发送到最终客户端时解压缩数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /storage/ &#123;</div><div class="line">    gunzip on;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="发送压缩文件"><a href="#发送压缩文件" class="headerlink" title="发送压缩文件"></a>发送压缩文件</h3><p>使用gzip_static 命令可以发送一个压缩版本的文件到客户端，若要使用它需要在编译的时候把gzip_static模块编译进去：<br><code>./configure --with-http_gzip_static_module</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    gzip_static on;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当请求 /path/to/file，nginx会查找并发送/path/to/file.gz。如果文件不存在或者客户端不支持gzip，nginx会发送未压缩版本。<br>注意，gzip_static指令不支持实时压缩。它只是使用压缩工具预先压缩文件。要压缩在运行时的内容（不仅是静态内容），使用gzip的指令。</p>
<h2 id="页面内容缓存"><a href="#页面内容缓存" class="headerlink" title="页面内容缓存"></a>页面内容缓存</h2><p>nginx支持缓存，当开启缓存后，nginx缓存从代理服务器返回的数据，并将其缓存到硬盘上，当有请求过来时，先去缓存查找响应。</p>
<h3 id="开启响应缓存"><a href="#开启响应缓存" class="headerlink" title="开启响应缓存"></a>开启响应缓存</h3><p>将 proxy_cache_path 放到http块中来开启缓存。第一个参数是存放缓存文件的路径。keys_zone定义了用于存储缓存条目元数据的共享存储空间名称和大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache keys_zone=one:10m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将proxy_cache放入想进行缓存的协议类型、server块或者location块中。并指定proxy_cache_path中的key_zone。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache keys_zone=one:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        proxy_cache one;</div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://localhost:8000;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，key_zone定义的大小并不限制缓存相应数据的总量。缓存的响应数据本身存储为元数据的一个备份，存在指定的file上。为了限制缓存的数量，可以使用proxy_cache_path的max_size参数，缓存数量可以暂时超过max_size。</p>
<h3 id="控制缓存"><a href="#控制缓存" class="headerlink" title="控制缓存"></a>控制缓存</h3><p>缓存管理器会定期检查缓存的状态。如果缓存大小超过proxy_cache_path中 max_size参数设定的限制,缓存管理器删除最近最少访问的数据。正如前面提到的,缓存数据的数量可以暂时超过限制缓存管理器激活的时间期间。<br>缓存加载器仅会在nginx启动后启动一次。它会将之前缓存的数据加载进来。加载一次缓存可能会消耗大量资源，影响nginx启动后几分钟内的性能。下面有proxy_cacahe_path的几个参数来避免这一情况：</p>
<ul>
<li>loader_threshold ： 加载时间上限，单位是毫秒，默认为200毫秒。</li>
<li>loader_files： 一次迭代的最多条目数，默认是100。</li>
<li>loader_sleeps ： 迭代的间隔，单位是毫秒，默认50。</li>
</ul>
<p><code>proxy_cache_path /data/nginx/cache keys_zone=one:10m loader_threshold=300 loader_files=200;</code></p>
<h3 id="指定对哪个请求进行缓存"><a href="#指定对哪个请求进行缓存" class="headerlink" title="指定对哪个请求进行缓存"></a>指定对哪个请求进行缓存</h3><p>一般情况下，nginx缓存http的get和head方法响应的数据。nginx将请求字符串作为请求的key。如果缓存中存在和请求相同的key，nginx会直接用缓存来响应。可以在http，server，location的上下文中控制哪些进行缓存。</p>
<p>为了改变请求的单词来计算key，可以使用proxy_cache_key:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_key &quot;$host$request_uri$cookie_user&quot;;</div></pre></td></tr></table></figure></p>
<p>定义在必须在请求指定的最低次数以后，响应才会被缓存起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_min_uses 5;</div></pre></td></tr></table></figure></p>
<p>缓存除了GET和HEAD的其他请求，get和head也需要被列举出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_methods GET HEAD POST;</div></pre></td></tr></table></figure></p>
<h3 id="限制或绕过缓存"><a href="#限制或绕过缓存" class="headerlink" title="限制或绕过缓存"></a>限制或绕过缓存</h3><p>默认情况下，响应数据会一直在缓存中。它们只有在缓存超过最大值时，并且它们是最少命中的，才会被淘汰。nginx可以设置淘汰策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_cache_valid 200 302 10m;</div><div class="line">proxy_cache_valid 404      1m;</div></pre></td></tr></table></figure></p>
<p>上面的例子中，返回200或者302都被认为是在10分钟以内有效的。返货404在1分钟以内也是有效的。也可以使用<code>any</code>来设置第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_valid any 5m;</div></pre></td></tr></table></figure></p>
<p>可以定义proxy_cache_bypass指令来决定是否使用cache响应请求。每个参数定义了一个条件并且由变量组成。如果至少有一个参数为空并且不等于0，nginx不会从cache查找响应，会直接去后端服务器请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;</div></pre></td></tr></table></figure></p>
<p><code>proxy_cache_bypass string ...;</code></p>
<p>控制哪些请求不进行缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_no_cache $http_pragma $http_authorization;</div></pre></td></tr></table></figure></p>
<h3 id="从缓存中清除内容"><a href="#从缓存中清除内容" class="headerlink" title="从缓存中清除内容"></a>从缓存中清除内容</h3><p>NGINX可以从缓存中删除过期的缓存文件。这是非常必要的,删除过期的缓存内容,防止同时提供新老版本的web页面。清除缓存时，nginx会收到一个特别的“清除”请求包含一个自定义HTTP头,或“清除”的HTTP方法。</p>
<ul>
<li>配置缓存清除<br>下面配置一个清除的HTTP方法并删除匹配的URL。<br>在http块中，新建一个变量，如下面的 $purge_method ， 它依赖于$request_method变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">        PURGE 1;</div><div class="line">        default 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在location块中已经定义了cache，在 proxy_cache_purge 指令中，指定了会被清除cache的条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen      80;</div><div class="line">    server_name www.example.com;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass  https://localhost:8002;</div><div class="line">        proxy_cache mycache;</div><div class="line"></div><div class="line">        proxy_cache_purge $purge_method;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当 $request_method 为PURGE，则清除。否则不清除。</p>
<ul>
<li>发送清除指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -X PURGE -D – &quot;https://www.example.com/*&quot;</div><div class="line">HTTP/1.1 204 No Content</div><div class="line">Server: nginx/1.5.7</div><div class="line">Date: Sat, 01 Dec 2015 16:33:04 GMT</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上例中，指定的URI中的缓存文件并不删除，它们还会继续存储在磁盘上，直到nginx来操作处理。</p>
<ul>
<li><p>限制访问清除指令<br>比较推荐的是通过设置IP白名单来限制访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">geo $purge_allowed &#123;</div><div class="line">   default         0;  # deny from other</div><div class="line">   10.0.0.1        1;  # allow from localhost</div><div class="line">   192.168.0.0/24  1;  # allow from 10.0.0.0/24</div><div class="line">&#125;</div><div class="line"></div><div class="line">map $request_method $purge_method &#123;</div><div class="line">   PURGE   $purge_allowed;</div><div class="line">   default 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>完全删除cache文件<br><code>proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=mycache:10m purger=on;</code><br>在 proxy_cache_path 加上 purger=on参数。</p>
</li>
<li>完整的例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=mycache:10m purger=on;</div><div class="line"></div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">        PURGE 1;</div><div class="line">        default 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      80;</div><div class="line">        server_name www.example.com;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass        https://localhost:8002;</div><div class="line">            proxy_cache       mycache;</div><div class="line">            proxy_cache_purge $purge_method;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    geo $purge_allowed &#123;</div><div class="line">       default         0;</div><div class="line">       10.0.0.1        1;</div><div class="line">       192.168.0.0/24  1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">       PURGE   $purge_allowed;</div><div class="line">       default 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Byte范围的缓存"><a href="#Byte范围的缓存" class="headerlink" title="Byte范围的缓存"></a>Byte范围的缓存</h3><p>有时候，将数据放入缓存中是一个很费时的操作，特别是大文件。当第一次请求开始下载一个大文件时，下一次请求必须等待整个文件下载并放入缓存后才能被服务。<br>nginx可以使用cache slice module 来处理。文件被分成较小的“片”。每个请求范围选择特定的片,如果这个范围没有被缓存,那么将会把它放到缓存中。然后其它所有请求这个片数据的请求都会被这个缓存响应。<br>开启范围级别的缓存：</p>
<ol>
<li>为nginx编译进slice模块。</li>
<li><p>指定每个片的大小。片大小应足以使切片快速下载。设置太小可能会导致过度的内存使用和大量的文件描述符,过大的值可能会导致延迟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    slice  1m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在cache key中加入$slice_range<br><code>proxy_cache_key $uri$is_args$args$slice_range;</code></p>
</li>
<li>开启响应的206代码<br><code>proxy_cache_valid 200 206 1h;</code></li>
<li>在发往代理服务器的HTTP头的Range里面加入$slice_range。<br><code>proxy_set_header  Range $slice_range;</code></li>
<li>综合样例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    slice             1m;</div><div class="line">    proxy_cache       cache;</div><div class="line">    proxy_cache_key   $uri$is_args$args$slice_range;</div><div class="line">    proxy_set_header  Range $slice_range;</div><div class="line">    proxy_cache_valid 200 206 1h;</div><div class="line">    proxy_pass        http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Nginx/" rel="tag">#Nginx</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/11/Nginx学习笔记：二、进程和运行时/" rel="next" title="Nginx学习笔记：二、进程和运行时">
                <i class="fa fa-chevron-left"></i> Nginx学习笔记：二、进程和运行时
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/18/Nginx学习笔记：四、配置SSL/" rel="prev" title="Nginx学习笔记：四、配置SSL">
                Nginx学习笔记：四、配置SSL <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="ChenPeng" />
          <p class="site-author-name" itemprop="name">ChenPeng</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/chenpeng89" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Web服务"><span class="nav-number">1.</span> <span class="nav-text">Web服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置虚拟服务器"><span class="nav-number">1.1.</span> <span class="nav-text">设置虚拟服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置location"><span class="nav-number">1.2.</span> <span class="nav-text">配置location</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用变量"><span class="nav-number">1.3.</span> <span class="nav-text">使用变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回指定状态码"><span class="nav-number">1.4.</span> <span class="nav-text">返回指定状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写URI请求"><span class="nav-number">1.5.</span> <span class="nav-text">重写URI请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写HTTP返回"><span class="nav-number">1.6.</span> <span class="nav-text">重写HTTP返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理异常"><span class="nav-number">1.7.</span> <span class="nav-text">处理异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态文件服务"><span class="nav-number">2.</span> <span class="nav-text">静态文件服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Root目录和索引文件"><span class="nav-number">2.1.</span> <span class="nav-text">Root目录和索引文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它的命令"><span class="nav-number">2.2.</span> <span class="nav-text">其它的命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提高nginx内容服务速度"><span class="nav-number">2.3.</span> <span class="nav-text">提高nginx内容服务速度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反向代理"><span class="nav-number">3.</span> <span class="nav-text">反向代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送请求到代理服务器"><span class="nav-number">3.1.</span> <span class="nav-text">发送请求到代理服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送请求头到代理服务器"><span class="nav-number">3.2.</span> <span class="nav-text">发送请求头到代理服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置Buffer"><span class="nav-number">3.3.</span> <span class="nav-text">设置Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定出口IP"><span class="nav-number">3.4.</span> <span class="nav-text">绑定出口IP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩和解压缩"><span class="nav-number">4.</span> <span class="nav-text">压缩和解压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开启压缩"><span class="nav-number">4.1.</span> <span class="nav-text">开启压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开启解压缩"><span class="nav-number">4.2.</span> <span class="nav-text">开启解压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送压缩文件"><span class="nav-number">4.3.</span> <span class="nav-text">发送压缩文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面内容缓存"><span class="nav-number">5.</span> <span class="nav-text">页面内容缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开启响应缓存"><span class="nav-number">5.1.</span> <span class="nav-text">开启响应缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制缓存"><span class="nav-number">5.2.</span> <span class="nav-text">控制缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定对哪个请求进行缓存"><span class="nav-number">5.3.</span> <span class="nav-text">指定对哪个请求进行缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制或绕过缓存"><span class="nav-number">5.4.</span> <span class="nav-text">限制或绕过缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从缓存中清除内容"><span class="nav-number">5.5.</span> <span class="nav-text">从缓存中清除内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Byte范围的缓存"><span class="nav-number">5.6.</span> <span class="nav-text">Byte范围的缓存</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChenPeng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
