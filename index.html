<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="ChenPeng's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="ChenPeng's Blog">
<meta property="og:url" content="http://chenpeng89.github.io/index.html">
<meta property="og:site_name" content="ChenPeng's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ChenPeng's Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6332319628039030000,
      author: '����'
    }
  };
</script>

  <title> ChenPeng's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ChenPeng's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/22/Elasticsearch学习笔记：三、Document-APIs/" itemprop="url">
                  Elasticsearch学习笔记：三、Document APIs
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-22T14:02:30+08:00" content="2016-09-22">
              2016-09-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h2><p>index API 用来向指定的index添加或更新JSON文档，并使它可被搜索。下面的例子是在名为 twitter 的index中添加一个文档，type为tweet，id=1 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 3,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，_shards段中提供了以下信息：</p>
<ul>
<li>total - 多少个分片及其备份要被操作。</li>
<li>successful - 说明分片及其备份成功了几个。</li>
<li>failures - 一个包含了失败分片及失败原因的数组。</li>
</ul>
<h3 id="自动创建Index"><a href="#自动创建Index" class="headerlink" title="自动创建Index"></a>自动创建Index</h3><p>如果实现没创建index，那么在上面的操作中会自动创建相应的index，如果没创建type，也会为指定的type自动创建一个动态type映射。</p>
<p>这个映射非常灵活，并且模式自由。新的字段和对象会自动的被添加到指定类型的映射定义中去。</p>
<p>自动创建index可以被关闭，在节点配置文件中将 action.auto_create_index 设为 false 就可以了。自动创建type映射也可以关闭，将 index.mapper.dynamic 设为 false就可以了。</p>
<p>自动创建index也可以设置黑白名单，例如，设置 action.auto_create_index 为 +aaa*,-bbb*,+ccc*,-* ， 名字为 aaa*的是可以创建的，为 bbb*的是被禁止的，以此类推。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>每个被index的文档都会有一个版本号。version 字段会在查询时返回给客户端。如果指定了版本号，可使用它做一个乐观锁。可以使用版本号进行一个read-then-update的事务处理。在读的时候指定文档的版本号可以确保期间文档不会发生变化。如果是读而不是更新操作，可以设置为preference 来替代 _primary。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/twitter/tweet/1?version=2&apos; -d &apos;&#123;</div><div class="line">    &quot;message&quot; : &quot;elasticsearch now has versioning support, double cool!&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>注意：版本操作是实时的，而且不被搜索操作的接近实时所影响。如果没设置版本号，接下来的操作将不会检查版本号。</p>
<p>默认情况下，内部的版本号会从1开始，然后随着每次更新增加。版本号也可以由外部提供。如果要开启外部版本号，需要将version_type设置为external。当设置为版本号为外部版本号时，系统不会检查版本号是否相等，而是当传入的版本号是否大于当前版本号，如果大于，则更新，如果等于或小于，则更新失败。</p>
<h4 id="版本号类型"><a href="#版本号类型" class="headerlink" title="版本号类型"></a>版本号类型</h4><p>除了上面所说的内部和外部版本号类型，es还提供了一些特殊的版本号类型：</p>
<ul>
<li>internal<br>只有在传入的版本号和系统中当前版本号相等时才更新索引。</li>
<li>external 或 external_gt<br>只有在传入的版本号大于系统当前版本号 或者 要更新的文档不存在的时候，才会更新索引。传入的版本号将作为新的版本号，并且会存储新的文档。版本号必须为一个非负的long型。</li>
<li>external_gte<br>和上面唯一不同的是，如果传入的版本号等于当前版本号也可以更新索引。</li>
<li>force<br>无视版本号或者文档是否存在，都直接更新。且传入的版本号作为新的版本号，并会存储新的文档。一般用于改正错误数据。</li>
</ul>
<h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><p>index操作也允许传入 on_type 参数来强制进行 create 操作。当设置为create，如果文档已经存在，index操作将会失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1?op_type=create&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>如果失败，会返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;error&quot;: &#123;</div><div class="line">    &quot;root_cause&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;type&quot;: &quot;document_already_exists_exception&quot;,</div><div class="line">        &quot;reason&quot;: &quot;[tweet][1]: document already exists&quot;,</div><div class="line">        &quot;index&quot;: &quot;twitter&quot;,</div><div class="line">        &quot;shard&quot;: &quot;0&quot;</div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    &quot;type&quot;: &quot;document_already_exists_exception&quot;,</div><div class="line">    &quot;reason&quot;: &quot;[tweet][1]: document already exists&quot;,</div><div class="line">    &quot;index&quot;: &quot;twitter&quot;,</div><div class="line">    &quot;shard&quot;: &quot;0&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;status&quot;: 409</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种指定 create 的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1/_create&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="自动生成ID"><a href="#自动生成ID" class="headerlink" title="自动生成ID"></a>自动生成ID</h3><p>index的操作可以不指定id。id可以自动生成。op_type会自动设置为create。注意，此处用的是POST而不是PUT：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPOST &apos;http://localhost:9200/twitter/tweet/&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;AVdQyYB5e-yIFmSuoS-f&quot;,</div><div class="line">  &quot;_version&quot;: 1,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><p>一般情况下，shard的位置是由id的hash来控制的。为了更精确地控制，可以直接在每次操作上指定用于计算hash的值。使用 routing参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPOST &apos;http://localhost:9200/twitter/tweet?routing=kimchy&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>例如上面，就是使用kimchy来计算分片hash，来决定这个文档存放在哪个shard中。</p>
<p>当显示设置了_routing字段，并设置为required，如果index操作中没传递这个参数，将会操作失败。</p>
<h3 id="Parent-amp-Children"><a href="#Parent-amp-Children" class="headerlink" title="Parent &amp; Children"></a>Parent &amp; Children</h3><p>可以在index操作时指定parent：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT localhost:9200/blogs/blog_tag/1122?parent=1111 -d &apos;&#123;</div><div class="line">    &quot;tag&quot; : &quot;something&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>当index一个child文档，routing的值会自动设置为何它parent的一致，除非显式指定child的routing。</p>
<h3 id="写一致性"><a href="#写一致性" class="headerlink" title="写一致性"></a>写一致性</h3><p>默认情况下，对index的操作只有在超过半数的分片可用的情况下（quorum）才能成功返回。这个默认值可以通过 action.write_consistency参数来设置。如果想在每次操作时指定，可以使用请求参数 consistency 。参数有效值为one ， quorum和all。 index操作只有在复制组里面所有可用的分片都执行后才返回。</p>
<h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>想要在index操作后立即就能够查询到结果，需要设置refresh参数为true。将此选项设置为true应该在经过仔细思考和验证后,从索引和搜索的角度来看，它不会影响性能。注意，使用getAPI是实时的，不需要刷新。</p>
<h3 id="Noop-Updates"><a href="#Noop-Updates" class="headerlink" title="Noop Updates"></a>Noop Updates</h3><p>等待更新？。。。这个词不知道怎么翻译比较易懂。。。<br>当使用新的版本号进行index更新时，不管文档内容有没有变，都会创建一个新的文档。如果不能接受这样的操作，可以在使用_update api时将detect_noop设为true。这个选项不能用于index api因为index api不会获取旧的文档，因此，也就不会拿旧的和新的作比较。</p>
<h3 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h3><p>当进行index操作时，被安排用于index操作的shard可能暂时不可用。一些因素导致这个情形，比如正在搬迁或者网络异常。默认的，index操作将会等待shard一分钟，如果还不可用就会返回失败。timeout 参数可以用来显式设置等待多久：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT &apos;http://localhost:9200/twitter/tweet/1?timeout=5m&apos; -d &apos;&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>上例中，设置等待5分钟。</p>
<h2 id="Get-API"><a href="#Get-API" class="headerlink" title="Get API"></a>Get API</h2><p>get API 允许通过id来从index中查找相应的JSON文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://localhost:9200/twitter/tweet/1&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;twitter&quot;,</div><div class="line">  &quot;_type&quot;: &quot;tweet&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 5,</div><div class="line">  &quot;found&quot;: true,</div><div class="line">  &quot;_source&quot;: &#123;</div><div class="line">    &quot;user&quot;: &quot;kimchy&quot;,</div><div class="line">    &quot;postDate&quot;: &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot;: &quot;trying out Elasticsearch&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过HEAD来查询文档是否存在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XHEAD -i &apos;http://localhost:9200/twitter/tweet/1&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果可以通过 http status来判断，200 – 存在，404则不存在。</p>
<h3 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h3><p>一般来说，get API是实时的，它不会被index的刷新频率所影响（当数据变得可搜索后）。</p>
<p>为了关闭实时性，可以传入 realtime参数为false，或者全局设置 action.get.realtime为false。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/22/Elasticsearch学习笔记：二、基本设置/" itemprop="url">
                  Elasticsearch学习笔记：二、基本设置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-22T09:49:19+08:00" content="2016-09-22">
              2016-09-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="JAVA版本"><a href="#JAVA版本" class="headerlink" title="JAVA版本"></a>JAVA版本</h3><p>es是由java开发的，运行也需要java环境。需要保证jdk至少是1.7及以上的。且仅支持Oracle’sJava和OpenJDK。在es的所有节点和客户端中，jdk的版本号应该是一致的。<br>官方推荐安装jdk8 update20及以后或者jdk8 update 55及以后。之前的版本有bug因此会容易丢失数据。es也会自动判断，如果是不好的版本，它会拒绝启动。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="external">下载</a>最新的版本后，解压压缩包，然后就可以启动了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch</div></pre></td></tr></table></figure></p>
<h3 id="作为守护进程启动"><a href="#作为守护进程启动" class="headerlink" title="作为守护进程启动"></a>作为守护进程启动</h3><p>在*nix系统中，还可以作为守护进程启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch -d</div></pre></td></tr></table></figure></p>
<h3 id="指定PID"><a href="#指定PID" class="headerlink" title="指定PID"></a>指定PID</h3><p>为了维护方便，还可以指定es的pid:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch -d -p pid </div><div class="line">$ kill `cat pid`</div></pre></td></tr></table></figure></p>
<ul>
<li>PID应该被写在名为pid的文件中。</li>
<li>kill命令会发送一个term信号给pid文件中的PID。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>通过脚本，es可以向JVM传递JAVA_OPT参数。其中，最重要的参数是-Xms和-Xmx，它们用来控制进程的内存大小。<br>大多数情况下，最好用ES_JAVA_OPTS环境变量来替代JAVA_OPTS，这样可以不影响其它jvm项目的运行。<br>ES_HEAP_SIZE环境变量用来设置分配给esjava进程的堆内存大小。它会吧最大值和最小值设为同一个值。当然，也可以自己指定最大值和最小值，使用ES_MIN_MEM(默认是256m) 和 ES_MAX_MEM(默认是1G)。<br>值得推荐的做法是将最大值和最小值设为相同的值，并且开启mlockall（之后会有介绍）。</p>
<h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>确保要增加服务器中打开文件描述符的数量。设置为32K或者64是比较推荐的做法。<br>可以使用Nodes API查看文件描述符的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl localhost:9200/_nodes/stats/process?pretty</div></pre></td></tr></table></figure></p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>es默认使用 hybrid mmapfs / niofs 目录来存储index。默认情况下，os的限制的mmap数量可能过小，有可能会引起内存溢出。在Linux中，可以通过指令增加这个限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -w vm.max_map_count=262144</div></pre></td></tr></table></figure></p>
<p>或者为了让这个设置永久生效，可以在/etc/sysctl.conf设置vm.max_map_count 这个参数。</p>
<h4 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h4><p>大多数os会使用尽可能大的内存来做文件缓存，并将不用的应用程序内存换出，这就有可能将es的进程换出去了。换出这个动作对于es是非常影响效率的，并引起节点的不稳定，因此，应该尽量避免换出。<br>有以下三个解决方案：</p>
<ul>
<li><p>禁止换出<br>最简单的方案就是完全禁止换出操作。<br>在Linux系统中，如果暂时禁止换出，可以使用 sudo swapoff -a 命令。如果想永久生效，可以在 /etc/fstab 文件中将带有 swap的行通通注释掉。<br>在Windows中，可以通过 System Properties → Advanced → Performance → Advanced → Virtual memory 禁止分页文件来实现。</p>
</li>
<li><p>设置 swappiness<br>第二个方案是将sysctl 中 vm.swappiness设为0。这个操作会降低内核换出操作的频率。除非系统处于不得不换出的状态，一般情况下都不会执行换出操作。<br>注意，在内核版本 3.5-rc1及以上，swappiness为0会导致OOM杀掉进程而不是换出。你需要将swappiness设为1来允许在紧急情况下的换出。</p>
</li>
<li><p>mlockall<br>第三个方案是，在Linux中使用mlockall或者在Windows中使用VirtualLock，来锁住RAM中的进程地址空间，防止es内存被换出去，这个可以在 config/elasticsearch.yml 文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bootstrap.memory_lock: true</div></pre></td></tr></table></figure>
<p>在启动后，可以查看mlockall状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl http://localhost:9200/_nodes/process?pretty</div></pre></td></tr></table></figure>
<p>如果你看到mlockall是false，它意味着mlockall失败了。在Linuxl/Unix中，一般是因为es没有权限锁内存。这个在启动es前可以通过<code>ulimit -l unlimited as root</code> 来授权。<br>另一个可能的原因是临时目录（一般是/tmp）被安装了noexec 选项，这可以通过指定一个新的临时文件目录来解决:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/elasticsearch -Djna.tmpdir=/path/to/new/dir</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Elasticsearch设置"><a href="#Elasticsearch设置" class="headerlink" title="Elasticsearch设置"></a>Elasticsearch设置</h3><p>es配置文件可以在 ES_HOME/config 文件夹中找到。它包括两个文件，elasticsearch.yml 用于es的不同模块的设置，logging.yml 用于配置es的日志。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>在生产环境中，一般会设置两个路径来存储数据和日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">path:</div><div class="line">  logs: /var/log/elasticsearch</div><div class="line">  data: /var/data/elasticsearch</div></pre></td></tr></table></figure></p>
<h4 id="集群名称"><a href="#集群名称" class="headerlink" title="集群名称"></a>集群名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cluster:</div><div class="line">  name: &lt;NAME OF YOUR CLUSTER&gt;</div></pre></td></tr></table></figure>
<p>要保证你不会在不同的环境使用相同的集群名称，否则节点有可能加入到错误的集群中。你可以在生产环境用 logging-prod ，开发环境 logging-dev，分支环境使用 loggin-stage。</p>
<h4 id="节点名称"><a href="#节点名称" class="headerlink" title="节点名称"></a>节点名称</h4><p>你可以为每个节点修改他们的节点名称以便于管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node:</div><div class="line">  name: &lt;NAME OF YOUR NODE&gt;</div></pre></td></tr></table></figure></p>
<p>hostname一般存在于服务器的HOSTNAME环境变量中，如果你的机器对于集群运行一个单独的es节点，你可以设置节点名称为hostname<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node:</div><div class="line">  name: $&#123;HOSTNAME&#125;</div></pre></td></tr></table></figure></p>
<h4 id="设置配置文件格式"><a href="#设置配置文件格式" class="headerlink" title="设置配置文件格式"></a>设置配置文件格式</h4><p>在es中，所有的设置都被包围在 anmespaced中。例如，上面这些设置都在node.name中。这意味着可以支持其他格式的配置文件，比如JSON。如果使用JSON，可以将elasticsearch.yml修改为elasticsearch.json。相应的，里面的设置格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;network&quot; : &#123;</div><div class="line">        &quot;host&quot; : &quot;10.0.0.4&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Index设置"><a href="#Index设置" class="headerlink" title="Index设置"></a>Index设置</h3><p>集群中的index可以维护自己的设置。例如，可以将创建index的刷新间隔时间设置为5s。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -XPUT http://localhost:9200/kimchy/ -d \</div><div class="line">&apos;</div><div class="line">index:</div><div class="line">    refresh_interval: 5s</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>Index级别的设置也可以在node级别中设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">index :</div><div class="line">    refresh_interval: 5s</div></pre></td></tr></table></figure></p>
<p>如果index和node都设置了，那么指定的index会覆盖node的设置。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>es内部使用了log4j。配置文件是config/logging.yml。也支持JSON和properties文件。</p>
<h4 id="过期行为的日志"><a href="#过期行为的日志" class="headerlink" title="过期行为的日志"></a>过期行为的日志</h4><p>除了常规的日志，es还能记录过期行为的日志。这对于迁移是一个很大的优势。默认它是关闭的，在 config/logging.yml 开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deprecation: DEBUG, deprecation_log_file</div></pre></td></tr></table></figure></p>
<p>它会在日志目录下创建一个每天滚动的日志文件。定期检查这个文件，针对于当你想要升级到一个新的大版本。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/Elasticsearch学习笔记：一、入门/" itemprop="url">
                  Elasticsearch学习笔记：一、入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T11:59:46+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Elasticsearch是一个分布式的开源的全文分析搜索引擎，它基于Lucene，提供一个接近实时的搜索。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Near-Realtine-NRT"><a href="#Near-Realtine-NRT" class="headerlink" title="Near Realtine(NRT)"></a>Near Realtine(NRT)</h3><p>Es是一个接近实时的搜索平台。这意味着，当你index一个文档到能搜索到它，需要花费一些很少的时间（通常是一秒）。</p>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>cluster是一个由一个或多个服务节点组成的集合，它包含了你所有的数据并提供了对所有节点的索引和搜索。一个cluster会被一个名称唯一标识，默认名称是“elasticsearch”。这个名字非常重要，因为节点会通过集群的名字来确定加入的集群。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>一个节点是你cluster中一个独立的服务，存储数据，组成cluster的index，提供搜索的能力。在一个cluster中，它的节点会被节点名称唯一标识，默认是一个随机的Marvel人物的名称。节点名称对于管理节点是非常重要的。<br>一个节点可以cluster名称来决定参加哪个cluster。默认情况下，在你网络中又多个节点，并且它们可以互相连通，那么它们会自动组成并加入一个名字为”elasticsearch”的cluster。<br>在一个cluster中，如果只有一个节点，那么它会自动形成一个名叫“elasticsearch”的单节点cluster。</p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>index是有相同特征的文档的集合。例如，你可以有一个用户数据的index，或者产品目录的index。一个index被一个名称表示，名称必须是小写字母，这个名称可以用来对文档执行索引、创建，搜索，更新和删除等操作。</p>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>在index中，你可以定义一个或多个type。type是一个逻辑类别还是index的一部分，这些都取决于你的定义。一般来说，一个type是具有相同field的文档。例如，我们假设你运行一个blog平台，并且存储所有的数据在一个单独的index中。在这个index中，你可能会定义一个type为user数据，另一个type为blog数据，还有其它type为评论数据等等。</p>
<h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><p>document是被索引的基本数据单位。例如，你可能有一个文档是针对单个用户，另一个文档是某个商品等。document用JSON来存储。<br>在index/type类型中，你可以存储很多document。</p>
<h3 id="Shards-amp-Replicas"><a href="#Shards-amp-Replicas" class="headerlink" title="Shards &amp; Replicas"></a>Shards &amp; Replicas</h3><p>一个index能够存储非常大量的数据，有时可能会超过单个节点硬件的限制。例如。一个index存储一超过1TB的数据，这对于单个节点有可能是负担不起的。为了解决这个问题，es可以讲index分片到不同的shards中。当你创建一个index，你可以定义你想要的shards数量。每一个shard对于自己来说都是一个拥有所有功能并且有独立的index，可以被放到任何node上。<br>分片有两个重要的优势：</p>
<ul>
<li>它允许你水平 分割/扩展 你的内容。</li>
<li>它允许你并行处理不同分片上的数据来提高效率。 为了保证高可用性，可以为每个分片节点设置备份节点。</li>
</ul>
<p>对于如何进行分片以及进行聚合操作时文档是怎样merge的，es都自动管理了，并且对用户是透明的。</p>
<p>在网络环境中，当某个服务失效了，failover机制是非常有效的高可用保障。es也提供了对于index分片的复制。<br>复制机制有两个重要特点：</p>
<ul>
<li>它提供了高可用性以防一个shard/node失效。值得注意的是，一个shard复制不要和它本身放在同一个节点。</li>
<li>它通过对所有复制shard的并行搜索来提高你系统的吞吐量。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>es运行环境需要jdk1.7及以上，下载jdk直接去oracle官网下。然后<a href="http://www.elastic.co/downloads" target="_blank" rel="external">下载es </a>。<br>解压后，启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elasticsearch-2.4.0/bin/elasticsearch</div></pre></td></tr></table></figure></p>
<p>之前提到过，我们可以覆盖cluster和node名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./elasticsearch --cluster.name my_cluster_name --node.name my_node_name</div></pre></td></tr></table></figure></p>
<h2 id="探索集群和Index"><a href="#探索集群和Index" class="headerlink" title="探索集群和Index"></a>探索集群和Index</h2><p>现在我们已经让节点和集群运行起来了，下一步怎么和es进行沟通交流呢？幸运的是，es提供了一个非常好用的restAPI。通过api我们可以做这些事情：</p>
<ul>
<li>检查集群，节点和index的健康状况，状态和统计数据。</li>
<li>管理集群、节点和index的数据和元数据。</li>
<li>执行CRUD和一些针对index的搜索操作。</li>
<li>执行高级的搜索操作，例如分页，排序，过滤，脚本，聚合以及其他。</li>
</ul>
<h3 id="集群的健康监测"><a href="#集群的健康监测" class="headerlink" title="集群的健康监测"></a>集群的健康监测</h3><p>接下来，我们对集群进行一个基本的简单的健康监测。前文提到了，因为es通过restAPI来进行操作，所以可以使用curl或者postman等。<br>检测cluster的健康状况，我们可以使用_cat API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/health?v&apos;</div></pre></td></tr></table></figure></p>
<p>返回的结果是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign</div><div class="line">1394735289 14:28:09  elasticsearch green           1         1      0   0    0    0        0</div></pre></td></tr></table></figure></p>
<p>其中status显示了当前的健康状况。<br>status的定义如下： </p>
<ul>
<li>green ： everything is ok。 </li>
<li>yellow： 所有数据可用，但是一些备份节点的数据尚未被分配。 </li>
<li>red ： 一些数据不可用。</li>
</ul>
<p>还可以查看节点的状况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/nodes?v&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">host         ip        heap.percent ram.percent load node.role master name</div><div class="line">mwubuntu1    127.0.1.1            8           4 0.00 d         *      New Goblin</div></pre></td></tr></table></figure></p>
<h3 id="查询所有的index"><a href="#查询所有的index" class="headerlink" title="查询所有的index"></a>查询所有的index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/indices?v&apos;</div></pre></td></tr></table></figure>
<p>返回为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">health status index   pri rep docs.count docs.deleted store.size pri.store.size </div><div class="line">yellow open   secilog   5   1          1            0      4.2kb          4.2kb </div><div class="line">green  open   twitter   1   0          2            0      7.2kb          7.2kb</div></pre></td></tr></table></figure></p>
<p>上面显示了，我有两个index，一个secilog，还有一个twitter，当然，这些都是我后来自己建的，新安装的es是没有的，它会返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">health index pri rep docs.count docs.deleted store.size pri.store.size</div></pre></td></tr></table></figure></p>
<h3 id="创建一个Index"><a href="#创建一个Index" class="headerlink" title="创建一个Index"></a>创建一个Index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer?pretty&apos;</div></pre></td></tr></table></figure>
<p>返回：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"acknowledged"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/indices?v&apos;</div><div class="line">health index    pri rep docs.count docs.deleted store.size pri.store.size</div><div class="line">yellow customer   5   1          0            0       495b           495b</div></pre></td></tr></table></figure></p>
<p>这里status是yellow，是因为默认情况下，es默认会为每一个shards创建一个replica，但是由于目前我们只是一个单节点的，所以replica没有地方进行分配，所以就是yellow了。</p>
<h3 id="索引并查询一个文档"><a href="#索引并查询一个文档" class="headerlink" title="索引并查询一个文档"></a>索引并查询一个文档</h3><p>下面我们放一些数据到刚才定义的index中。还记得之前提到过的type么，我们必须为文档指定type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;John Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">  &quot;_type&quot;: &quot;external&quot;,</div><div class="line">  &quot;_id&quot;: &quot;1&quot;,</div><div class="line">  &quot;_version&quot;: 1,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 2,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面显示创建成功了。不过，值得注意的是，如果上面的customer之前不存在，那么es会自动创建一个名为customer的index。</p>
<p>然后我们就可以搜索到了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;localhost:9200/customer/external/1?pretty&apos;</div></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot; : &quot;customer&quot;,</div><div class="line">  &quot;_type&quot; : &quot;external&quot;,</div><div class="line">  &quot;_id&quot; : &quot;1&quot;,</div><div class="line">  &quot;_version&quot; : 1,</div><div class="line">  &quot;found&quot; : true,</div><div class="line">  &quot;_source&quot; : &#123;</div><div class="line">    &quot;name&quot; : &quot;John Doe&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除一个Index"><a href="#删除一个Index" class="headerlink" title="删除一个Index"></a>删除一个Index</h3><p>现在我们可以删除刚刚创建的index：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE &apos;localhost:9200/customer?pretty&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;acknowledged&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据上面的操作，不难看出，es针对index的操作一般遵循这个格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X&lt;REST Verb&gt; &lt;Node&gt;:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</div></pre></td></tr></table></figure></p>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>es提供对于数据的修改以及接近实时的搜索功能。在你index/update/delete数据后，到你可以搜索到这些改变，一般需要1秒钟的延迟。这对于其他平台比如SQL来说，是一个非常大的区别。</p>
<h3 id="创建-替换索引文档"><a href="#创建-替换索引文档" class="headerlink" title="创建/替换索引文档"></a>创建/替换索引文档</h3><p>之前我们已经看到了如何对一个文档进行索引，让我们回顾一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;John Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>接着，上面的操作会为customer创建一个文档，type是external，id是1.如果我们执行同样的操作但是使用不同的数据，es会覆盖之前已经存在的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;localhost:9200/customer/external/1?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>如果我们不指定ID，es会为自动生成一个id并用它来索引文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">  &quot;_type&quot;: &quot;external&quot;,</div><div class="line">  &quot;_id&quot;: &quot;AVdLq7nyMju-ZsxkZnGp&quot;,</div><div class="line">  &quot;_version&quot;: 1,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 2,</div><div class="line">    &quot;successful&quot;: 1,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;created&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<font color="red"><strong>值得注意的是，在不指定ID时，我们应该使用的是POST请求。</strong></font>

<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>为了创建/替换索引文档，我们还可以更新文档的内容。但是，es并不进行就地的更新。当我们执行一个update，es会删除旧的文档然后在桶中索引一个新的文档。</p>
<p>接下来更新之前的id=1的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/1/_update?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>也可以使用script来进行更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/1/_update?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;script&quot; : &quot;ctx._source.age += 5&quot;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>有时可能会返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;error&quot;: &#123;</div><div class="line">    &quot;root_cause&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;type&quot;: &quot;remote_transport_exception&quot;,</div><div class="line">        &quot;reason&quot;: &quot;[Witchfire][127.0.0.1:9300][indices:data/write/update[s]]&quot;</div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    &quot;type&quot;: &quot;illegal_argument_exception&quot;,</div><div class="line">    &quot;reason&quot;: &quot;failed to execute script&quot;,</div><div class="line">    &quot;caused_by&quot;: &#123;</div><div class="line">      &quot;type&quot;: &quot;script_exception&quot;,</div><div class="line">      &quot;reason&quot;: &quot;scripts of type [inline], operation [update] and lang [groovy] are disabled&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;status&quot;: 400</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是由于es基于安全考虑，将脚本功能禁用了，可以在config/elasticsearch.yml文件添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">script.inline: on</div><div class="line">script.indexed: on</div><div class="line">script.file: on</div></pre></td></tr></table></figure></p>
<p>配置后，重启Elasticsearch。</p>
<p>再执行上面的操作，就可以了。</p>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE &apos;localhost:9200/customer/external/2?pretty&apos;</div></pre></td></tr></table></figure>
<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><p>es对于index/uodate/delete等操作也可以进行批量处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/_bulk?pretty&apos; -d &apos;</div><div class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</div><div class="line">&#123;&quot;name&quot;: &quot;John Doe&quot; &#125;</div><div class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</div><div class="line">&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>也可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/external/_bulk?pretty&apos; -d &apos;</div><div class="line">&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</div><div class="line">&#123;&quot;doc&quot;: &#123; &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot; &#125; &#125;</div><div class="line">&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>bulkAPI 会按顺序执行请求。如果某个请求失败了，不管是什么原因，它都会继续执行接下来的请求。当返回结果时，它会告诉你哪些成功哪些失败。</p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h3><p>下面我们来进行一些简单的查询操作。es提供了两种基本的查询方式：</p>
<ul>
<li>REST request URI</li>
<li>REST request body</li>
</ul>
<p>顾名思义，request body就是在请求体中添加参数，而URI则是在 URI中写明参数。<br>下面，用URI方式进行查询请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/customer/_search?q=*&amp;pretty&apos;</div></pre></td></tr></table></figure></p>
<p>来分析一下查询请求，我们使用了_search 在customer index中，q=*说明了es要查询index中所有的文档。preety参数说明返回结果打印的时候打印一个规范的json格式。</p>
<p>返回结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 109,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 3,</div><div class="line">    &quot;max_score&quot;: 1,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">        &quot;_type&quot;: &quot;external&quot;,</div><div class="line">        &quot;_id&quot;: &quot;2&quot;,</div><div class="line">        &quot;_score&quot;: 1,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">        &quot;_type&quot;: &quot;external&quot;,</div><div class="line">        &quot;_id&quot;: &quot;AVdLq7nyMju-ZsxkZnGp&quot;,</div><div class="line">        &quot;_score&quot;: 1,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;Jane Doe&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;customer&quot;,</div><div class="line">        &quot;_type&quot;: &quot;external&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 1,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>针对返回结果，我们可以看到这些部分：</p>
<ul>
<li>took - es用于执行查询所用的时间，单位为毫秒。</li>
<li>time_out - 告诉我们查询是否超时了。</li>
<li>_shards - 告诉我们以供查询了多少shards，以及它们成功与否。</li>
<li>hits - 查询的命中结果。</li>
<li>hits.total - 符合我们查询规则的文档总数。</li>
<li>hits.hits - 查询结果数组，默认为前10个文档。</li>
<li>_score和max_score - 先忽略它们。</li>
</ul>
<p>使用request body查询方式来达到相同的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/bank/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>非常重要的一点，一旦你的搜索结果返回了，那么，es不会保留任何的服务端资源或者在你结果集上的游标。这和其他的平台形成了鲜明的对比，比如SQL，你可能在一开始只是获取到你查询结果的子集，之后还需要向服务器使用某些服务端有状态的游标来抓取剩下的结果集。</p>
<h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><p>首先，我们来看一下返回的文档字段。默认情况下，会返回文档的所有字段，我们可以指定返回的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</div><div class="line">  &quot;_source&quot;: [&quot;name&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>接下来，我们看一下query部分，之前，我们都是使用的match_all，会返回所有的文档。下面我们加一些限制条件，查询name包含Jane 或者 Doe的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123;&quot;name&quot; : &quot;Jane Doe&quot;&#125; &#125;,</div><div class="line">  &quot;_source&quot;: [&quot;name&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>查询name同时包含“Jane Doe”短语的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123;&quot;name&quot; : &quot;Jane Doe&quot;&#125; &#125;,</div><div class="line">  &quot;_source&quot;: [&quot;name&quot;]</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>下面是布尔类型的query，表示and：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;,</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>表示OR：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;should&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;,</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>表示都为false:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must_not&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;,</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>也可以自由组合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Jane&quot; &#125; &#125;</div><div class="line">      ],</div><div class="line">	  &quot;must_not&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;Doe&quot; &#125; &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h3><p>之前提到的score是一个数字，它用来评价当前返回的文档和我们需要的文档的匹配程度。分数越高的匹配程度越好。<br>但是查询并不是总需要产生score，尤其是它们只是用来过滤文档的时候。es能够自动的优化查询并不计算这些无用的score。<br>上文中的bool query也支持filter语句。filter语句可以在不改变score的情况下使用查询语句来限定文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</div><div class="line">      &quot;filter&quot;: &#123;</div><div class="line">        &quot;range&quot;: &#123;</div><div class="line">          &quot;age&quot;: &#123;</div><div class="line">            &quot;gte&quot;: 20000,</div><div class="line">            &quot;lte&quot;: 30000</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>由此可知，有的时候我们不需要关注score，那么久可以用filter来进行查询过滤，因为filter不会去计算score，那么它的效率相应会更高一些。</p>
<h3 id="执行聚合"><a href="#执行聚合" class="headerlink" title="执行聚合"></a>执行聚合</h3><p>聚合可以对数据进行分组并对分组进行数据统计。类似于SQL中的group by。在es中，可以一次性返回查询结果和局和结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/customer/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_name&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;name&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<p>返回结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 159,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 3,</div><div class="line">    &quot;max_score&quot;: 0,</div><div class="line">    &quot;hits&quot;: []</div><div class="line">  &#125;,</div><div class="line">  &quot;aggregations&quot;: &#123;</div><div class="line">    &quot;group_by_state&quot;: &#123;</div><div class="line">      &quot;doc_count_error_upper_bound&quot;: 0,</div><div class="line">      &quot;sum_other_doc_count&quot;: 0,</div><div class="line">      &quot;buckets&quot;: [</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;doe&quot;,</div><div class="line">          &quot;doc_count&quot;: 3</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;jane&quot;,</div><div class="line">          &quot;doc_count&quot;: 3</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;becomes&quot;,</div><div class="line">          &quot;doc_count&quot;: 1</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          &quot;key&quot;: &quot;john&quot;,</div><div class="line">          &quot;doc_count&quot;: 1</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如按官网上的例子，统计不同银行账户下的平均余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/bank/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_state&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;state&quot;,</div><div class="line">        &quot;order&quot;: &#123;</div><div class="line">          &quot;average_balance&quot;: &quot;desc&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;average_balance&quot;: &#123;</div><div class="line">          &quot;avg&quot;: &#123;</div><div class="line">            &quot;field&quot;: &quot;balance&quot;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>或者对聚合进行嵌套，先按年龄范围分组，再统计不同性别的账户平均余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">curl -XPOST &apos;localhost:9200/bank/_search?pretty&apos; -d &apos;</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_age&quot;: &#123;</div><div class="line">      &quot;range&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;age&quot;,</div><div class="line">        &quot;ranges&quot;: [</div><div class="line">          &#123;</div><div class="line">            &quot;from&quot;: 20,</div><div class="line">            &quot;to&quot;: 30</div><div class="line">          &#125;,</div><div class="line">          &#123;</div><div class="line">            &quot;from&quot;: 30,</div><div class="line">            &quot;to&quot;: 40</div><div class="line">          &#125;,</div><div class="line">          &#123;</div><div class="line">            &quot;from&quot;: 40,</div><div class="line">            &quot;to&quot;: 50</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;,</div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;group_by_gender&quot;: &#123;</div><div class="line">          &quot;terms&quot;: &#123;</div><div class="line">            &quot;field&quot;: &quot;gender&quot;</div><div class="line">          &#125;,</div><div class="line">          &quot;aggs&quot;: &#123;</div><div class="line">            &quot;average_balance&quot;: &#123;</div><div class="line">              &quot;avg&quot;: &#123;</div><div class="line">                &quot;field&quot;: &quot;balance&quot;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/21/Nginx学习笔记：六、访问限制/" itemprop="url">
                  Nginx学习笔记：六、访问限制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-21T13:57:22+08:00" content="2016-07-21">
              2016-07-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="限制访问HTTP代理资源"><a href="#限制访问HTTP代理资源" class="headerlink" title="限制访问HTTP代理资源"></a>限制访问HTTP代理资源</h2><h3 id="控制访问"><a href="#控制访问" class="headerlink" title="控制访问"></a>控制访问</h3><p>可以通过客户端IP地址或使用基于HTTP的身份认证。<br>使用IP地址控制访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    deny  192.168.1.2;</div><div class="line">    allow 192.168.1.1/24;</div><div class="line">    allow 127.0.0.1;</div><div class="line">    deny  all;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开启身份验证，可以使用 auth_basic指令。然后用户必须加入他们的有效用户名和密码来获取网站访问权。用户名和密码必须在auth_basic_user_file指定的文件中列举出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    auth_basic &quot;closed website&quot;;</div><div class="line">    auth_basic_user_file conf/htpasswd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以设置某些URL不需要身份认证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    auth_basic &quot;closed website&quot;;</div><div class="line">    auth_basic_user_file conf/htpasswd;</div><div class="line"></div><div class="line">    location /public/ &#123;</div><div class="line">        auth_basic off;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以使用satisfy指令来控制访问，如果需要某一个条件，则使用any ， 如果都需要满足，则使用all。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    satisfy any;</div><div class="line"></div><div class="line">    allow 192.168.1.0/24;</div><div class="line">    deny  all;</div><div class="line"></div><div class="line">    auth_basic           &quot;closed site&quot;;</div><div class="line">    auth_basic_user_file conf/htpasswd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="限制访问"><a href="#限制访问" class="headerlink" title="限制访问"></a>限制访问</h3><ul>
<li>限制访问的连接数<br>首先，使用 limit_conn_zone 指令定义key和共享的内存<br><code>limit_conn_zone $binary_remote_address zone=addr:10m;</code><br>第二步，使用limit_conn 指令指定使用的http 、 server 或者location。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /download/ &#123;</div><div class="line">    limit_conn addr 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里可以基于IP限制连接数，因为使用了$binary_remote_address 变量当做key。连接数也可以通过 server 名称来限制，通过使用$server_name变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    limit_conn_zone $server_name zone=servers:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        limit_conn servers 1000;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>限制访问率<br>限制访问率，首先使用 limit_req_zone 指令设置key和共享内存区域来供计数器使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>rate参数可以设置为每秒请求(r/s)或者每分钟请求 (r/m)。比如30r/m。<br>当设置了共享内存，使用limit_req指令在server 或 location中来限制速率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /search/ &#123;</div><div class="line">    limit_req zone=one burst=5;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，nginx不会再每秒处理多于一个请求在指定的location中。如果速率超过了请求限制，那么会将请求放入队列中延迟处理。burst参数设置了每秒处理请求的最大值，当超过了这个最大值，会返回503.<br>如果不想在设置了burst后有延迟处理，添加nodelay参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">limit_req zone=one burst=5 nodelay;</div></pre></td></tr></table></figure></p>
<ul>
<li>限制带宽<br>限制每个链接的带宽，可以使用limit_rate指令。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /download/ &#123;</div><div class="line">    limit_rate 50k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过这个设置，客户端最多能够下载50k内容通过一个单独的链接。然而，客户端能够开几个链接。所以如果想要更好的控制链接带宽，可以配合限制连接数使用。例如，一个IP一个连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /download/ &#123;</div><div class="line">    limit_conn addr 1;</div><div class="line">    limit_rate 50k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以允许客户端在下载一定量的数据后再进行限速：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">limit_rate_after 500k;</div><div class="line">limit_rate 20k;</div></pre></td></tr></table></figure></p>
<p>下面是一个完整的例子，限制了连接数和带宽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    limit_conn_zone $binary_remote_address zone=addr:10m</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        root /www/data;</div><div class="line">        limit_conn addr 5;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /download/ &#123;</div><div class="line">            limit_conn addr 1;</div><div class="line">            limit_rate 1m;</div><div class="line">            limit_rate 50k;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="限制访问TCP代理资源"><a href="#限制访问TCP代理资源" class="headerlink" title="限制访问TCP代理资源"></a>限制访问TCP代理资源</h2><h3 id="通过IP地址限制访问"><a href="#通过IP地址限制访问" class="headerlink" title="通过IP地址限制访问"></a>通过IP地址限制访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        listen 12345;</div><div class="line">        deny   192.168.1.2;</div><div class="line">        allow  192.168.1.1/24;</div><div class="line">        allow  2001:0db8::/32;</div><div class="line">        deny   all;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="限制TCP连接数"><a href="#限制TCP连接数" class="headerlink" title="限制TCP连接数"></a>限制TCP连接数</h3><p>可以有效的防止DOS攻击。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    limit_conn_zone $binary_remote_addr zone=ip_addr:10m;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大致和HTTP的配置方式差不多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    limit_conn_zone $binary_remote_addr zone=ip_addr:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line">        limit_conn ip_addr 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="限制带宽"><a href="#限制带宽" class="headerlink" title="限制带宽"></a>限制带宽</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    proxy_download_rate 100k;</div><div class="line">    proxy_upload_rate   50k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一个完整的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    limit_conn_zone $binary_remote_addr zone=ip_addr:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line">        limit_conn ip_addr 1;</div><div class="line">        proxy_download_rate 100k;</div><div class="line">        proxy_upload_rate   50k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/18/Nginx学习笔记：五、负载均衡/" itemprop="url">
                  Nginx学习笔记：五、负载均衡
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-18T11:31:02+08:00" content="2016-07-18">
              2016-07-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP-负载均衡"><a href="#HTTP-负载均衡" class="headerlink" title="HTTP 负载均衡"></a>HTTP 负载均衡</h2><h3 id="负载一组服务器"><a href="#负载一组服务器" class="headerlink" title="负载一组服务器"></a>负载一组服务器</h3><p>在nginx中使用一组服务器之前，需要先定义一组服务器，在http块中使用upstream指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    upstream backend &#123;</div><div class="line">        server backend1.example.com weight=5;</div><div class="line">        server backend2.example.com;</div><div class="line">        server 192.0.0.1 backup;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想要将请求发送到一组后端服务器，还需要指定这组服务器的名称，使用 proxy_pass ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://backend;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="选择一个负载均衡的方法"><a href="#选择一个负载均衡的方法" class="headerlink" title="选择一个负载均衡的方法"></a>选择一个负载均衡的方法</h3><ol>
<li><p>轮询<br>根据服务器的权重将请求均匀的分布到所有服务器上。这个是默认的策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">   server backend1.example.com;</div><div class="line">   server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>连接数最小<br>将请求发送到目前连接数最小的服务器上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    least_conn;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ip_hash<br>由客户端IP决定发送到哪个服务器上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    ip_hash;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果哪个服务器需要暂时停止服务，可以使用down指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">    server backend3.example.com down;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>一致性hash<br>通过用户定义的key来决定请求分发到哪台服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    hash $request_uri consistent;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最低延迟和最小连接数<br>选取最低延迟和最小连接数的服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    least_time header;</div><div class="line"></div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>header : 从服务器接收到第一个字节所用的时间。<br>last_byte ： 从服务器接收全部响应所用的时间。</p>
<h3 id="服务器权重"><a href="#服务器权重" class="headerlink" title="服务器权重"></a>服务器权重</h3><p>默认情况下，nginx根据服务器的权重来进行轮训的分发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com weight=5;</div><div class="line">    server backend2.example.com;</div><div class="line">    server 192.0.0.1 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三个服务器设为 backup，只有当前两个服务器不可用时，它才能接收请求。</p>
<h3 id="服务器慢启动"><a href="#服务器慢启动" class="headerlink" title="服务器慢启动"></a>服务器慢启动</h3><p>服务器的慢启动能够保护从刚刚连接超时或者其他的原因不可用的状态恢复的服务器被连接淹没。<br>nginx慢启动可以逐步恢复服务器，一开始将服务器的权重设为0，然后逐步成为设置的权重。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com slow_start=30s;</div><div class="line">    server backend2.example.com;</div><div class="line">    server 192.0.0.1 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="session持久化"><a href="#session持久化" class="headerlink" title="session持久化"></a>session持久化</h3><p>session持久化意味着Nginx标识用户session并将请求发送到与之前相同的服务器上。<br>session支持三种session持久化方法：</p>
<ol>
<li>sticky cookie<br>使用这个方法，nginx会为第一个响应的upstream组添加一个session的cookie，并标识响应请求的服务器。当下次请求时，它会携带一个cookie的值，然后nginx将请求路由到相同的服务器上：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com;</div><div class="line"></div><div class="line">    sticky cookie srv_id expires=1h domain=.example.com path=/;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例子中，srv_id参数设置了cookie的名称。可选的expire参数设置了浏览器保持cookie的时间。可选的参数domian定义了一个设置cookie的domain。可选参数path定义了cookie设置的访问路径。这是最简单的session持久化方法。</p>
<ol>
<li><p>sticky route<br>nginx为第一次接受请求的客户端设置了一个route。所有后续请求将与server指令中识别服务器的route参数进行比较。<br>路由信息取自cookie或者URI。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com route=a;</div><div class="line">    server backend2.example.com route=b;</div><div class="line"></div><div class="line">    sticky route $route_cookie $route_uri;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>cookie learn<br>首先，nginx通过检查请求和响应来发现session标识。然后，nginx“学习”哪个upstream 服务器组和哪个session标识相关联。举荐的，这些标识被传进HTTPcookie。如果请求包含的session已经被“学习”，nginx将会直接将请求发送到关联的服务器上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">   server backend1.example.com;</div><div class="line">   server backend2.example.com;</div><div class="line"></div><div class="line">   sticky learn </div><div class="line">       create=$upstream_cookie_examplecookie</div><div class="line">       lookup=$cookie_examplecookie</div><div class="line">       zone=client_sessions:1m</div><div class="line">       timeout=1h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例子中，upstream的服务器在响应中通过设置cookie “EXAMPLECOOKIE”来创建了一个session。<br>必填的 create 参数指定了怎么创建一个新的session。在例子中，新的session是由upstream服务器发送的cookie “EXAMPLECOOKIE”创建的。<br>必填的参数 lookup 指定了怎么搜索已经存在的session。在例子中，从客户端发送的cookie “EXAMPLECOOKIE” 中查询已经存在的session。<br>必填的参数 zone 指定了一个保存所有session信息的共享内存。<br>这个策略不需要客户端保存任何cookie，所有信息保存在服务器端的共享内存中。</p>
<h3 id="限制连接数"><a href="#限制连接数" class="headerlink" title="限制连接数"></a>限制连接数</h3><p>如果MAX_CONNS已达到限制，该请求可以被放置到队列为提供该队列指令指定其进一步处理。该指令集，可以在队列中同时请求的最大数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    server backend1.example.com  max_conns=3;</div><div class="line">    server backend2.example.com;</div><div class="line"></div><div class="line">    queue 100 timeout=70;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有其它worker进程打开了空闲时keepalive，max_conn限制将会被忽略。结果是，连接到服务器的总数将会超过max_conns。</p>
<h3 id="被动的健康监测"><a href="#被动的健康监测" class="headerlink" title="被动的健康监测"></a>被动的健康监测</h3><p>当nginx认为一个服务器不可用时，它会暂时停止发送请求到这台服务器知道服务器被认为可用。<br>max_fails和fail_timeout —— 这俩是关联的，如果某台服务器在fail_timeout时间内出现了max_fails次连接失败，那么nginx就会认为那个服务器已经挂掉，从而在 fail_timeout时间内不再去查询它，fail_timeout的默认值是10s，max_fails的默认值是1（这意味着一发生错误就认为服务器挂掉），如果把max_fails设为0则表示把这个检查取消。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;                </div><div class="line">    server backend1.example.com;</div><div class="line">    server backend2.example.com max_fails=3 fail_timeout=30s;</div><div class="line">    server backend3.example.com max_fails=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主动的健康监测"><a href="#主动的健康监测" class="headerlink" title="主动的健康监测"></a>主动的健康监测</h3><p>预先发送一个指定的请求到每个服务器，并检测响应信息是否符合检测中的可用条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    upstream backend &#123;</div><div class="line">        zone backend 64k;</div><div class="line"></div><div class="line">        server backend1.example.com;</div><div class="line">        server backend2.example.com;</div><div class="line">        server backend3.example.com;</div><div class="line">        server backend4.example.com;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://backend;</div><div class="line">            health_check;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>zone 指令定义了被worker进程共享的并用来存储服务器组配置的内存区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    proxy_pass http://backend;</div><div class="line">    health_check interval=10 fails=3 passes=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>健康监测的时间间隔是10s，在失败3次后会认为是不可用的，以后需要两次通过监测才能认为是可用的。<br>也可以指定URI进行监测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    proxy_pass http://backend;</div><div class="line">    health_check uri=/some/path;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还可以设置macth块来指定健康监测的响应结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    match server_ok &#123;</div><div class="line">        status 200-399;</div><div class="line">        body !~ &quot;maintenance mode&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://backend;</div><div class="line">            health_check match=server_ok;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以定义返回头中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">match welcome &#123;</div><div class="line">    status 200;</div><div class="line">    header Content-Type = text/html;</div><div class="line">    body ~ &quot;Welcome to nginx!&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用!可以定义非的条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">match not_redirect &#123;</div><div class="line">    status ! 301-303 307;</div><div class="line">    header ! Refresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用DNS配置HTTP负载均衡"><a href="#使用DNS配置HTTP负载均衡" class="headerlink" title="使用DNS配置HTTP负载均衡"></a>使用DNS配置HTTP负载均衡</h3><p>服务器组的配置可以在运行时使用DNS修改。<br>nginx可以监控IP地址对应的域名服务器的变化，并自动将变化应用于nginx，且不用重启。这可以通过在http块中使用resolver指令，和server指令后的 resolver参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    resolver 10.0.0.1 valid=300s ipv6=off;</div><div class="line">    resolver_timeout 10s;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://backend;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    upstream backend &#123;</div><div class="line">        zone backend 32k;</div><div class="line">        least_conn;</div><div class="line">        ...</div><div class="line">        server backend1.example.com resolve;</div><div class="line">        server backend2.example.com resolve;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个示例中,服务器的resolve参数指令将定期通过IP地址重新解析 backend1.example.com和backend2.example.com服务器。默认情况下,NGINX基于TTL重新解析DNS记录,但TTL值可以覆盖resolve指令的valid参数,在我们的示例中是5分钟。<br>如果一个域名对应多个IP地址，那么IP地址会被存到upstream配置中并被负载均衡。在例子中，服务器会使用least_conn来负载均衡。如果一个活多个IP地址被修改、添加或删除，那么这些服务器也会被重新负载。</p>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>nginx的服务器组可以通过HTTP接口来动态配置。配置指令可以用来查看所有服务器或者服务器组，修改服务器参数或者添加删除服务器。</p>
<ul>
<li><p>设置动态配置</p>
<ol>
<li><p>将zone指令放入upstream块中。zone 指令配置了一个区域来共享内存，并设置zone 的名称和大小。服务器组的配置被存放到这个zone中，所有的worker进程都使用同样的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">  		upstream appservers &#123;</div><div class="line">      		zone appservers 64k;</div><div class="line">      		server appserv1.example.com      weight=5;</div><div class="line">      		server appserv2.example.com:8080 fail_timeout=5s;</div><div class="line">      		server reserve1.example.com:8080 backup;</div><div class="line">      		server reserve2.example.com:8080 backup;</div><div class="line">  		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>配置 upstream_conf指令到location块中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  		location /upstream_conf &#123;</div><div class="line">      		upstream_conf;</div><div class="line">      		...</div><div class="line">  		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为其设置访问白名单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">   	location /upstream_conf &#123;</div><div class="line">   	    upstream_conf;</div><div class="line">   	    allow 127.0.0.1;</div><div class="line">   	    deny  all;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>一个完整的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">   	...</div><div class="line">   	# Configuration of the server group</div><div class="line">   	upstream appservers &#123;</div><div class="line">       	zone appservers 64k;</div><div class="line"></div><div class="line">       	server appserv1.example.com      weight=5;</div><div class="line">       	server appserv2.example.com:8080 fail_timeout=5s;</div><div class="line"></div><div class="line">       	server reserve1.example.com:8080 backup;</div><div class="line">       	server reserve2.example.com:8080 backup;</div><div class="line">   	&#125;</div><div class="line"></div><div class="line">   	server &#123;</div><div class="line">       	# Location that proxies requests to the group</div><div class="line">       	location / &#123;</div><div class="line">           	proxy_pass http://appservers;</div><div class="line">           	health_check;</div><div class="line">       	&#125;</div><div class="line"></div><div class="line">       	# Location for configuration requests</div><div class="line">        location /upstream_conf &#123;</div><div class="line">   	        upstream_conf;</div><div class="line">   	        allow 127.0.0.1;</div><div class="line">   	        deny  all;</div><div class="line">   	    &#125;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>动态配置持久化<br>上面的动态配置会随着nginx配置文件的reload而失效，为了让它继续能有效果，需要将upstream服务器从upstream块移动到一个指定的文件中，能够保持upstream服务器的状态。文件的路径要在 state指令中设置。在Linux中，比较推荐的路径是/var/lib/nginx/state/。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    upstream appservers &#123;</div><div class="line">        zone appservers 64k;</div><div class="line">        state /var/lib/nginx/state/appservers.conf;</div><div class="line"></div><div class="line">        # All these servers should be moved to the file using the upstream_conf API:</div><div class="line">        # server appserv1.example.com      weight=5;</div><div class="line">        # server appserv2.example.com:8080 fail_timeout=5s;</div><div class="line">        # server reserve1.example.com:8080 backup;</div><div class="line">        # server reserve2.example.com:8080 backup;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，文件只能被 upstream_conf API来修改，应该避免直接修改文件。</p>
<ul>
<li>动态配置Upstream服务器<br>使用HTTP请求来将配置命令传递给nginx。请求需要有一个合适的URI来获取到location中的upstream_conf指令。请求需要包含upstream参数来确定修改的服务器组。<br>查看所有backup的服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?upstream=appservers&amp;backup=</div></pre></td></tr></table></figure>
</li>
</ul>
<p>添加一个新的服务器到组里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?add=&amp;upstream=appservers&amp;server=appserv3.example.com:8080&amp;weight=2&amp;max_fails=3</div></pre></td></tr></table></figure></p>
<p>删除一个服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?remove=&amp;upstream=appservers&amp;id=2</div></pre></td></tr></table></figure></p>
<p>修改一个服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/upstream_conf?upstream=appservers&amp;id=2&amp;down=</div></pre></td></tr></table></figure></p>
<h2 id="TCP-UDP负载均衡"><a href="#TCP-UDP负载均衡" class="headerlink" title="TCP/UDP负载均衡"></a>TCP/UDP负载均衡</h2><h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><p>首先，需要额皮质一个反向代理来使nginx通过TCP连接或者UDP报文将客户端数据发送到upstream组或者一个代理服务器。</p>
<ol>
<li><p>在顶级目录创建一个stream块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在stream块中定义一个或多个server块</p>
</li>
<li><p>在server块中定义listen指令来监听ip和端口。对于UDP，还需要包含udp参数。TCP在stream块中是默认的，所以listen没有tcp参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 12345;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        listen 53 udp;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过proxy_pass指令来定义将要跳转的代理服务器或者upstream组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    server &#123;</div><div class="line">        listen     12345;</div><div class="line"></div><div class="line">        #TCP traffic will be proxied to the &quot;stream_backend&quot; upstream group</div><div class="line">        proxy_pass stream_backend;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen     12346;</div><div class="line"></div><div class="line">        #TCP traffic will be proxied a proxied server</div><div class="line">        proxy_pass backend.example.com:12346;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen     53 udp;</div><div class="line"></div><div class="line">        #UDP traffic will be proxied to the &quot;dns_servers&quot; upstream group</div><div class="line">        proxy_pass dns_servers;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果你的代理服务器有多个网络接口，你可以配置nginx选一个源ip地址来连接到upstream服务器。这对于后端服务器仅接受指定IP地址访问是有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        listen     127.0.0.1:12345;</div><div class="line">        proxy_pass backend.example.com:12345;</div><div class="line">        proxy_bind 127.0.0.1:12345;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>可以调整两个缓冲区的大小，这两个缓冲区用于nginx缓存客户端和upstream的连接中的数据。如果数据比较小，buffer会自动缩小来节省存储资源。如果有大量的数据,可以通过减少socket的读/写操作次数来增加buffer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    ...</div><div class="line">    server &#123;</div><div class="line">        listen            127.0.0.1:12345;</div><div class="line">        proxy_pass        backend.example.com:12345;</div><div class="line">        proxy_buffer_size 16k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置TCP-UDP负载均衡"><a href="#配置TCP-UDP负载均衡" class="headerlink" title="配置TCP/UDP负载均衡"></a>配置TCP/UDP负载均衡</h3><p>创建一组服务器或upstream组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    upstream stream_backend &#123;</div><div class="line">        ...    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    upstream dns_servers &#123;</div><div class="line">        ...    </div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>剩下和HTTP差不多，如有疑问：<a href="https://www.nginx.com/resources/admin-guide/tcp-load-balancing/" target="_blank" rel="external">https://www.nginx.com/resources/admin-guide/tcp-load-balancing/</a></p>
<h2 id="设置代理协议"><a href="#设置代理协议" class="headerlink" title="设置代理协议"></a>设置代理协议</h2><p>代理协议允许nginx接受客户端连接信息并通过HAproy等发送给代理服务器。</p>
<p>通过代理协议发送的信息包括客户端IP地址、代理服务器IP和它们的端口号。知道原始的IP地址有助于网站的语言设置、访问黑名单或一些简单的log和静态资源。</p>
<p>通过代理协议，nginx可以获取到原始的ip地址通过SSL, HTTP/2, SPDY, WebSocket, 和 TCP。</p>
<h3 id="使用SSL-HTTP-2-SPDY-和-WebSocket-代理协议"><a href="#使用SSL-HTTP-2-SPDY-和-WebSocket-代理协议" class="headerlink" title="使用SSL, HTTP/2, SPDY, 和 WebSocket 代理协议"></a>使用SSL, HTTP/2, SPDY, 和 WebSocket 代理协议</h3><ol>
<li><p>配置nginx接受代理协议报文头。在listen中添加proxy_protocol参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80   proxy_protocol;</div><div class="line">    listen 443  ssl proxy_protocol;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在set_real_ip_from 指令中，指定ip地址或者TCP代理的CIDR地址范围或者负载均衡器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    set_real_ip_from 192.168.1.0/24;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在real_ip_header指令中，添加proxy_protocol参数来保持客户端IP地址和端口号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    real_ip_header proxy_protocol;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过proxy_set_header directive 和 $proxy_protocol_addr变量从nginx传递IP地址到upstream服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_set_header X-Real-IP       $proxy_protocol_addr;</div><div class="line">proxy_set_header X-Forwarded-For $proxy_protocol_addr;</div></pre></td></tr></table></figure>
</li>
<li><p>在http层添加 $proxy_protocol_addr 变量到  log_format指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    log_format combined &apos;$proxy_protocol_addr - $remote_user [$time_local] &apos;</div><div class="line">                        &apos;&quot;$request&quot; $status $body_bytes_sent &apos;</div><div class="line">                        &apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="在TCP流上使用代理协议"><a href="#在TCP流上使用代理协议" class="headerlink" title="在TCP流上使用代理协议"></a>在TCP流上使用代理协议</h3><p>nginx能够就在TCP流上传递代理协议数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 12345;</div><div class="line">        proxy_pass example.com:12345;</div><div class="line">        proxy_protocol on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="完整的样例"><a href="#完整的样例" class="headerlink" title="完整的样例"></a>完整的样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    log_format combined &apos;$proxy_protocol_addr - $remote_user [$time_local] &apos;</div><div class="line">                        &apos;&quot;$request&quot; $status $body_bytes_sent &apos;</div><div class="line">                        &apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&apos;;</div><div class="line">    ...</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        server_name localhost;</div><div class="line"></div><div class="line">        listen 80   proxy_protocol;</div><div class="line">        listen 443  ssl proxy_protocol;</div><div class="line"></div><div class="line">        ssl_certificate      /etc/nginx/ssl/public.example.com.pem;</div><div class="line">        ssl_certificate_key  /etc/nginx/ssl/public.example.com.key;</div><div class="line"></div><div class="line">        set_real_ip_from 192.168.1.0/24;</div><div class="line">        real_ip_header   proxy_protocol;</div><div class="line"></div><div class="line">        location /app/ &#123;</div><div class="line">            proxy_pass       http://backend1;</div><div class="line">            proxy_set_header Host            $host;</div><div class="line">            proxy_set_header X-Real-IP       $proxy_protocol_addr;</div><div class="line">            proxy_set_header X-Forwarded-For $proxy_protocol_addr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">stream &#123;</div><div class="line">...</div><div class="line">    server &#123;</div><div class="line">        listen         12345;</div><div class="line">        proxy_pass     example.com:12345;</div><div class="line">        proxy_protocol on;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/18/Nginx学习笔记：四、配置SSL/" itemprop="url">
                  Nginx学习笔记：四、配置SSL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-18T09:30:57+08:00" content="2016-07-18">
              2016-07-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="通过HTTPS传递Web内容"><a href="#通过HTTPS传递Web内容" class="headerlink" title="通过HTTPS传递Web内容"></a>通过HTTPS传递Web内容</h2><h3 id="配置一个HTTPS服务"><a href="#配置一个HTTPS服务" class="headerlink" title="配置一个HTTPS服务"></a>配置一个HTTPS服务</h3><p>建立一个HTTPS的nginx服务器，在nginx.conf中指定服务器的ssl参数与listen指令，然后设置服务器证书和私钥文件的位置:</p>
<p>x509证书一般会用到三类文，key，csr，crt。</p>
<p>Key 是私用密钥openssl格，通常是rsa算法。</p>
<p>Csr 是证书请求文件，用于申请证书。在制作csr文件的时，必须使用自己的私钥来签署申，还可以设定一个密钥。</p>
<p>crt是CA认证后的证书文，（windows下面的，其实是crt），签署人用自己的key给你签署的凭证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen              443 ssl;</div><div class="line">    server_name         www.example.com;</div><div class="line">    ssl_certificate     www.example.com.crt;</div><div class="line">    ssl_certificate_key www.example.com.key;</div><div class="line">    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_ciphers         HIGH:!aNULL:!MD5;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器证书是一个公共实体。它被发送到每一个连接到服务器的客户端。私钥是一个安全的实体，并应被存储在与限制访问的文件。然而，Nginx的的master进程必须能够读取该文件。私钥也可以和公钥存储在同一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssl_certificate xxx.cert;</div><div class="line">ssl_certificate_key xxx.cert;</div></pre></td></tr></table></figure></p>
<p>在这种情况下，文件的访问权限也需要被限制。虽然公钥和私钥在一个文件中，但是只有公钥会被发送到客户端。</p>
<p>ssl_protocols 和 ssl_ciphers 指令可以用来限制连接的版本和SSL/TLS的加密方式。</p>
<h3 id="https服务优化"><a href="#https服务优化" class="headerlink" title="https服务优化"></a>https服务优化</h3><p>SSL会给CPU带来额外的开销。最耗CPU的是SSL的握手过程。下面有两个方法能够减少每个客户端操作的数量：</p>
<ul>
<li>使keepalive连接通过一个连接发送多个请求</li>
<li>重用SSL会话参数来避免并行和随后的SSL握手连接</li>
</ul>
<p>session存储在SSL的 session缓存中，并被worker进程共享，这个可以用ssl_session_cache 配置。1M的cache可以包含大约4000个session。默认情况下，cache的超时时间是5分钟。超时时间可以用 ssl_session_timeout 来设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">worker_processes auto;</div><div class="line"></div><div class="line">http &#123;</div><div class="line">    ssl_session_cache   shared:SSL:10m;</div><div class="line">    ssl_session_timeout 10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen              443 ssl;</div><div class="line">        server_name         www.example.com;</div><div class="line">        keepalive_timeout   70;</div><div class="line"></div><div class="line">        ssl_certificate     www.example.com.crt;</div><div class="line">        ssl_certificate_key www.example.com.key;</div><div class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SSL证书链"><a href="#SSL证书链" class="headerlink" title="SSL证书链"></a>SSL证书链</h3><p>一些浏览器会报出证书不是由权威机构颁发的，而其他的浏览器则不会有这个问题。这是由于发行机构的证书不是由权威机构的中级证书签发的。这种情况下，发行机构应该提供一个证书链来和服务器证书绑定。在绑定文件中，公钥证书应该在证书链之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat www.example.com.crt bundle.crt &gt; www.example.com.chained.crt</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen              443 ssl;</div><div class="line">    server_name         www.example.com;</div><div class="line">    ssl_certificate     www.example.com.chained.crt;</div><div class="line">    ssl_certificate_key www.example.com.key;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于名称的HTTPS服务"><a href="#基于名称的HTTPS服务" class="headerlink" title="基于名称的HTTPS服务"></a>基于名称的HTTPS服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen          443 ssl;</div><div class="line">    server_name     www.example.com;</div><div class="line">    ssl_certificate www.example.com.crt;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen          443 ssl;</div><div class="line">    server_name     www.example.org;</div><div class="line">    ssl_certificate www.example.org.crt;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于IP：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen          192.168.1.1:443 ssl;</div><div class="line">    server_name     www.example.com;</div><div class="line">    ssl_certificate www.example.com.crt;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen          192.168.1.2:443 ssl;</div><div class="line">    server_name     www.example.org;</div><div class="line">    ssl_certificate www.example.org.crt;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用HTTPS建立TCP连接"><a href="#使用HTTPS建立TCP连接" class="headerlink" title="使用HTTPS建立TCP连接"></a>使用HTTPS建立TCP连接</h2><p>nginx负责https的认证等操作，并把数据返回给后端的服务器处理，后端服务器是http服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">stream &#123;</div><div class="line">    upstream stream_backend &#123;</div><div class="line">         server backend1.example.com:12345;</div><div class="line">         server backend2.example.com:12345;</div><div class="line">         server backend3.example.com:12345;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    server &#123;</div><div class="line">        listen                12345 ssl;</div><div class="line">        proxy_pass            stream_backend;</div><div class="line"> </div><div class="line">        ssl_certificate       /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key   /etc/ssl/certs/server.key;</div><div class="line">        ssl_protocols         SSLv3 TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">        ssl_ciphers           HIGH:!aNULL:!MD5;</div><div class="line">        ssl_session_cache     shared:SSL:20m;</div><div class="line">        ssl_session_timeout   4h;</div><div class="line">        ssl_handshake_timeout 30s;</div><div class="line">		ssl_session_tickets on;</div><div class="line">    …</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>session Ticket 是另一种session缓存。session信息存储在客户端，减少了服务端存储session的压力。当客户端恢复与服务端的交互后，它会提供session并且可以不用再进行握手之类的操作。</p>
<h2 id="为nginx和后端服务器的HTTP连接加密"><a href="#为nginx和后端服务器的HTTP连接加密" class="headerlink" title="为nginx和后端服务器的HTTP连接加密"></a>为nginx和后端服务器的HTTP连接加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    upstream backend.example.com &#123;</div><div class="line">        server backend1.example.com:443;</div><div class="line">        server backend2.example.com:443;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      80;</div><div class="line">        server_name www.example.com;</div><div class="line">        ...</div><div class="line"></div><div class="line">        location /upstream &#123;</div><div class="line">            proxy_pass                    https://backend.example.com;</div><div class="line">            proxy_ssl_certificate         /etc/nginx/client.pem;</div><div class="line">            proxy_ssl_certificate_key     /etc/nginx/client.key</div><div class="line">            proxy_ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">            proxy_ssl_ciphers             HIGH:!aNULL:!MD5;</div><div class="line">            proxy_ssl_trusted_certificate /etc/nginx/trusted_ca_cert.crt;</div><div class="line"></div><div class="line">            proxy_ssl_verify        on;</div><div class="line">            proxy_ssl_verify_depth  2;</div><div class="line">            proxy_ssl_session_reuse on;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend1.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend2.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="为nginx和后端服务器的TCP连接加密"><a href="#为nginx和后端服务器的TCP连接加密" class="headerlink" title="为nginx和后端服务器的TCP连接加密"></a>为nginx和后端服务器的TCP连接加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    upstream backend.example.com &#123;</div><div class="line">        server backend1.example.com:443;</div><div class="line">        server backend2.example.com:443;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      80;</div><div class="line">        server_name www.example.com;</div><div class="line">        ...</div><div class="line"></div><div class="line">        location /upstream &#123;</div><div class="line">            proxy_pass                    https://backend.example.com;</div><div class="line">            proxy_ssl_certificate         /etc/nginx/client.pem;</div><div class="line">            proxy_ssl_certificate_key     /etc/nginx/client.key</div><div class="line">            proxy_ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">            proxy_ssl_ciphers             HIGH:!aNULL:!MD5;</div><div class="line">            proxy_ssl_trusted_certificate /etc/nginx/trusted_ca_cert.crt;</div><div class="line"></div><div class="line">            proxy_ssl_verify        on;</div><div class="line">            proxy_ssl_verify_depth  2;</div><div class="line">            proxy_ssl_session_reuse on;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend1.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      443 ssl;</div><div class="line">        server_name backend2.example.com;</div><div class="line"></div><div class="line">        ssl_certificate        /etc/ssl/certs/server.crt;</div><div class="line">        ssl_certificate_key    /etc/ssl/certs/server.key;</div><div class="line">        ssl_client_certificate /etc/ssl/certs/ca.crt;</div><div class="line">        ssl_verify_client      off;</div><div class="line"></div><div class="line">        location /yourapp &#123;</div><div class="line">            proxy_pass http://url_to_app.com;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/11/Nginx学习笔记：三、基本功能/" itemprop="url">
                  Nginx学习笔记：三、基本功能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-11T15:59:00+08:00" content="2016-07-11">
              2016-07-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><h3 id="设置虚拟服务器"><a href="#设置虚拟服务器" class="headerlink" title="设置虚拟服务器"></a>设置虚拟服务器</h3><p>nginx配置文件中至少需要一个定义了虚拟服务器的server块。当nginx处理请求时，它会首先选择虚拟服务器来处理请求。<br>虚拟服务器定义在http上下文的server块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        # Server configuration</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以在http上下文中定义多个server块。<br>server块通常包含一个listen指令来监听指定的ip的端口。支持ipv4/ipv6，ipv6的地址需要用（）包裹起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 127.0.0.1:8080;</div><div class="line">    # The rest of server configuration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果省略端口号，则使用标准端口号。如果省略ip，那么服务器将监听所有地址。如果省略listen指令，那么标准的端口号是80/tcp，默认的端口号是8000/tcp这取决于root的权限。</p>
<p>server_name 参数用来指定接受访问的host头中的相应参数。它的值可以是一个通配符。如果没有匹配的，那么将路由到默认的服务器上来处理。</p>
<h3 id="配置location"><a href="#配置location" class="headerlink" title="配置location"></a>配置location</h3><p>nginx可以将请求路由到不同的代理或者服务器上，基于请求的uri。这些都是依靠定义在server块中的localtion块来决定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    root html;</div><div class="line">    index  index.html  index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有两种类型的参数：前缀字符串和正则表达式。对于一个请求URI，他必须满足匹配前缀字符串。</p>
<p>正则表达式前面增加 ~ 表示区分大小写，~* 表示不区分大小写。下面的例子匹配所有带有.html或者.htm的URI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location ~ \.html? &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>为了找到最匹配URI的location，nginx会首先搜索前缀字符串，然后再搜索正则表达式。</strong></p>
<p>nginx的处理逻辑为：</p>
<ol>
<li>尝试匹配所有前缀字符串。</li>
<li>= 修饰符定义了一个URI和前缀字符串的精确匹配。如果发现精确匹配,搜索停止。</li>
<li>如果有^~修饰符，则最先考虑最长前缀字符串匹配,正则表达式不检查。</li>
<li>存储最长前缀匹配字符串。</li>
<li>尝试匹配正则表达式。</li>
<li>从第一个匹配的正则表达式跳出递归，并使用相应的location。</li>
<li>如果没有匹配的正则表达式，使用存储的最长匹配的前缀表达式（第4步）的location。</li>
</ol>
<p>location块中包含如何处理的逻辑，要么转到一个静态文件，要么将请求转给一个代理服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    location /images/ &#123;</div><div class="line">        root /data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://www.example.com;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>nginx允许在配置文件中使用自定义的变量。<br><code>set $variable value</code><br><code>map string $variable { ... }</code><br><code>geo [$address] $variable { ... }</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line"> geo $arg_boy $ttlsa_com &#123;</div><div class="line">        default 0;</div><div class="line">        127.0.0.1/24 24;</div><div class="line">        127.0.0.1/32 32;</div><div class="line">        8.8.8.8 2;</div><div class="line">&#125;</div><div class="line"> server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  test.ttlsa.com;</div><div class="line"> </div><div class="line">        location /hello &#123;</div><div class="line"> default_type text/plain;</div><div class="line"> echo $ttlsa_com;</div><div class="line"> echo $arg_boy;</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"># curl 127.0.0.1:8080/hello?boy=127.0.0.1</div><div class="line">32</div><div class="line">127.0.0.1</div><div class="line"># curl 127.0.0.1:8080/hello?boy=127.0.0.12</div><div class="line">24</div><div class="line">127.0.0.12</div></pre></td></tr></table></figure>
<h3 id="返回指定状态码"><a href="#返回指定状态码" class="headerlink" title="返回指定状态码"></a>返回指定状态码</h3><p>一些网站URI需要立即返回指定的错误代码或重定向代码，例如，如果一个页面被暂时或永久的移除，那么，最简单的方法是直接返回相应的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /wrong/url &#123;</div><div class="line">    return 404;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>return 的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">return code [text];</div><div class="line">return code URL;</div><div class="line">return URL;</div></pre></td></tr></table></figure></p>
<p>return 指令可以存在于location和server块中。</p>
<h3 id="重写URI请求"><a href="#重写URI请求" class="headerlink" title="重写URI请求"></a>重写URI请求</h3><p>一个请求的URI可以在处理请求过程中被重写多次，它包括一个可选的和两个必须的参数。第一个必须的参数是请求URI必须满足的正则表达式。第二个参数是用来替换请求URI的URI。可选的参数是一个标志位，它能停止进一步的重写处理或者发送重定向（301或302）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /users/ &#123;</div><div class="line">    rewrite ^/users/(.*)$ /show?user=$1 break;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>rewrite指令可以存在于server和location块中。在server块中，如果server的上下文被选中，那么server块中的rewrite只会执行一次。</p>
<p>rewrite指令用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rewrite regex replacement [flag];</div></pre></td></tr></table></figure></p>
<p>flag 有以下可选值：<br>last: 重新请求搜索是否还有匹配的locaton。<br>break: 不再搜索是否还有匹配的location。<br>redirect：返回一个暂时的重定向代码 ， 302，使用一个不以”<a href="http://&quot;或&quot;https://&quot;开头的代替的字符串。" target="_blank" rel="external">http://&quot;或&quot;https://&quot;开头的代替的字符串。</a><br>permanent： 返回一个永久的重定向代码，301.</p>
<h3 id="重写HTTP返回"><a href="#重写HTTP返回" class="headerlink" title="重写HTTP返回"></a>重写HTTP返回</h3><p>有时候你需要重写或者修改HTTP返回中的内容，把一个字符串替换成其它的。那么，你需要使用sub_filter指令来定义重写。这个指令支持变量和链操作来使复杂的操作变得简单。<br>sub_filter的替换匹配是不区分大小写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  www.github.com;</div><div class="line"> </div><div class="line">    root /data/site/www.github.com;    </div><div class="line"> </div><div class="line">    location / &#123;</div><div class="line">        sub_filter  github &apos;GIT&apos;;</div><div class="line">        sub_filter_types text/html;</div><div class="line">        sub_filter_once on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子将返回数据中的github替换为GIT，然后由于sub_filter_once on ， 所以只替换了一次。结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># curl www.github.com/2013/10/20131001_sub1.html           </div><div class="line">welcome to GIT!</div><div class="line">github TEAM!</div></pre></td></tr></table></figure></p>
<p>sub_filter 可以存在于 http, server, location 块。</p>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>使用error_page 指令，可以为特定的错误码自定义错误页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_page 404 /404.html;</div></pre></td></tr></table></figure></p>
<p>下面的例子中，将404转换为301，并重定向到http:/example.com/new/path.html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /old/path.html &#123;</div><div class="line">    error_page 404 =301 http:/example.com/new/path.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h2><h3 id="Root目录和索引文件"><a href="#Root目录和索引文件" class="headerlink" title="Root目录和索引文件"></a>Root目录和索引文件</h3><p>root指令制定了将要去搜索文件的根目录。为了获得文件路径，nginx为请求的URI添加了指定的root路径。root指令可以在http、server和location块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    root /www/data;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /images/ &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location ~ \.(mp3|mp4) &#123;</div><div class="line">        root /www/media;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子中，如果URI以/images/开始，那么，搜索的路径为/www/data/images/目录。如果URI以.mp3或者.mp4结尾，那么搜索的路径为/www/media/。</p>
<p>如果请求是以/结尾，那么，nginx将其认为是请求目录结构并查找目录里面的索引文件。index命令定义了索引文件名（默认名称为index.html）。接着上面的例子，如果请求是 /images/some/path/ ， nginx将传送文件/www/data/images/some/path/index.html，如果存在的话。如果不存在，nginx返回404。为了让NGINX返回一个自动生成的目录清单,加入autoindex指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /images/ &#123;</div><div class="line">    autoindex on;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以列举不只一个文件名在index指令下。nginx以指定的顺序搜索文件并返回第一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    index index.$geo.html index.htm index.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的$geo变量是一个自定义的geo。它的值取决于客户端的ip地址。</p>
<p>autoindex_exact_size on | off 表示是否显示大小。<br>autoindex_format html | xml | json | jsonp 输出格式<br>autoindex_localtime on | off  显示本地时间或UTC</p>
<h3 id="其它的命令"><a href="#其它的命令" class="headerlink" title="其它的命令"></a>其它的命令</h3><p>try_files 用来检查指定的文件或者目录是否存在，并设置一个重定向或者返回一个指定的状态码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    root /www/data;</div><div class="line"></div><div class="line">    location /images/ &#123;</div><div class="line">        try_files $uri /images/default.gif;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后一个参数可以是状态码或者位置。在下面的例子中，如果try_files的参数中的文件或目录不存在，则返回404。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    try_files $uri $uri/ $uri.html =404;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在下面的例子中，如果原始的URI和URI后面加上/的目录均不存在，那么请求会被重定向到一个代理服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    try_files $uri $uri/ @backend;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location @backend &#123;</div><div class="line">    proxy_pass http://backend.example.com;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提高nginx内容服务速度"><a href="#提高nginx内容服务速度" class="headerlink" title="提高nginx内容服务速度"></a>提高nginx内容服务速度</h3><p>加载速度是重要的考虑因素。做一些小幅的优化配置可能会大幅提高效率甚至达到最佳性能。</p>
<ul>
<li><p>开启sendfile<br>默认情况下，nginx自己控制文件传输，并在发送前把它拷贝到buffer中。使用sendfile命令可以减少拷贝到buffer的步骤，并且直接将一个文件描述符拷贝到另一个。另外,防止一个快速连接完全占用worker进程,可以在sendfile()调用sendfile_max_chunk指令限制传输的数据量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3 &#123;</div><div class="line">    sendfile           on;</div><div class="line">    sendfile_max_chunk 1m;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>开启tcp_nopush<br>配合sendfile一起使用tcp_nopush。一般情况下，在tcp交互的过程中，当应用程序接收到数据包后马上传送出去，不等待，而tcp_cork选项是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞，已经是默认了,tcp_nopush = on 会设置调用tcp_cork方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3 &#123;</div><div class="line">    sendfile   on;</div><div class="line">    tcp_nopush on;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>开启tcp_nodelay<br>与tcp_nopush 是互斥的，有数据的话会立即将数据包发送出去，有可能会造成网络拥堵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /mp3  &#123;</div><div class="line">    tcp_nodelay       on;</div><div class="line">    keepalive_timeout 65;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>优化Backlog Queue<br>nginx处理连接请求也是一个非常重要的优化点。一般情况下，当一个连接建立后，它会被放入listen socket的listen队列。在普通负载下，这是一个小的甚至不存在的队列。但是高负载时，队列会显著增长，这可能导致连接断开或者高延迟。<br><strong>检查listen queue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -lan</div></pre></td></tr></table></figure>
</li>
</ul>
<p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Current listen queue sizes (qlen/incqlen/maxqlen)</div><div class="line">Listen         Local Address         </div><div class="line">0/0/128        *.12345            </div><div class="line">10/0/128        *.80       </div><div class="line">0/0/128        *.8080</div></pre></td></tr></table></figure></p>
<p>说明有10个在80端口的连接未被处理。<br><strong>设置OS</strong><br>设置 net.core.somaxconn 来增大OS的负载能力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vi   /etc/sysctl.conf</div><div class="line">net.core.somaxconn = 4096</div></pre></td></tr></table></figure></p>
<p><strong>设置nginx</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80 backlog 4096;</div><div class="line">    # The rest of server configuration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="发送请求到代理服务器"><a href="#发送请求到代理服务器" class="headerlink" title="发送请求到代理服务器"></a>发送请求到代理服务器</h3><p>当使用nginx代理时，会发送请求到代理服务器，获取相应，然后返回给客户端。它可以代理HTTP请求也可以代理非HTTP请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_pass http://www.example.com/link/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="发送请求头到代理服务器"><a href="#发送请求头到代理服务器" class="headerlink" title="发送请求头到代理服务器"></a>发送请求头到代理服务器</h3><p>默认情况下，nginx会重新定义请求头中的两个域，Host和Connection，Host被设置为$proxy_host变量，Connection被设置为 close。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>防止某个域传递到代理服务器，可以将其设置为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_set_header Accept-Encoding &quot;&quot;;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="设置Buffer"><a href="#设置Buffer" class="headerlink" title="设置Buffer"></a>设置Buffer</h3><p>一般情况下，nginx缓冲代理服务器的相应，直到收到整个相应信息才发送给客户端。缓冲机制能够优化慢客户端，因为如果对于慢客户端nginx同步响应，那么会浪费代理服务器时间。<br><strong>proxy_buffering</strong>，该指令设置缓冲区的大小和数量,从被代理的后端服务器取得的响应内容,会放置到这里. 默认情况下,一个缓冲区的大小等于内存页面大小,可能是4K也可能是8K,这取决于平台。proxy_buffers 8  4k/8k。<br><strong>proxy_buffer_size</strong>，该指令设置缓冲区大小,从代理后端服务器取得的第一部分的响应内容,会放到这里.小的响应header通常位于这部分响应内容里边.默认来说,该缓冲区大小等于指令 proxy_buffers所设置的;但是,你可以把它设置得更小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_buffers 16 4k;</div><div class="line">    proxy_buffer_size 2k;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果关闭buffer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /some/path/ &#123;</div><div class="line">    proxy_buffering off;</div><div class="line">    proxy_pass http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="绑定出口IP"><a href="#绑定出口IP" class="headerlink" title="绑定出口IP"></a>绑定出口IP</h3><p>如果你的代理服务器有多个网络接口，有时需要选择其中一个进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">location /app1/ &#123;</div><div class="line">    proxy_bind 127.0.0.1;</div><div class="line">    proxy_pass http://example.com/app1/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /app2/ &#123;</div><div class="line">    proxy_bind 127.0.0.2;</div><div class="line">    proxy_pass http://example.com/app2/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /app3/ &#123;</div><div class="line">    proxy_bind $server_addr;</div><div class="line">    proxy_pass http://example.com/app3/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h2><p>亚索形影数据对于减小传输数据是非常重要的。然而，在运行时进行压缩还有可能对系统有负面影响。nginx在发送相应数据前进行压缩，但是不会对已经压缩过的数据进行二次压缩（例如，对于代理服务器的）。</p>
<h3 id="开启压缩"><a href="#开启压缩" class="headerlink" title="开启压缩"></a>开启压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip on;</div></pre></td></tr></table></figure>
<p>通常情况下，nginx仅对MIME类型为text/html的相应进行压缩。为了添加压缩的类型，可以使用gzip_types命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_types text/plain application/xml;</div></pre></td></tr></table></figure></p>
<p>指定压缩响应的最小长度，使用gzip_min_length指令。默认是20bytes。（这里设置为1000）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_min_length 1000;</div></pre></td></tr></table></figure></p>
<p>一般情况下，nginx不会压缩代理服务器的请求响应。该请求来自代理服务器的事实是由Via头字段的请求中的存在来确定。使用gzip_proxied指令来配置这些响应的压缩。这个指令有很多参数，来确定哪种代理请求nginx需要压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip_proxied no-cache no-store private expired auth;</div></pre></td></tr></table></figure></p>
<p>一个完整的例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    gzip on;</div><div class="line">    gzip_types      text/plain application/xml;</div><div class="line">    gzip_proxied    no-cache no-store private expired auth;</div><div class="line">    gzip_min_length 1000;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="开启解压缩"><a href="#开启解压缩" class="headerlink" title="开启解压缩"></a>开启解压缩</h3><p>一些客户端不支持gzip编码算法。同时，它又想要存储压缩数据或者压缩相应数据并存入缓存。为了成功发送到客户端，nginx支持在发送到最终客户端时解压缩数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location /storage/ &#123;</div><div class="line">    gunzip on;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="发送压缩文件"><a href="#发送压缩文件" class="headerlink" title="发送压缩文件"></a>发送压缩文件</h3><p>使用gzip_static 命令可以发送一个压缩版本的文件到客户端，若要使用它需要在编译的时候把gzip_static模块编译进去：<br><code>./configure --with-http_gzip_static_module</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    gzip_static on;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当请求 /path/to/file，nginx会查找并发送/path/to/file.gz。如果文件不存在或者客户端不支持gzip，nginx会发送未压缩版本。<br>注意，gzip_static指令不支持实时压缩。它只是使用压缩工具预先压缩文件。要压缩在运行时的内容（不仅是静态内容），使用gzip的指令。</p>
<h2 id="页面内容缓存"><a href="#页面内容缓存" class="headerlink" title="页面内容缓存"></a>页面内容缓存</h2><p>nginx支持缓存，当开启缓存后，nginx缓存从代理服务器返回的数据，并将其缓存到硬盘上，当有请求过来时，先去缓存查找响应。</p>
<h3 id="开启响应缓存"><a href="#开启响应缓存" class="headerlink" title="开启响应缓存"></a>开启响应缓存</h3><p>将 proxy_cache_path 放到http块中来开启缓存。第一个参数是存放缓存文件的路径。keys_zone定义了用于存储缓存条目元数据的共享存储空间名称和大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache keys_zone=one:10m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将proxy_cache放入想进行缓存的协议类型、server块或者location块中。并指定proxy_cache_path中的key_zone。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache keys_zone=one:10m;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        proxy_cache one;</div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://localhost:8000;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，key_zone定义的大小并不限制缓存相应数据的总量。缓存的响应数据本身存储为元数据的一个备份，存在指定的file上。为了限制缓存的数量，可以使用proxy_cache_path的max_size参数，缓存数量可以暂时超过max_size。</p>
<h3 id="控制缓存"><a href="#控制缓存" class="headerlink" title="控制缓存"></a>控制缓存</h3><p>缓存管理器会定期检查缓存的状态。如果缓存大小超过proxy_cache_path中 max_size参数设定的限制,缓存管理器删除最近最少访问的数据。正如前面提到的,缓存数据的数量可以暂时超过限制缓存管理器激活的时间期间。<br>缓存加载器仅会在nginx启动后启动一次。它会将之前缓存的数据加载进来。加载一次缓存可能会消耗大量资源，影响nginx启动后几分钟内的性能。下面有proxy_cacahe_path的几个参数来避免这一情况：</p>
<ul>
<li>loader_threshold ： 加载时间上限，单位是毫秒，默认为200毫秒。</li>
<li>loader_files： 一次迭代的最多条目数，默认是100。</li>
<li>loader_sleeps ： 迭代的间隔，单位是毫秒，默认50。</li>
</ul>
<p><code>proxy_cache_path /data/nginx/cache keys_zone=one:10m loader_threshold=300 loader_files=200;</code></p>
<h3 id="指定对哪个请求进行缓存"><a href="#指定对哪个请求进行缓存" class="headerlink" title="指定对哪个请求进行缓存"></a>指定对哪个请求进行缓存</h3><p>一般情况下，nginx缓存http的get和head方法响应的数据。nginx将请求字符串作为请求的key。如果缓存中存在和请求相同的key，nginx会直接用缓存来响应。可以在http，server，location的上下文中控制哪些进行缓存。</p>
<p>为了改变请求的单词来计算key，可以使用proxy_cache_key:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_key &quot;$host$request_uri$cookie_user&quot;;</div></pre></td></tr></table></figure></p>
<p>定义在必须在请求指定的最低次数以后，响应才会被缓存起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_min_uses 5;</div></pre></td></tr></table></figure></p>
<p>缓存除了GET和HEAD的其他请求，get和head也需要被列举出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_methods GET HEAD POST;</div></pre></td></tr></table></figure></p>
<h3 id="限制或绕过缓存"><a href="#限制或绕过缓存" class="headerlink" title="限制或绕过缓存"></a>限制或绕过缓存</h3><p>默认情况下，响应数据会一直在缓存中。它们只有在缓存超过最大值时，并且它们是最少命中的，才会被淘汰。nginx可以设置淘汰策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_cache_valid 200 302 10m;</div><div class="line">proxy_cache_valid 404      1m;</div></pre></td></tr></table></figure></p>
<p>上面的例子中，返回200或者302都被认为是在10分钟以内有效的。返货404在1分钟以内也是有效的。也可以使用<code>any</code>来设置第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_valid any 5m;</div></pre></td></tr></table></figure></p>
<p>可以定义proxy_cache_bypass指令来决定是否使用cache响应请求。每个参数定义了一个条件并且由变量组成。如果至少有一个参数为空并且不等于0，nginx不会从cache查找响应，会直接去后端服务器请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;</div></pre></td></tr></table></figure></p>
<p><code>proxy_cache_bypass string ...;</code></p>
<p>控制哪些请求不进行缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_no_cache $http_pragma $http_authorization;</div></pre></td></tr></table></figure></p>
<h3 id="从缓存中清除内容"><a href="#从缓存中清除内容" class="headerlink" title="从缓存中清除内容"></a>从缓存中清除内容</h3><p>NGINX可以从缓存中删除过期的缓存文件。这是非常必要的,删除过期的缓存内容,防止同时提供新老版本的web页面。清除缓存时，nginx会收到一个特别的“清除”请求包含一个自定义HTTP头,或“清除”的HTTP方法。</p>
<ul>
<li>配置缓存清除<br>下面配置一个清除的HTTP方法并删除匹配的URL。<br>在http块中，新建一个变量，如下面的 $purge_method ， 它依赖于$request_method变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">        PURGE 1;</div><div class="line">        default 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在location块中已经定义了cache，在 proxy_cache_purge 指令中，指定了会被清除cache的条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen      80;</div><div class="line">    server_name www.example.com;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass  https://localhost:8002;</div><div class="line">        proxy_cache mycache;</div><div class="line"></div><div class="line">        proxy_cache_purge $purge_method;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当 $request_method 为PURGE，则清除。否则不清除。</p>
<ul>
<li>发送清除指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -X PURGE -D – &quot;https://www.example.com/*&quot;</div><div class="line">HTTP/1.1 204 No Content</div><div class="line">Server: nginx/1.5.7</div><div class="line">Date: Sat, 01 Dec 2015 16:33:04 GMT</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上例中，指定的URI中的缓存文件并不删除，它们还会继续存储在磁盘上，直到nginx来操作处理。</p>
<ul>
<li><p>限制访问清除指令<br>比较推荐的是通过设置IP白名单来限制访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">geo $purge_allowed &#123;</div><div class="line">   default         0;  # deny from other</div><div class="line">   10.0.0.1        1;  # allow from localhost</div><div class="line">   192.168.0.0/24  1;  # allow from 10.0.0.0/24</div><div class="line">&#125;</div><div class="line"></div><div class="line">map $request_method $purge_method &#123;</div><div class="line">   PURGE   $purge_allowed;</div><div class="line">   default 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>完全删除cache文件<br><code>proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=mycache:10m purger=on;</code><br>在 proxy_cache_path 加上 purger=on参数。</p>
</li>
<li>完整的例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=mycache:10m purger=on;</div><div class="line"></div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">        PURGE 1;</div><div class="line">        default 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen      80;</div><div class="line">        server_name www.example.com;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass        https://localhost:8002;</div><div class="line">            proxy_cache       mycache;</div><div class="line">            proxy_cache_purge $purge_method;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    geo $purge_allowed &#123;</div><div class="line">       default         0;</div><div class="line">       10.0.0.1        1;</div><div class="line">       192.168.0.0/24  1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map $request_method $purge_method &#123;</div><div class="line">       PURGE   $purge_allowed;</div><div class="line">       default 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Byte范围的缓存"><a href="#Byte范围的缓存" class="headerlink" title="Byte范围的缓存"></a>Byte范围的缓存</h3><p>有时候，将数据放入缓存中是一个很费时的操作，特别是大文件。当第一次请求开始下载一个大文件时，下一次请求必须等待整个文件下载并放入缓存后才能被服务。<br>nginx可以使用cache slice module 来处理。文件被分成较小的“片”。每个请求范围选择特定的片,如果这个范围没有被缓存,那么将会把它放到缓存中。然后其它所有请求这个片数据的请求都会被这个缓存响应。<br>开启范围级别的缓存：</p>
<ol>
<li>为nginx编译进slice模块。</li>
<li><p>指定每个片的大小。片大小应足以使切片快速下载。设置太小可能会导致过度的内存使用和大量的文件描述符,过大的值可能会导致延迟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    slice  1m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在cache key中加入$slice_range<br><code>proxy_cache_key $uri$is_args$args$slice_range;</code></p>
</li>
<li>开启响应的206代码<br><code>proxy_cache_valid 200 206 1h;</code></li>
<li>在发往代理服务器的HTTP头的Range里面加入$slice_range。<br><code>proxy_set_header  Range $slice_range;</code></li>
<li>综合样例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    slice             1m;</div><div class="line">    proxy_cache       cache;</div><div class="line">    proxy_cache_key   $uri$is_args$args$slice_range;</div><div class="line">    proxy_set_header  Range $slice_range;</div><div class="line">    proxy_cache_valid 200 206 1h;</div><div class="line">    proxy_pass        http://localhost:8000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/11/Nginx学习笔记：二、进程和运行时/" itemprop="url">
                  Nginx学习笔记：二、进程和运行时
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-11T11:10:31+08:00" content="2016-07-11">
              2016-07-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>nginx包含一个master进程和一个或多个worker进程。<br>master进程的主要职责是读取和使用配置文件，同时管理worker进程。<br>worker进程用来处理用户请求。Nginx依赖OS的机制来有效的分发请求给worker进程。worker进程的数量定义位于nginx.conf配置文件上，它可以是固定的数目也可以自适应cpu的核心数。<br>定义worker进程的数母，主要参考几个方面，cpu的核心数、存储数据的硬盘数以及负载模式。当不清楚使用哪种策略时，设定为自适应cpu核心数(“auto”)是一个好的方法。</p>
<h2 id="操作Nginx"><a href="#操作Nginx" class="headerlink" title="操作Nginx"></a>操作Nginx</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>重载配置，你可以停止并重启nginx或者发送一个信号给master进程。使用-s发送信号给运行中的nginx。<br><code>nginx -s signal</code><br>signal的值可以为<br>quit<br>reload<br>reopen<br>stop</p>
<p>可以直接用kill命令来直接放松信号到master进程。master进程的ID默认情况下存在 /usr/local/nginx/logs 或者 /var/run 的nginx.pid 文件中。可以在nginx.conf中设置。<br>有两种方式来通过这些信号去控制 Nginx，第一是通过 kill – XXX <pid> 来控制 Nginx，其中 XXX 就是上表中列出的信号名。如果系统中只有一个 Nginx 进程，那也可以通过 killall 命令来完成，例如运行 killall – s HUP nginxPID 来让 Nginx 重新加载配置。<br>master进程有如下信号：<br>TERM, INT     快速关闭程序，中止当前正在处理的请求<br>QUIT     处理完当前请求后，关闭程序<br>HUP     重新加载配置，并开启新的工作进程，关闭就的进程，此操作不会中断请求<br>USR1     重新打开日志文件，用于切换日志，例如每天生成一个新的日志文件<br>USR2     平滑升级可执行程序<br>WINCH     从容关闭工作进程 </pid></p>
<p>单独的worker进程也可以通过信号量来控制，虽然并不是必须的。<br>TERM, INT    快速关闭进程<br>QUIT    处理完当前请求后，关闭进程<br>USR1    重新打开日志文件，用于切换日志，例如每天生成一个新的日志文件<br>WINCH    调试异常终止（需要启用debug_points ）</p>
<h3 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h3><p>为了nginx能够重读配置文件，HUP信号将发送给master进程，master进程首先检查信号的有效性，然后使用新的配置，打开日志文件和心得监听socket。如果这步失败了，那么将回滚并使用旧的配置。如果成功了，会开启新的worker进程，并发送信息给旧的worker进程让它们优雅停机。旧的进程关闭监听socket并继续服务旧的客户端，当所有客户端请求被服务后，旧的worker进程会停机。</p>
<h3 id="分割日志文件"><a href="#分割日志文件" class="headerlink" title="分割日志文件"></a>分割日志文件</h3><p>为了分割日志文件，首先，它们需要被重命名。在那之后，需要向master进程发送USR1信号。master进程会重新打开所有当前打开的日志文件，并将它们分配给当前worker进程正在运行的无权限的用户作为所有者。在成功重新打开日志文件后，master进程会关闭所有打开的文件并发送消息给worker进程来重新打开文件。worker进程也需要立刻打开新文件并关闭旧文件。其结果是，旧文件可以立即适用于后处理，例如压缩。</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>为了升级服务，需要使用新的可执行文件替换旧的。在USR2信号发送到master进程后，master进程首先会将pid文件名加上一个.oldbin后缀。/usr/local/nginx/logs/nginx.pid.oldbin。然后启动一个新的可执行文件来启动新的worker进程。</p>
<p>之后，所有的worker进程（新的和旧的）都继续接收请求，如果WINCH信号发送到了，master进程，那么将会通知worker进程去优雅停机。</p>
<p>经历一段时间后，只有新的worker进程可以处理请求。</p>
<p>需要注意的是，旧的master进程不会关闭监听socket，并且如果需要，它还可以重新启动。如果由于一些原因，新的可执行文件不能使用了，那么会出现以下两种情况中的一种：</p>
<ul>
<li>发送HUP信号到旧的master进程，旧的master进程不重新读配置文件，但会启动一个新的worker进程。在那之后，发送QUIT到新的master进程，所有新的进程将优雅停止。</li>
<li>发送 TERM 信号到新的master进程。然后新的master进程会发送信息到它的worker进程，告诉他们立即停止（如果有新的进程因为某些原因未停止，那么会发送KILL信号来强制停止）。当新的master进程停止后，旧的master进程自动会启动新的worker进程。</li>
</ul>
<p>如果新的master进程退出了，那么旧的，master进程会抛弃带有.oldbin的文件。</p>
<p>如果更新成功，那么旧的master进程会被发送QUIT信号，然后只有新的进程存活。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/11/Nginx学习笔记：一、入门/" itemprop="url">
                  Nginx学习笔记: 一、入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-11T10:32:41+08:00" content="2016-07-11">
              2016-07-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装nginx需要先安装c++ 编译器、pcre 、zlib以及openssl。</p>
<ol>
<li>安装c++ 编译器<br><code>yum install -y gcc gcc-c++</code></li>
<li><p>安装pcre</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz</div><div class="line">$ tar -zxf pcre-8.39.tar.gz</div><div class="line">$ cd pcre-8.39</div><div class="line">$ ./configure</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>安装zlib</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ wget http://zlib.net/zlib-1.2.8.tar.gz</div><div class="line">$ tar -zxf zlib-1.2.8.tar.gz</div><div class="line">$ cd zlib-1.2.8</div><div class="line">$ ./configure</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>安装openssl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ wget http://www.openssl.org/source/openssl-1.0.2f.tar.gz</div><div class="line">$ tar -zxf openssl-1.0.2f.tar.gz</div><div class="line">$ cd openssl-1.0.2f</div><div class="line">$ ./configure  --prefix=/usr/local/openssl</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>安装nginx<br>先下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ wget http://nginx.org/download/nginx-1.11.2.tar.gz</div><div class="line">$ tar zxf nginx-1.11.2.tar.gz</div><div class="line">$ cd nginx-1.11.2</div></pre></td></tr></table></figure>
</li>
</ol>
<p>编译安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./configure --with-pcre=../pcre-8.39 --with-zlib=../zlib-1.28 --with-openssl=../openssl</div><div class="line">$ make &amp; make install</div></pre></td></tr></table></figure></p>
<ol>
<li>启动nginx <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd /usr/local/nginx/sbin</div><div class="line">$ ./nginx</div></pre></td></tr></table></figure>
</li>
</ol>
<p>验证是否启动成功了<br><code>curl -I 127.0.0.1</code><br><img src="http://i.imgur.com/HbB3BQh.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/Redis持久化策略/" itemprop="url">
                  Redis持久化策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T10:24:32+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis提供了两种持久化策略，一种是快照方式（point-in-time snapshot），另一种是只追加文件（append-only file）方式。</p>
<h2 id="快照方式"><a href="#快照方式" class="headerlink" title="快照方式"></a>快照方式</h2><p>快照方式会在某个时刻将所有数据都写入到硬盘中。用户可以根据Redis的配置命令<code>config get dir</code>和<code>config get dbfilename</code>来知道快照文件写入的路径和文件名。</p>
<p>创建快照的方式有以下几种：</p>
<ul>
<li>客户端发送  <code>bgsave</code> 命令（windows不支持此命令），Redis会调用fork创建一个进程来进行备份操作，父进程继续接收执行命令。</li>
<li>客户端发送  <code>save</code> 命令，Redis会进行备份操作，在备份完成之前，不相应其它命令请求。一般不使用此命令，只有在没有足够内存去执行<code>bgsave</code>情况下才使用此命令。</li>
<li>在配置中设置了 <code>save</code> 选项，比如设置为 <code>save 60 10000</code> ， 当60s内有10000次写入则触发bgsave。</li>
<li>当使用 <code>shutdown</code> 关闭Redis时，会先执行<code>save</code>命令，并阻塞所有客户端。</li>
<li>当Redis连接另一Redis，并向对方发送<code>sync</code>开始一次复制命令，如果redis没有正在执行<code>bgsave</code> 或 没有刚刚执行完 <code>bgsave</code>，那么会执行一次<code>bgsave</code>。</li>
</ul>
<p>缺点：<br>如果在进行下一次备份的时候服务器crash了，那么将丢失上次备份到现在的所有记录。</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>aof会将被执行的写命令写到aof文件的末尾，每次恢复的时候直接执行aof文件中的写命令就可以了。用户可以在<code>appendonly</code>配置中打开aof。<code>appendfsync</code>可以控制aof的频率。<code>always</code>是每次写命令都要同步到硬盘，这样会严重降低redis的速度。<code>everysec</code>每秒进行一次同步，显式将多个写命令同步到硬盘，一般使用这个选项。<code>no</code>由OS来确定何时同步。</p>
<p>由于aof文件会越来越大，一是会占用过大的硬盘空间，二是数据恢复会需要很长时间。为了解决这个问题，redis提供了一个<code>bgrewriteaof</code>命令创建一个子进程来移除aof的冗余命令并重写aof文件。redis还提供了<code>auto-aof-rewrite-percentage</code>和<code>auto-aof-rewrite-min-size</code>来自动执行<code>bgrewriteaof</code>。当设置了 <code>auto-aof-rewrite-percentage 100</code>和<code>auto-aof-rewrite-min-size 64mb</code>时，并启动了aof，当aof文件大于64mb 并且aof文件比上一次重写大了至少1倍时，redis将会执行<code>bgrewriteaof</code>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="ChenPeng" />
          <p class="site-author-name" itemprop="name">ChenPeng</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/chenpeng89" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChenPeng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
